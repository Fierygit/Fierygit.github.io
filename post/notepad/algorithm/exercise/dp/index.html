<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>DP - Firefly</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Firefly" /><meta name="description" content="DP 题目汇总 记录一些遇到过的dp问题 DP(Dynamic Programming) 一种解决最优化问题的算法思想。 要求： 重叠子问题 &amp;amp;&amp;amp; 最优子结构 递归： 记忆化搜索 递推： 自底向上 [toc] 比特位计数 给" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.79.0 with theme even" />


<link rel="canonical" href="http://fireflying.top/post/notepad/algorithm/exercise/dp/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="DP" />
<meta property="og:description" content="DP 题目汇总 记录一些遇到过的dp问题 DP(Dynamic Programming) 一种解决最优化问题的算法思想。 要求： 重叠子问题 &amp;&amp; 最优子结构 递归： 记忆化搜索 递推： 自底向上 [toc] 比特位计数 给" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://fireflying.top/post/notepad/algorithm/exercise/dp/" />
<meta property="article:published_time" content="2019-12-28T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-12-28T00:00:00+00:00" />
<meta itemprop="name" content="DP">
<meta itemprop="description" content="DP 题目汇总 记录一些遇到过的dp问题 DP(Dynamic Programming) 一种解决最优化问题的算法思想。 要求： 重叠子问题 &amp;&amp; 最优子结构 递归： 记忆化搜索 递推： 自底向上 [toc] 比特位计数 给">
<meta itemprop="datePublished" content="2019-12-28T00:00:00+00:00" />
<meta itemprop="dateModified" content="2019-12-28T00:00:00+00:00" />
<meta itemprop="wordCount" content="5818">



<meta itemprop="keywords" content="DP," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="DP"/>
<meta name="twitter:description" content="DP 题目汇总 记录一些遇到过的dp问题 DP(Dynamic Programming) 一种解决最优化问题的算法思想。 要求： 重叠子问题 &amp;&amp; 最优子结构 递归： 记忆化搜索 递推： 自底向上 [toc] 比特位计数 给"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Firefly</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Firefly</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">DP</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-12-28 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#center-dp-题目汇总-center"><center> DP 题目汇总 </center></a>
      <ul>
        <li>
          <ul>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="center-dp-题目汇总-center"><center> DP 题目汇总 </center></h1>
<p>记录一些遇到过的dp问题</p>
<p>DP(Dynamic Programming) 一种解决最优化问题的算法思想。</p>
<p>要求： <strong>重叠子问题</strong> &amp;&amp; <strong>最优子结构</strong></p>
<ul>
<li>
<p>递归： 记忆化搜索</p>
</li>
<li>
<p>递推： 自底向上</p>
</li>
</ul>
<p>[toc]</p>
<h4 id="比特位计数">比特位计数</h4>
<blockquote>
<p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
</blockquote>
<h4 id="最大连续子序和">最大连续子序和</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">{</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="最长不下降子序列">最长不下降子序列</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>  <span class="p">(</span><span class="err">贪心也可以</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="最长公共子序列lcs">最长公共子序列（LCS）</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    		<span class="n">max</span><span class="p">{</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="最长回文子串">最长回文子串</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    		<span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="01-背包问题">01 背包问题</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">{</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="完全背包问题">完全背包问题</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">{</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span> <span class="o">-</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="非相连最大和">非相连最大和</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sum</span><span class="p">(</span><span class="n">k</span> <span class="err">–</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">sum</span><span class="p">(</span><span class="n">k</span> <span class="err">–</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="leetcode---dp中等专题">leetcode - dp中等专题</h4>
<h5 id="60不同的二叉搜索树">60.不同的二叉搜索树</h5>
<blockquote>
<p>一组数据能够构成二叉树的最多的装填类型</p>
</blockquote>
<p><em>F</em>(<em>i</em>,<em>n</em>)=<em>G</em>(<em>i</em>−1)⋅<em>G</em>(<em>n</em>−<em>i</em>)</p>
<p>把一组数据看成左右和中间一点</p>
<h5 id="198打家劫舍">198.打家劫舍</h5>
<blockquote>
<p>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
</blockquote>
<p>dp[i + 2] = max(dp[i] + nums[i], dp[i+1]);</p>
<p>对于一家要么偷（取前两个之前最大的和加上前两个）， 要么不偷（取前面一个的就行了）</p>
<h5 id="740-删除与获得点数">740. 删除与获得点数</h5>
<blockquote>
<p>给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
</blockquote>
<p>nums = [2, 2, 3, 3, 3, 4]	变换一下	all=[0, 0, 2, 3, 1];</p>
<p>dp[i + 2] = max(dp[i] + i * nums[i], dp[i+1]);</p>
<p>和打家劫舍一样</p>
<h5 id="面试题-0811-硬币">面试题 08.11. 硬币</h5>
<blockquote>
<p>给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">coin</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">coin</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coin</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="464-我能赢吗">464. 我能赢吗</h5>
<blockquote>
<p>在 &ldquo;100 game&rdquo; 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？</p>
</blockquote>
<p>使用 dfs +  状态记忆就可以了, 太巧秒了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="err">满足条件</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">cur</span> <span class="o">+</span> <span class="n">i</span><span class="p">)){</span><span class="c1">// 注意这里是输的，状态反过来了
</span><span class="c1"></span>			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="523-连续的子数组和">523. 连续的子数组和</h5>
<blockquote>
<p>给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p>
</blockquote>
<p>1、 使用前缀和的方法，将 O（n^3） 优化为 O（n^ 2）</p>
<p>2、 很巧妙，记录所有前缀和的取余的数据</p>
<p>j &ndash;  i 如果是满足答案的， 那么， 前缀和 map[j % k] == map[i % k], 可以证明得到</p>
<h5 id="375-猜数字大小-ii">375. 猜数字大小 II</h5>
<blockquote>
<p>我们正在玩一个猜数游戏，游戏规则如下：我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。</p>
</blockquote>
<h5 id="718-最长重复子数组">718. 最长重复子数组</h5>
<blockquote>
<p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>
</blockquote>
<p>dp [i] [j] 表示A 从 i 和  B 从 j的最长的前缀和</p>
<h5 id="376-摆动序列">376. 摆动序列</h5>
<blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
</blockquote>
<p>摆动序列和一个数组的最大乘积和是一样的， 要记录两个状态！！！</p>
<h5 id="剑指-offer-14--ii-剪绳子-ii">剑指 Offer 14- II. 剪绳子 II</h5>
<blockquote>
<p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m]</code> 。请问 <code>k[0]*k[1]*...*k[m]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</blockquote>
<p>这道题是一道数学题， 只要一直往3 减去就好了。</p>
<h5 id="983-最低票价">983. 最低票价</h5>
<blockquote>
<p>难度中等237收藏分享切换为英文关注反馈</p>
</blockquote>
<blockquote>
<p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 <code>days</code> 的数组给出。每一项是一个从 <code>1</code> 到 <code>365</code> 的整数。</p>
</blockquote>
<blockquote>
<p>火车票有三种不同的销售方式：</p>
</blockquote>
<ul>
<li>一张为期一天的通行证售价为 <code>costs[0]</code> 美元；</li>
<li>一张为期七天的通行证售价为 <code>costs[1]</code> 美元；</li>
<li>一张为期三十天的通行证售价为 <code>costs[2]</code> 美元。</li>
</ul>
<blockquote>
<p>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
</blockquote>
<p>返回你想要完成在给定的列表 <code>days</code> 中列出的每一天的旅行所需要的最低消费。</p>
<p>我们用 dp*(*i*) 来表示从第  i  天开始到一年的结束，我们需要花的钱。</p>
<h5 id="221-最大正方形">221. 最大正方形</h5>
<blockquote>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
</blockquote>
<p>dp[i] [j] 表示在i, j 点的最大大正方形</p>
<p>dp 转移方程只要去左边，左上和上边最小的就可以了</p>
<h5 id="面试题-0105-一次编辑">面试题 01.05. 一次编辑</h5>
<blockquote>
<p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
</blockquote>
<p>dp[i] [j] 表示 第一个字符在 i， 第二个字符在 j 的时候编辑次数, 模拟出删除，替换，和拆入</p>
<h5 id="376-摆动序列-1">376. 摆动序列</h5>
<blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
</blockquote>
<p>和整数和一样，使用两个记录状态和， 也可以直接贪心， 因为前面的跟后面的没有关系，前面一个是上升的就接着找下一个下降的就行</p>
<h5 id="718-最长重复子数组-1">718. 最长重复子数组</h5>
<blockquote>
<p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>
</blockquote>
<p>二维dp</p>
<h5 id="面试题-0802-迷路的机器人">面试题 08.02. 迷路的机器人</h5>
<blockquote>
<p>设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。</p>
</blockquote>
<p>可以使用 dfs 加上减枝， 也可以使用dfs，相当于 bfs</p>
<h5 id="面试题-1706-2出现的次数">面试题 17.06. 2出现的次数</h5>
<blockquote>
<p>编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。</p>
</blockquote>
<p>遍历每一位数字， 计算每一位数字大于2， 等于 2， 小于 2 的情况！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">numberOf2sInRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">exatnum</span> <span class="o">=</span> <span class="n">n</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">post</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">post</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">exatnum</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">){</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="p">(</span><span class="n">pre</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">base</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">exatnum</span><span class="o">==</span><span class="mi">2</span><span class="p">){</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">pre</span><span class="o">*</span><span class="n">base</span> <span class="o">+</span> <span class="n">post</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">pre</span><span class="o">*</span><span class="n">base</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">post</span> <span class="o">+=</span> <span class="n">exatnum</span><span class="o">*</span><span class="n">base</span><span class="p">;</span>
        <span class="n">exatnum</span> <span class="o">=</span> <span class="n">pre</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
        <span class="n">pre</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">base</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="1367-二叉树中的列表">1367. 二叉树中的列表</h5>
<blockquote>
<p>给你一棵以 <code>root</code> 为根的二叉树和一个 <code>head</code> 为第一个节点的链表。</p>
<p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 <code>head</code> 为首的链表中每个节点的值，那么请你返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p>
</blockquote>
<p>暴力， 没有什么难度</p>
<h5 id="95-不同的二叉搜索树-ii">95. 不同的二叉搜索树 II</h5>
<blockquote>
<p>给定一个整数 <em>n</em>，生成所有由 1 &hellip; <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p>
</blockquote>
<p>太巧妙了！！！， 递归的优雅之处！！！， <strong>看到停下来，</strong> <strong>再看一遍</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">vector</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">helper</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span><span class="n">nullptr</span><span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">start</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">left</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">right</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">a</span><span class="p">:</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">b</span><span class="p">:</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
                <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="1372-二叉树中的最长交错路径">1372. 二叉树中的最长交错路径</h5>
<blockquote>
<p>给你一棵以 <code>root</code> 为根的二叉树，二叉树中的交错路径定义如下：</p>
</blockquote>
<ul>
<li>选择二叉树中 <strong>任意</strong> 节点和一个方向（左或者右）。</li>
<li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</li>
<li>改变前进方向：左变右或者右变左。</li>
<li>重复第二步和第三步，直到你在树中无法继续移动。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">maxAns</span><span class="p">;</span>
    <span class="cm">/* 0 =&gt; left, 1 =&gt; right */</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">o</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dir</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxAns</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxAns</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> 

    <span class="kt">int</span> <span class="nf">longestZigZag</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">maxAns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">maxAns</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="213-打家劫舍-ii">213. 打家劫舍 II</h5>
<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈，**这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
</blockquote>
<p>分位两种情况来计算dp！</p>
<h5 id="279-完全平方数">279. 完全平方数</h5>
<blockquote>
<p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
</blockquote>
<p>二维dp</p>
<h5 id="5-最长回文子串">5. 最长回文子串</h5>
<blockquote>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
</blockquote>
<p>dp[i] [j] 表示 从 i 到 j 是一个回文子串</p>
<h5 id="面试题-1708-马戏团人塔">面试题 17.08. 马戏团人塔</h5>
<p>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="n">using</span> <span class="n">vint</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">bestSeqAtIndex</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">height</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">height</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vint</span><span class="o">&gt;</span> <span class="n">k</span><span class="p">(</span><span class="n">len</span><span class="p">,</span><span class="n">vint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>        
        <span class="n">sort</span><span class="p">(</span><span class="n">k</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">k</span><span class="p">.</span><span class="n">end</span><span class="p">(),[](</span><span class="k">const</span> <span class="n">vint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span><span class="k">const</span> <span class="n">vint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">else</span> <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">});</span>
        <span class="n">vint</span> <span class="nf">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">m</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">m</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
            <span class="k">else</span> <span class="n">m</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="516-最长回文子序列">516. 最长回文子序列</h5>
<blockquote>
<p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p>
</blockquote>
<p>二维dp</p>
<h5 id="1143-最长公共子序列">1143. 最长公共子序列</h5>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。</p>
<p>二维dp</p>
<h5 id="801-使序列递增的最小交换次数">801. 使序列递增的最小交换次数</h5>
<blockquote>
<p>我们有两个长度相等且不为空的整型数组 <code>A</code> 和 <code>B</code> 。</p>
<p>我们可以交换 <code>A[i]</code> 和 <code>B[i]</code> 的元素。注意这两个元素在各自的序列中应该处于相同的位置。</p>
<p>在交换过一些元素之后，数组 <code>A</code> 和 <code>B</code> 都应该是严格递增的（数组严格递增的条件仅为<code>A[0] &lt; A[1] &lt; A[2] &lt; ... &lt; A[A.length - 1]</code>）。</p>
<p>给定数组 <code>A</code> 和 <code>B</code> ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。</p>
</blockquote>
<p>没懂，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，
没懂，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，</p>
<h5 id="1314-矩阵区域和">1314. 矩阵区域和</h5>
<blockquote>
<p>给你一个 <code>m * n</code> 的矩阵 <code>mat</code> 和一个整数 <code>K</code> ，请你返回一个矩阵 <code>answer</code> ，其中每个 <code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和：</p>
</blockquote>
<ul>
<li><code>i - K &lt;= r &lt;= i + K, j - K &lt;= c &lt;= j + K</code></li>
<li><code>(r, c)</code> 在矩阵内。</li>
</ul>
<p>使用前缀和记录每一个小矩阵的值， easy</p>
<h5 id="931-下降路径最小和">931. 下降路径最小和</h5>
<blockquote>
<p>给定一个<strong>方形</strong>整数数组 <code>A</code>，我们想要得到通过 <code>A</code> 的<em>下降路径</em>的<strong>最小</strong>和。</p>
<p>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。</p>
</blockquote>
<p>easy dp[i] [j] 表示为 在 i， j 位置的最小和</p>
<h5 id="剑指-offer-63-股票的最大利润">剑指 Offer 63. 股票的最大利润</h5>
<blockquote>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
</blockquote>
<p>贪心， 只需要记住之前最小的股票价格就好了</p>
<h5 id="1339-分裂二叉树的最大乘积">1339. 分裂二叉树的最大乘积</h5>
<blockquote>
<p>给你一棵二叉树，它的根为 <code>root</code> 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">maxProduct</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">postOrder</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="kt">long</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 取最大值时不能取模，应该用long型存结果
</span><span class="c1"></span>        <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">sums</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">-</span> <span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">res</span> <span class="o">%</span> <span class="n">mod</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">postOrder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">res</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">postOrder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">postOrder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="n">sums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>太巧妙了， 后序遍历的做法， 太太太太太太太太太太太太巧妙了！！！*****************************************</p>
<h5 id="435-无重叠区间">435. 无重叠区间</h5>
<blockquote>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p><strong>注意:</strong></p>
<ol>
<li>可以认为区间的终点总是大于它的起点。</li>
<li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li>
</ol>
</blockquote>
<p>求最长上升子序列, 模版题记住！！！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
    <span class="n">using</span> <span class="n">vint</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">using</span> <span class="n">vvint</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vint</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">eraseOverlapIntervals</span><span class="p">(</span><span class="n">vvint</span><span class="o">&amp;</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">intervals</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">intervals</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">intervals</span><span class="p">.</span><span class="n">end</span><span class="p">(),[](</span><span class="k">const</span> <span class="n">vint</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vint</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">});</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">intervals</span><span class="p">){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="n">end</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">ans</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>  
            <span class="k">else</span>   <span class="n">end</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="646-最长数对链">646. 最长数对链</h5>
<blockquote>
<p>给出 <code>n</code> 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p>
<p>现在，我们定义一种跟随关系，当且仅当 <code>b &lt; c</code> 时，数对<code>(c, d)</code> 才可以跟在 <code>(a, b)</code> 后面。我们用这种形式来构造一个数对链。</p>
<p>给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p>
</blockquote>
<p>和上题基本一样， 模版题来的！！！</p>
<h5 id="1477-找两个和为目标值且不重叠的子数组">1477. 找两个和为目标值且不重叠的子数组</h5>
<blockquote>
<p>给你一个整数数组 <code>arr</code> 和一个整数值 <code>target</code> 。</p>
<p>请你在 <code>arr</code> 中找 <strong>两个互不重叠的子数组</strong> 且它们的和都等于 <code>target</code> 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 <strong>最小值</strong> 。</p>
<p>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 <strong>-1</strong> 。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"> <span class="kt">int</span> <span class="nf">minSumOfLengths</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
     <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">200000</span><span class="p">;</span> 
     <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">len</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">200000</span><span class="p">);</span>
     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//l,r是滑动区间的左右坐标
</span><span class="c1"></span>         <span class="n">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
         <span class="k">while</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="n">sum</span> <span class="o">-=</span> <span class="n">arr</span><span class="p">[</span><span class="n">r</span><span class="o">--</span><span class="p">];</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
             <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//子数组长度
</span><span class="c1"></span>             <span class="n">ans</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">cur</span> <span class="o">+</span> <span class="n">len</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span> <span class="c1">//子数组长度 + 后面子数组的最小长度
</span><span class="c1"></span>             <span class="n">len</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cur</span><span class="p">);</span> <span class="c1">//更新子数组的最小长度
</span><span class="c1"></span>         <span class="p">}</span>
         <span class="k">else</span> <span class="n">len</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">//更新子数组的最小长度
</span><span class="c1"></span>     <span class="p">}</span>
     <span class="k">return</span> <span class="n">ans</span> <span class="o">==</span> <span class="mi">200000</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ans</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>很巧妙，多看看， 使用滑动窗口解决问题</p>
<h5 id="650-只有两个键的键盘">650. 只有两个键的键盘</h5>
<blockquote>
<p>最初在一个记事本上只有一个字符 &lsquo;A&rsquo;。你每次可以对这个记事本进行两种操作：</p>
<ol>
<li><code>Copy All</code> (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。</li>
<li><code>Paste</code> (粘贴) : 你可以粘贴你<strong>上一次</strong>复制的字符。</li>
</ol>
<p>给定一个数字 <code>n</code> 。你需要使用最少的操作次数，在记事本中打印出<strong>恰好</strong> <code>n</code> 个 &lsquo;A&rsquo;。输出能够打印出 <code>n</code> 个 &lsquo;A&rsquo; 的最少操作次数。</p>
</blockquote>
<p>steps[n] = steps[i] + n/i, 核心在于找到最大的因子， 这样可以尽可能的少操作数据</p>
<h5 id="712-两个字符串的最小ascii删除和">712. 两个字符串的最小ASCII删除和</h5>
<blockquote>
<p>给定两个字符串<code>s1, s2</code>，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p>
</blockquote>
<p>聪明一点，这道题就是 LCS的扩展版！！！！！！！！！！！！！！！！！和 lcs 基本是一样的啊啊啊啊啊啊</p>
<h5 id="494-目标和">494. 目标和</h5>
<blockquote>
<p>给定一个非负整数数组，a1, a2, &hellip;, an, 和一个目标数，S。现在你有两个符号 <code>+</code> 和 <code>-</code>。对于数组中的任意一个整数，你都可以从 <code>+</code> 或 <code>-</code>中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTargetSumWays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">S</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">2001</span><span class="o">];</span>
    <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">1000</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
    <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">][-</span><span class="n">nums</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="n">1</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="o">-</span><span class="n">1000</span><span class="o">;</span> <span class="n">sum</span> <span class="o">&lt;=</span> <span class="n">1000</span><span class="o">;</span> <span class="n">sum</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="n">1000</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="n">1000</span><span class="o">];</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">sum</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">1000</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">sum</span> <span class="o">+</span> <span class="n">1000</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">S</span> <span class="o">&gt;</span> <span class="n">1000</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">S</span> <span class="o">+</span> <span class="n">1000</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>背包问题的修改， 强！ 要点在于加上了 1000， 处理负数的情况</p>
<h5 id="1155-掷骰子的n种方法">1155. 掷骰子的N种方法</h5>
<blockquote>
<p>这里有 <code>d</code> 个一样的骰子，每个骰子上都有 <code>f</code> 个面，分别标号为 <code>1, 2, ..., f</code>。</p>
<p>我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。</p>
<p>如果需要掷出的总点数为 <code>target</code>，请你计算出有多少种不同的组合情况（所有的组合情况总共有 <code>f^d</code> 种），<strong>模 <code>10^9 + 7</code></strong> 后返回。</p>
</blockquote>
<p>dp[i] [j] 表示前i 个筛子， 得分为j的情况</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">numRollsToTarget</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="p">;</span> <span class="n">j</span> <span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">f</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">-</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">++</span><span class="p">){</span><span class="c1">// 对于每一种的取分，
</span><span class="c1"></span>                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="n">k</span><span class="p">];</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">%=</span> <span class="n">mod</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span>  <span class="n">dp</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">target</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>比较难的 3 维dp 问题。</p>
<h5 id="1277-统计全为-1-的正方形子矩阵">1277. 统计全为 1 的正方形子矩阵</h5>
<blockquote>
<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数。</p>
</blockquote>
<p>和中间是正方形的做法是一样的！</p>
<p>dp[i] [j] 表示到 i ，j 时是否为正方形</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Firefly</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2019-12-28
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/dp/">DP</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/notepad/algorithm/exercise/hnu_acm/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">ACM_exercise</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/notepad/algorithm/exercise/exercise100/">
            <span class="next-text nav-default">Test</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="http://github.com/fierygit" class="iconfont icon-github" title="github"></a>
  <a href="http://fireflying.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>Firefly</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
