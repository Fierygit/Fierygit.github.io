<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>bash-archives - Firefly</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Firefly" /><meta name="description" content="归档和备份 gzip gzip 程序用来压缩文件，原文件的压缩版（添加gz后缀名）会替代原文件。gunzip 程序用来还原压缩版本。 1 2 $ gzip foo.txt $ gunzip foo.txt.gz gzip的参" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.79.0 with theme even" />


<link rel="canonical" href="http://fireflying.top/post/notepad/docs/bash/bash-archives/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="bash-archives" />
<meta property="og:description" content="归档和备份 gzip gzip 程序用来压缩文件，原文件的压缩版（添加gz后缀名）会替代原文件。gunzip 程序用来还原压缩版本。 1 2 $ gzip foo.txt $ gunzip foo.txt.gz gzip的参" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://fireflying.top/post/notepad/docs/bash/bash-archives/" />
<meta property="article:published_time" content="2020-12-29T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-12-29T00:00:00+00:00" />
<meta itemprop="name" content="bash-archives">
<meta itemprop="description" content="归档和备份 gzip gzip 程序用来压缩文件，原文件的压缩版（添加gz后缀名）会替代原文件。gunzip 程序用来还原压缩版本。 1 2 $ gzip foo.txt $ gunzip foo.txt.gz gzip的参">
<meta itemprop="datePublished" content="2020-12-29T00:00:00+00:00" />
<meta itemprop="dateModified" content="2020-12-29T00:00:00+00:00" />
<meta itemprop="wordCount" content="20753">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="bash-archives"/>
<meta name="twitter:description" content="归档和备份 gzip gzip 程序用来压缩文件，原文件的压缩版（添加gz后缀名）会替代原文件。gunzip 程序用来还原压缩版本。 1 2 $ gzip foo.txt $ gunzip foo.txt.gz gzip的参"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Firefly</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Firefly</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">bash-archives</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-12-29 </span>
        <div class="post-category">
            <a href="/categories/bash/"> bash </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#归档和备份">归档和备份</a>
      <ul>
        <li><a href="#gzip">gzip</a></li>
        <li><a href="#bzip2">bzip2</a></li>
        <li><a href="#zip">zip</a></li>
        <li><a href="#tar">tar</a></li>
        <li><a href="#rsync">rsync</a></li>
      </ul>
    </li>
    <li><a href="#异步任务">异步任务</a></li>
    <li><a href="#shell-的命令">Shell 的命令</a>
      <ul>
        <li><a href="#命令的类别">命令的类别</a></li>
        <li><a href="#type-whatis">type, whatis</a></li>
        <li><a href="#apropos">apropos</a></li>
        <li><a href="#alias-unalias">alias, unalias</a></li>
        <li><a href="#which">which</a></li>
        <li><a href="#helpman">help，man</a></li>
        <li><a href="#script">script</a></li>
        <li><a href="#export">export</a></li>
        <li><a href="#命令的连续执行">命令的连续执行</a></li>
      </ul>
    </li>
    <li><a href="#文件系统">文件系统</a>
      <ul>
        <li><a href="#pwd">pwd</a></li>
        <li><a href="#cd">cd</a></li>
        <li><a href="#ls">ls</a></li>
        <li><a href="#stat">stat</a></li>
        <li><a href="#touch">touch</a></li>
        <li><a href="#file">file</a></li>
        <li><a href="#chmod">chmod</a></li>
        <li><a href="#umask">umask</a></li>
        <li><a href="#du">du</a></li>
        <li><a href="#md5sum">md5sum</a></li>
        <li><a href="#locate">locate</a></li>
        <li><a href="#find">find</a></li>
        <li><a href="#xargs">xargs</a></li>
      </ul>
    </li>
    <li><a href="#文件操作">文件操作</a>
      <ul>
        <li><a href="#cp">cp</a></li>
        <li><a href="#mkdir">mkdir</a></li>
        <li><a href="#mv">mv</a></li>
        <li><a href="#rm">rm</a></li>
        <li><a href="#ln">ln</a></li>
      </ul>
    </li>
    <li><a href="#硬件操作">硬件操作</a>
      <ul>
        <li><a href="#df">df</a></li>
        <li><a href="#free">free</a></li>
        <li><a href="#硬盘">硬盘</a></li>
        <li><a href="#mount">mount</a></li>
        <li><a href="#umount">umount</a></li>
        <li><a href="#fdisk">fdisk</a></li>
        <li><a href="#mkfs">mkfs</a></li>
        <li><a href="#fsck">fsck</a></li>
        <li><a href="#dd">dd</a></li>
        <li><a href="#dmidecode">dmidecode</a></li>
        <li><a href="#lspci">lspci</a></li>
        <li><a href="#lsusb">lsusb</a></li>
      </ul>
    </li>
    <li><a href="#主机管理">主机管理</a>
      <ul>
        <li><a href="#hostname命令">hostname命令</a></li>
      </ul>
    </li>
    <li><a href="#命名管道">命名管道</a>
      <ul>
        <li><a href="#设置一个命名管道">设置一个命名管道</a></li>
        <li><a href="#使用命名管道">使用命名管道</a></li>
      </ul>
    </li>
    <li><a href="#进程管理">进程管理</a>
      <ul>
        <li><a href="#ps">ps</a></li>
        <li><a href="#top">top</a></li>
        <li><a href="#jobs">jobs</a></li>
        <li><a href="#fg">fg</a></li>
        <li><a href="#bg">bg</a></li>
        <li><a href="#kill">kill</a></li>
        <li><a href="#killall">killall</a></li>
        <li><a href="#其他进程相关命令">其他进程相关命令</a></li>
      </ul>
    </li>
    <li><a href="#重定向">重定向</a>
      <ul>
        <li><a href="#tee">tee</a></li>
        <li><a href="#命令替换">命令替换</a></li>
        <li><a href="#basename">basename</a></li>
      </ul>
    </li>
    <li><a href="#正则表达式">正则表达式</a>
      <ul>
        <li><a href="#元字符">元字符</a></li>
        <li><a href="#方括号">方括号</a></li>
        <li><a href="#预定义字符类">预定义字符类</a></li>
        <li><a href="#选择">选择</a></li>
        <li><a href="#量词操作符">量词操作符</a></li>
      </ul>
    </li>
    <li><a href="#系统信息">系统信息</a>
      <ul>
        <li><a href="#uname">uname</a></li>
        <li><a href="#service">service</a></li>
      </ul>
    </li>
    <li><a href="#文本处理">文本处理</a>
      <ul>
        <li><a href="#cat">cat</a></li>
        <li><a href="#nl">nl</a></li>
        <li><a href="#sort">sort</a></li>
        <li><a href="#uniq">uniq</a></li>
        <li><a href="#cut">cut</a></li>
        <li><a href="#paste">paste</a></li>
        <li><a href="#wc">wc</a></li>
        <li><a href="#head">head</a></li>
        <li><a href="#tail">tail</a></li>
        <li><a href="#grep">grep</a></li>
        <li><a href="#sed">sed</a></li>
      </ul>
    </li>
    <li><a href="#时间管理">时间管理</a>
      <ul>
        <li><a href="#date-命令">date 命令</a></li>
        <li><a href="#cal-命令">cal 命令</a></li>
      </ul>
    </li>
    <li><a href="#用户管理">用户管理</a>
      <ul>
        <li><a href="#id">id</a></li>
        <li><a href="#su">su</a></li>
        <li><a href="#sudo">sudo</a></li>
        <li><a href="#chown">chown</a></li>
        <li><a href="#chgrp">chgrp</a></li>
        <li><a href="#useradd">useradd</a></li>
        <li><a href="#usermod">usermod</a></li>
        <li><a href="#adduser">adduser</a></li>
        <li><a href="#groupadd">groupadd</a></li>
        <li><a href="#groupdel">groupdel</a></li>
        <li><a href="#passwd">passwd</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="归档和备份">归档和备份</h1>
<h2 id="gzip">gzip</h2>
<p>gzip 程序用来压缩文件，原文件的压缩版（添加<code>gz</code>后缀名）会替代原文件。gunzip 程序用来还原压缩版本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ gzip foo.txt
$ gunzip foo.txt.gz
</code></pre></td></tr></table>
</div>
</div><p><code>gzip</code>的参数如下。</p>
<ul>
<li>-c	把输出写入到标准输出，并且保留原始文件。也有可能用&ndash;stdout 和&ndash;to-stdout 选项来指定。</li>
<li>-d	解压缩。正如 gunzip 命令一样。也可以用&ndash;decompress 或者&ndash;uncompress 选项来指定.</li>
<li>-f	强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用&ndash;force 选项来指定。</li>
<li>-h	显示用法信息。也可用&ndash;help 选项来指定。</li>
<li>-l	列出每个被压缩文件的压缩数据。也可用&ndash;list 选项。</li>
<li>-r	若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用&ndash;recursive 选项来指定。</li>
<li>-t	测试压缩文件的完整性。也可用&ndash;test 选项来指定。</li>
<li>-v	显示压缩过程中的信息。也可用&ndash;verbose 选项来指定。</li>
<li>-number	设置压缩指数。number 是一个在1（最快，最小压缩）到9（最慢，最大压缩）之间的整数。 数值1和9也可以各自用&ndash;fast 和&ndash;best 选项来表示。默认值是整数6。</li>
</ul>
<p>下面是一些例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 查看解压缩后的内容</span>
$ gunzip -c foo.txt <span class="p">|</span> less
</code></pre></td></tr></table>
</div>
</div><p><code>zcat</code>程序等同于带有-c 选项的 gunzip 命令。它可以像<code>cat</code>命令那样，用来查看<code>gzip</code>压缩文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ zcat foo.txt.gz <span class="p">|</span> less
</code></pre></td></tr></table>
</div>
</div><h2 id="bzip2">bzip2</h2>
<p><code>bzip2</code>程序与<code>gzip</code>程序相似，但是使用了不同的压缩算法，舍弃了压缩速度，实现了更高的压缩级别。在大多数情况下，它的工作模式等同于<code>gzip</code>。 由<code>bzip2</code>压缩的文件，用扩展名<code>.bz2</code>表示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ bzip2 foo.txt
$ bunzip2 foo.txt.bz2
</code></pre></td></tr></table>
</div>
</div><p>gzip程序的所有选项（除了<code>-r</code>），bzip2 程序同样也支持。同样有 bunzip2 和 bzcat 程序来解压缩文件。bzip2 文件也带有 bzip2recover 程序，其会 试图恢复受损的 .bz2 文件。</p>
<h2 id="zip">zip</h2>
<p><code>zip</code>程序既是压缩工具，也是一个打包工具，读取和写入.zip文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ zip options zipfile file...
</code></pre></td></tr></table>
</div>
</div><p>它的用法如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 将指定目录压缩成zip文件</span>
$ zip -r playground.zip playground
</code></pre></td></tr></table>
</div>
</div><p><code>zip</code>与<code>tar</code>命令有一个相反之处。如果压缩文件已存在，其将被更新而不是被替代。这意味着会保留此文件包，但是会添加新文件，同时替换匹配的文件。</p>
<p>解压使用<code>unzip</code>命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ unzip ../playground.zip
</code></pre></td></tr></table>
</div>
</div><p><code>unzip</code>命令的参数如下。</p>
<ul>
<li><code>-l</code> 列出文件包中的内容而不解压</li>
<li><code>-v</code> 显示冗余信息</li>
<li><code>-p</code> 输出发送到标准输出</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ unzip -p ls-etc.zip <span class="p">|</span> less
</code></pre></td></tr></table>
</div>
</div><h2 id="tar">tar</h2>
<p><code>tar</code>是tape archive的简称，原来是一款制作磁带备份的工具，现在主要用于打包。一个 tar 包可以由一组独立的文件，一个或者多个目录，或者两者混合体组成。</p>
<p><code>tar</code>程序的语法如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ tar mode<span class="o">[</span>options<span class="o">]</span> pathname...
</code></pre></td></tr></table>
</div>
</div><p>tar支持以下模式。</p>
<ul>
<li>c 表示create，为文件和／或目录列表创建归档文件。</li>
<li>x 抽取归档文件。</li>
<li>r 追加具体的路径到归档文件的末尾。</li>
<li>t 列出归档文件的内容。</li>
</ul>
<p>支持的参数如下。</p>
<ul>
<li>f 表示file，用来指定生成的文件。</li>
</ul>
<p>模式和参数可以写在一起，而且不需要开头的短横线。注意，必须首先指定模式，然后才是其它的选项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 创建子目录的tar包</span>
$ tar cf playground.tar playground

<span class="c1"># 查看tar包内容</span>
$ tar tf playground.tar

<span class="c1"># 查看更详细的列表信息</span>
$ tar tvf playground.tar

<span class="c1"># 还原归档文件</span>
$ tar xf playground.tar

<span class="c1"># 还原单个文件</span>
$ tar xf archive.tar pathname

<span class="c1"># 还原文件到指定目录</span>
$ tar xvf archive.tar -C /home/me/

<span class="c1"># 追加文件</span>
$ tar rf archive.tar file.txt

<span class="c1"># 验证归档文件内容是否正确</span>
$ tar tvfW archive.tar

<span class="c1"># 支持通配符</span>
$ tar xf ../playground2.tar --wildcards <span class="s1">&#39;home/me/playground/\*.txt&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，<code>tar</code>命令还原的时候，总是还原为相对路径。如果归档的时候，保存的是绝对路径，那么还原的时候，这个绝对路径会整个变成相对路径。</p>
<p><code>find</code>命令可以与<code>tar</code>命令配合使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ find playground -name <span class="s1">&#39;file.txt&#39;</span> -exec tar rf playground.tar <span class="s1">&#39;{}&#39;</span> <span class="s1">&#39;+&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的命令先用<code>find</code>程序找到所有名为<code>file.txt</code>的文件，然后使用追加模式（<code>r</code>）的<code>tar</code>命令，把匹配的文件添加到归档文件<code>playground.tar</code>里面。</p>
<p>这种<code>tar</code>和<code>find</code>的配合使用，可以创建逐渐增加的目录树或者整个系统的备份。通过<code>find</code>命令匹配新于某个时间戳的文件，我们就能够创建一个归档文件，其只包含新于上一个 tar 包的文件。</p>
<p>tar支持压缩功能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 打成gzip压缩包</span>
$ tar czvf assets.tar.gz dist

<span class="c1"># 打成bz2压缩包</span>
$ tar cvfj assets.tar.bz2 dist

<span class="c1"># 解压 tar.gz 文件</span>
$ tar xzv archive.tar.gz
$ tar xvf archive.tar.gz

<span class="c1"># 解压bz2压缩包</span>
$ tar xvf archive.tar.bz2

<span class="c1"># 显示gzip压缩包内容</span>
$ tar tvf archive.tar.gz

<span class="c1"># 显示bz2压缩包内容</span>
$ tar tvf archive.tar.bz2

<span class="c1"># 从gzip压缩包取出单个文件</span>
$ tar zxvf archive.tar.gz file.txt

<span class="c1"># 从bz2压缩包取出单个文件</span>
$ tar jxvf archive.tar.bz2 file.txt

<span class="c1"># 按通配符取出文件</span>
$ tar zxvf archive.tar.gz --wildcards <span class="s1">&#39;*.php&#39;</span>
$ tar jxvf archive.tar.bz2 --wildcards <span class="s1">&#39;*.php&#39;</span>

<span class="c1"># 追加文件到压缩包</span>
$ tar rvf archive.tar.gz xyz.txt
$ tar rvf archive.tar.bz2 xyz.txt
</code></pre></td></tr></table>
</div>
</div><h2 id="rsync">rsync</h2>
<p><code>rsync</code>命令用于在多个目录之间、或者本地与远程目录之间同步。字母<code>r</code>表示<code>remote</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ rsync options <span class="nb">source</span> destination
</code></pre></td></tr></table>
</div>
</div><p>source 和 destination 是下列选项之一：</p>
<ul>
<li>一个本地文件或目录</li>
<li>一个远端文件或目录，以<code>[user@]host:path</code>的形式存在</li>
<li>一个远端 rsync 服务器，由<code>rsync://[user@]host[:port]/path</code>指定</li>
</ul>
<p>注意 source 和 destination 两者之一必须是本地文件。rsync 不支持远端到远端的复制。</p>
<p><code>rsync</code>命令的参数如下。</p>
<ul>
<li><code>-a</code> 递归和保护文件属性</li>
<li><code>-v</code> 冗余输出</li>
<li><code>--delete</code> 删除可能在备份设备中已经存在但却不再存在于源设备中的文件</li>
<li><code>--rsh=ssh</code> 使用 ssh 程序作为远程 shell，目的地必须标注主机名。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 同步两个本地目录</span>
$ rsync -av playground foo

<span class="c1"># 删除源设备不存在的文件</span>
$ sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/backup

<span class="c1"># 远程同步</span>
$ sudo rsync -av --delete --rsh<span class="o">=</span>ssh /etc /home /usr/local remote-sys:/backup

<span class="c1"># 与远程rsync主机同步</span>
$ rsync -av -delete rsync://rsync.gtlib.gatech.edu/path/to/oss fedora-devel
</code></pre></td></tr></table>
</div>
</div><h1 id="异步任务">异步任务</h1>
<p>Bash脚本有时候需要同时执行多个任务。通常这涉及到启动一个脚本，依次，启动一个或多个子脚本来执行额外的任务，而父脚本继续运行。然而，当一系列脚本 以这种方式运行时，要保持父子脚本之间协调工作，会有一些问题。也就是说，若父脚本或子脚本依赖于另一方，并且 一个脚本必须等待另一个脚本结束任务之后，才能完成它自己的任务，这应该怎么办？</p>
<p>bash 有一个内置命令，能帮助管理诸如此类的异步执行的任务。wait 命令导致一个父脚本暂停运行，直到一个 特定的进程（例如，子脚本）运行结束。</p>
<p>首先我们将演示一下 wait 命令的用法。为此，我们需要两个脚本，一个父脚本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="c1"># async-parent : Asynchronous execution demo (parent)</span>
<span class="nb">echo</span> <span class="s2">&#34;Parent: starting...&#34;</span>
<span class="nb">echo</span> <span class="s2">&#34;Parent: launching child script...&#34;</span>
async-child <span class="p">&amp;</span>
<span class="nv">pid</span><span class="o">=</span><span class="nv">$!</span>
<span class="nb">echo</span> <span class="s2">&#34;Parent: child (PID= </span><span class="nv">$pid</span><span class="s2">) launched.&#34;</span>
<span class="nb">echo</span> <span class="s2">&#34;Parent: continuing...&#34;</span>
sleep <span class="m">2</span>
<span class="nb">echo</span> <span class="s2">&#34;Parent: pausing to wait for child to finish...&#34;</span>
<span class="nb">wait</span> <span class="nv">$pid</span>
<span class="nb">echo</span> <span class="s2">&#34;Parent: child is finished. Continuing...&#34;</span>
<span class="nb">echo</span> <span class="s2">&#34;Parent: parent is done. Exiting.&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>和一个子脚本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="c1"># async-child : Asynchronous execution demo (child)</span>
<span class="nb">echo</span> <span class="s2">&#34;Child: child is running...&#34;</span>
sleep <span class="m">5</span>
<span class="nb">echo</span> <span class="s2">&#34;Child: child is done. Exiting.&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个例子中，我们看到该子脚本是非常简单的。真正的操作通过父脚本完成。在父脚本中，子脚本被启动， 并被放置到后台运行。子脚本的进程 ID 记录在 pid 变量中，这个变量的值是 $! shell 参数的值，它总是 包含放到后台执行的最后一个任务的进程 ID 号。</p>
<p>父脚本继续，然后执行一个以子进程 PID 为参数的 wait 命令。这就导致父脚本暂停运行，直到子脚本退出， 意味着父脚本结束。</p>
<p>当执行后，父子脚本产生如下输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ async-parent
Parent: starting...
Parent: launching child script...
Parent: child <span class="o">(</span><span class="nv">PID</span><span class="o">=</span> 6741<span class="o">)</span> launched.
Parent: continuing...
Child: child is running...
Parent: pausing to <span class="nb">wait</span> <span class="k">for</span> child to finish...
Child: child is <span class="k">done</span>. Exiting.
Parent: child is finished. Continuing...
Parent: parent is <span class="k">done</span>. Exiting.
</code></pre></td></tr></table>
</div>
</div><h1 id="shell-的命令">Shell 的命令</h1>
<h2 id="命令的类别">命令的类别</h2>
<p>Bash可以使用的命令分成四类。</p>
<ul>
<li>可执行程序</li>
<li>Shell 提供的命令</li>
<li>Shell 函数</li>
<li>前三类命令的别名</li>
</ul>
<h2 id="type-whatis">type, whatis</h2>
<p><code>type</code>命令可以显示命令类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">type</span> <span class="nb">command</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是几个例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">type</span> <span class="nb">type</span>
<span class="nb">type</span> is a shell <span class="nb">builtin</span>

$ <span class="nb">type</span> ls
ls is aliased to <span class="sb">`</span>ls --color<span class="o">=</span>tty<span class="err">&#39;</span>

$ <span class="nb">type</span> cp
cp is /bin/cp
</code></pre></td></tr></table>
</div>
</div><p><code>whatis</code>命令显示指定命令的描述。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ whatis ls
ls <span class="o">(</span>1<span class="o">)</span> - list directory contents
</code></pre></td></tr></table>
</div>
</div><h2 id="apropos">apropos</h2>
<p><code>apropos</code>命令返回符合搜索条件的命令列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ apropos floppy
create_floppy_devices <span class="o">(</span>8<span class="o">)</span> - udev callout to create all possible
fdformat <span class="o">(</span>8<span class="o">)</span> - Low-level formats a floppy disk
floppy <span class="o">(</span>8<span class="o">)</span> - format floppy disks
gfloppy <span class="o">(</span>1<span class="o">)</span> - a simple floppy formatter <span class="k">for</span> the GNOME
mbadblocks <span class="o">(</span>1<span class="o">)</span> - tests a floppy disk, and marks the bad
mformat <span class="o">(</span>1<span class="o">)</span> - add an MSDOS filesystem to a low-level
</code></pre></td></tr></table>
</div>
</div><h2 id="alias-unalias">alias, unalias</h2>
<p><code>alias</code>命令用来为命令起别名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">alias</span> <span class="nv">foo</span><span class="o">=</span><span class="s1">&#39;cd /usr; ls; cd -&#39;</span>

$ <span class="nb">type</span> foo
foo is aliased to <span class="sb">`</span><span class="nb">cd</span> /usr<span class="p">;</span> ls <span class="p">;</span> <span class="nb">cd</span> -<span class="err">&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>上面命令指定<code>foo</code>为三个命令的别名。以后，执行<code>foo</code>就相当于一起执行这三条命令。</p>
<p>注意，默认情况下，别名只在当前Session有效。当前Session结束时，这些别名就会消失。</p>
<p><code>alias</code>命令不加参数时，显示所有有效的别名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">alias</span>
<span class="nb">alias</span> l.<span class="o">=</span><span class="s1">&#39;ls -d .* --color=tty&#39;</span>
<span class="nb">alias</span> <span class="nv">ll</span><span class="o">=</span><span class="s1">&#39;ls -l --color=tty&#39;</span>
<span class="nb">alias</span> <span class="nv">ls</span><span class="o">=</span><span class="s1">&#39;ls --color=tty&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>unalias</code>命令用来取消别名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">unalias</span> foo
$ <span class="nb">type</span> foo
bash: type: foo: not found
</code></pre></td></tr></table>
</div>
</div><h2 id="which">which</h2>
<p><code>which</code>命令显示可执行程序的路径。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ which ls
/bin/ls
</code></pre></td></tr></table>
</div>
</div><p><code>which</code>命令用于Shell内置命令时（比如<code>cd</code>），将没有任何输出。</p>
<h2 id="helpman">help，man</h2>
<p><code>help</code>命令用于查看Shell内置命令的帮助信息，<code>man</code>命令用于查看可执行命令的帮助信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">help</span> <span class="nb">cd</span>
$ man ls
</code></pre></td></tr></table>
</div>
</div><p><code>man</code>里面的文档一共有8类，如果同一个命令，匹配多个文档，<code>man</code>命令总是返回第一个匹配。如果想看指定类型的文档，命令可以采用下面的形式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ man <span class="m">5</span> passwd
</code></pre></td></tr></table>
</div>
</div><h2 id="script">script</h2>
<p><code>script</code>命令会将输入的命令和它的输出，都保存进一个文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ script <span class="o">[</span>file<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>如果没有指定文件名，则所有结果会保存进当前目录下<code>typescript</code>文件。结束录制的时候，可以按下<code>Ctrl + d</code>。</p>
<h2 id="export">export</h2>
<p><code>export</code>命令用于将当前进程的变量，输出到所有子进程。</p>
<h2 id="命令的连续执行">命令的连续执行</h2>
<p>多个命令可以写在一起。</p>
<p>Bash 提供三种方式，定义它们如何执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 第一个命令执行完，执行第二个命令</span>
command1<span class="p">;</span> command2

<span class="c1"># 只有第一个命令成功执行完（退出码0），才会执行第二个命令</span>
command1 <span class="o">&amp;&amp;</span> command2

<span class="c1"># 只有第一个命令执行失败（退出码非0），才会执行第二个命令</span>
command1 <span class="o">||</span> command2
</code></pre></td></tr></table>
</div>
</div><p>上面三种执行方法的退出码，都是最后一条执行的命令的退出码。</p>
<p>bash 允许把命令组合在一起。可以通过两种方式完成；要么用一个 group 命令，要么用一个子 shell。 这里是每种方式的语法示例：</p>
<p>组命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">{</span> command1<span class="p">;</span> command2<span class="p">;</span> <span class="o">[</span>command3<span class="p">;</span> ...<span class="o">]</span> <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>子 shell</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>command1<span class="p">;</span> command2<span class="p">;</span> <span class="o">[</span>command3<span class="p">;</span>...<span class="o">])</span>
</code></pre></td></tr></table>
</div>
</div><p>这两种形式的不同之处在于，组命令用花括号把它的命令包裹起来，而子 shell 用括号。值得注意的是，鉴于 bash 实现组命令的方式， 花括号与命令之间必须有一个空格，并且最后一个命令必须用一个分号或者一个换行符终止。</p>
<p>那么组命令和子 shell 命令对什么有好处呢？ 它们都是用来管理重定向的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">{</span> ls -l<span class="p">;</span> <span class="nb">echo</span> <span class="s2">&#34;Listing of foo.txt&#34;</span><span class="p">;</span> cat foo.txt<span class="p">;</span> <span class="o">}</span> &gt; output.txt
</code></pre></td></tr></table>
</div>
</div><p>使用一个子 shell 是相似的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">(</span>ls -l<span class="p">;</span> <span class="nb">echo</span> <span class="s2">&#34;Listing of foo.txt&#34;</span><span class="p">;</span> cat foo.txt<span class="o">)</span> &gt; output.txt
</code></pre></td></tr></table>
</div>
</div><p>组命令和子 shell 真正闪光的地方是与管道线相结合。 当构建一个管道线命令的时候，通常把几个命令的输出结果合并成一个流是很有用的。 组命令和子 shell 使这种操作变得很简单。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">{</span> ls -l<span class="p">;</span> <span class="nb">echo</span> <span class="s2">&#34;Listing of foo.txt&#34;</span><span class="p">;</span> cat foo.txt<span class="p">;</span> <span class="o">}</span> <span class="p">|</span> lpr
</code></pre></td></tr></table>
</div>
</div><p>这里我们已经把我们的三个命令的输出结果合并在一起，并把它们用管道输送给命令 lpr 的输入，以便产生一个打印报告。</p>
<p>虽然组命令和子 shell 看起来相似，并且它们都能用来在重定向中合并流，但是两者之间有一个很重要的不同。 然而，一个组命令在当前 shell 中执行它的所有命令，而一个子 shell（顾名思义）在当前 shell 的一个 子副本中执行它的命令。这意味着运行环境被复制给了一个新的 shell 实例。当这个子 shell 退出时，环境副本会消失， 所以在子 shell 环境（包括变量赋值）中的任何更改也会消失。因此，在大多数情况下，除非脚本要求一个子 shell， 组命令比子 shell 更受欢迎。组命令运行很快并且占用的内存也少。</p>
<p>当我们发现管道线中的一个 read 命令 不按我们所期望的那样工作的时候。为了重现问题，我们构建一个像这样的管道线：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s2">&#34;foo&#34;</span> <span class="p">|</span> <span class="nb">read</span>
<span class="nb">echo</span> <span class="nv">$REPLY</span>
</code></pre></td></tr></table>
</div>
</div><p>该 REPLY 变量的内容总是为空，是因为这个 read 命令在一个子 shell 中执行，所以它的 REPLY 副本会被毁掉， 当该子 shell 终止的时候。因为管道线中的命令总是在子 shell 中执行，任何给变量赋值的命令都会遭遇这样的问题。 幸运地是，shell 提供了一种奇异的展开方式，叫做进程替换，它可以用来解决这种麻烦。进程替换有两种表达方式：</p>
<p>一种适用于产生标准输出的进程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">&lt;<span class="o">(</span>list<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>另一种适用于接受标准输入的进程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">&gt;<span class="o">(</span>list<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这里的 list 是一串命令列表：</p>
<p>为了解决我们的 read 命令问题，我们可以雇佣进程替换，像这样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">read</span> &lt; &lt;<span class="o">(</span><span class="nb">echo</span> <span class="s2">&#34;foo&#34;</span><span class="o">)</span>
<span class="nb">echo</span> <span class="nv">$REPLY</span>
</code></pre></td></tr></table>
</div>
</div><p>进程替换允许我们把一个子 shell 的输出结果当作一个用于重定向的普通文件。事实上，因为它是一种展开形式，我们可以检验它的真实值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>me@linuxbox ~<span class="o">]</span>$ <span class="nb">echo</span> &lt;<span class="o">(</span><span class="nb">echo</span> <span class="s2">&#34;foo&#34;</span><span class="o">)</span>
/dev/fd/63
</code></pre></td></tr></table>
</div>
</div><p>通过使用 echo 命令，查看展开结果，我们看到子 shell 的输出结果，由一个名为 /dev/fd/63 的文件提供。</p>
<h1 id="文件系统">文件系统</h1>
<h2 id="pwd">pwd</h2>
<p><code>pwd</code>命令显示列出当前所在的目录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">pwd</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="cd">cd</h2>
<p><code>cd</code>命令用来改变用户所在的目录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 进入用户的主目录</span>
$ <span class="nb">cd</span>

<span class="c1"># 进入前一个工作目录</span>
$ <span class="nb">cd</span> -

<span class="c1"># 进入指定用户的主目录</span>
$ <span class="nb">cd</span> ~user_name
</code></pre></td></tr></table>
</div>
</div><h2 id="ls">ls</h2>
<p><code>ls</code>目录可以显示指定目录的内容。不加参数时，显示当前目录的内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls
</code></pre></td></tr></table>
</div>
</div><p>上面命令显示当前目录的内容。</p>
<p><code>ls</code>命令也可以显示指定文件是否存在。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls foo.txt
foo.txt
</code></pre></td></tr></table>
</div>
</div><p><code>-l</code>参数可以显示文件的详细信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls -l foo.txt
-rw-rw-r-- <span class="m">1</span> me   me   <span class="m">0</span> 2016-03-06 14:52 foo.txt
</code></pre></td></tr></table>
</div>
</div><p>上面命令输出结果的第一栏，是文件的类型和权限。</p>
<p>文件类型分为以下几种。</p>
<ul>
<li><code>-</code> 普通文件</li>
<li><code>d</code> 目录</li>
<li><code>l</code> 符号链接。注意，对于符号链接文件，剩余的文件属性总是&quot;rwxrwxrwx&quot;。</li>
<li><code>c</code> 字符设备文件，指按照字节流处理数据的设备，比如调制解调器。</li>
<li><code>b</code> 块设备文件，指按照数据块处理数据的设备，比如硬盘。</li>
</ul>
<p>其他参数的用法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 显示多个目录的内容</span>
$ ls ~ /usr

<span class="c1"># -a --all 显示隐藏文件</span>
$ ls -a

<span class="c1"># -A 与-a类似，但是不显示当前目录和上一级目录两个点文件</span>
$ ls -A

<span class="c1"># -l 显示详细信息</span>
$ ls -l

<span class="c1"># -1 单列显示，每行只显示一个文件</span>
$ ls -1

<span class="c1"># -d 显示当前目录本身，而不是它的内容</span>
<span class="c1"># 通常与-l配合使用，列出一个目录本身的详细信息</span>
$ ls -dl

<span class="c1"># -F 目录名之后添加斜杠，可执行文件后面添加星号</span>
$ ls -F

<span class="c1"># -h 与-l配合使用，将文件大小显示为人类可读的格式</span>

<span class="c1"># -t 按文件修改时间排序，修改晚的排在前面</span>
$ ls -t

<span class="c1"># -s 按文件大小排序，</span>

<span class="c1"># --reverse 显示结果倒序排列</span>
$ ls -lt --reverse
</code></pre></td></tr></table>
</div>
</div><p>如果只显示一个目录里面的子目录，不显示文件，可以使用下面这些命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 只显示常规目录</span>
$ ls -d */
$ ls -F <span class="p">|</span> grep /
$ ls -l <span class="p">|</span> grep ^d
$ tree -dL <span class="m">1</span>

<span class="c1"># 只显示隐藏目录</span>
$ ls -d .*/

<span class="c1"># 隐藏目录和非隐藏目录都显示</span>
$ find -maxdepth <span class="m">1</span> -type d
</code></pre></td></tr></table>
</div>
</div><p>另一个简便方法是利用自动补全功能，先键入<code>cd</code>命令，然后连按两下<code>tab</code>键。</p>
<h2 id="stat">stat</h2>
<p><code>stat</code>命令是加强版的<code>ls</code>命令，可以显示一个文件的详细信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ stat timestamp
File: <span class="s1">&#39;timestamp&#39;</span>
Size: <span class="m">0</span> Blocks: <span class="m">0</span> IO Block: <span class="m">4096</span> regular empty file
Device: 803h/2051d Inode: <span class="m">14265061</span> Links: <span class="m">1</span>
Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span> Uid: <span class="o">(</span> 1001/ me<span class="o">)</span> Gid: <span class="o">(</span> 1001/ me<span class="o">)</span>
Access: 2008-10-08 15:15:39.000000000 -0400
Modify: 2008-10-08 15:15:39.000000000 -0400
Change: 2008-10-08 15:15:39.000000000 -0400
</code></pre></td></tr></table>
</div>
</div><h2 id="touch">touch</h2>
<p><code>touch</code>用来设置或更新文件的访问，更改，和修改时间。然而，如果一个文件名参数是一个 不存在的文件，则会创建一个空文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ touch timestamp
</code></pre></td></tr></table>
</div>
</div><p>上面命令创建了一个名为<code>timestamp</code>空文件。如果该文件已经存在，就会把它的修改时间设置为当前时间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ mkdir -p playground/dir-<span class="o">{</span>00<span class="o">{</span>1..9<span class="o">}</span>,0<span class="o">{</span>10..99<span class="o">}</span>,100<span class="o">}</span>
$ touch playground/dir-<span class="o">{</span>00<span class="o">{</span>1..9<span class="o">}</span>,0<span class="o">{</span>10..99<span class="o">}</span>,100<span class="o">}</span>/file-<span class="o">{</span>A..Z<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的命令创建了一个包含一百个子目录，每个子目录中包含了26个空文件。</p>
<h2 id="file">file</h2>
<p><code>file</code>命令显示指定文件的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ file picture.jpg
picture.jpg: JPEG image data, JFIF standard 1.01
</code></pre></td></tr></table>
</div>
</div><h2 id="chmod">chmod</h2>
<p><code>chmod</code>命令用于更改文件的权限，是“change mode”的缩写。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ chmod <span class="m">600</span> foo.txt
</code></pre></td></tr></table>
</div>
</div><p>上面命令将<code>foo.txt</code>的权限改成了600。</p>
<p><code>chmod</code>还可以接受四个缩写，为不同的对象单独设置权限。</p>
<ul>
<li><code>u</code> 所有者“user”的简写</li>
<li><code>g</code> 用户组“group”的缩写</li>
<li><code>o</code> 其他所有人“others”的简写</li>
<li><code>a</code> 所有人“all”的简写</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 为所有者添加可执行权限</span>
$ chmod u+x foo.txt

<span class="c1"># 删除所有者的可执行权限</span>
$ chmod u-x foo.txt

<span class="c1"># 为所有人添加可执行权限，等价于 a+x</span>
$ chmod +x foo.txt

<span class="c1"># 删除其他人的读权限和写权限。</span>
$ chmod o-rw foo.txt

<span class="c1"># 设定用户组和其他人的权限是读权限和写权限</span>
$ chmod <span class="nv">go</span><span class="o">=</span>rw foo.txt

<span class="c1"># 为所有者添加执行权限，设定用户组和其他人为读权限和写权限，多种设定用逗号分隔</span>
$ chmod u+x,go<span class="o">=</span>rw foo.txt
</code></pre></td></tr></table>
</div>
</div><p>添加权限。</p>
<ul>
<li>+x 添加执行权限</li>
<li>+r 设置读权限</li>
<li>+w 设置写权限</li>
<li>+rwx 设置所有读、写和执行权限。</li>
</ul>
<p>删除权限只需将<code>+</code>更改为<code>-</code>，就可以删除任何已设置的指定权限。可以使用<code>-R</code>（或<code>--recursive</code>）选项来递归地操作目录和文件。</p>
<p>设置精确权限，可以使用<code>=</code>代替<code>+</code>或<code>-</code>来实现此操作。如果想为用户、组或其他用户设置不同的权限，可以使用逗号将不同表达式分开（例如<code>ug=rwx,o=rx</code>）。</p>
<p>由于一共有3种可能的权限。也可以使用八进制数代替符号来设置权限。通过这种方式设置的权限最多使用3个八进制数。第1个数定义用户权限，第2个数定义组权限，第3个数定义其他权限。这3个数中的每一个都通过添加想要的权限设置来构造：读 (4)、写 (2) 和执行 (1)。</p>
<ul>
<li>rwx	7</li>
<li>rw-	6</li>
<li>r-x	5</li>
<li>r&ndash;	4</li>
<li>-wx	3</li>
<li>-w-	2</li>
<li>&ndash;x	1</li>
<li>&mdash;	0</li>
</ul>
<h2 id="umask">umask</h2>
<p><code>umask</code>用来查看和设置权限掩码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">umask</span>
<span class="m">0022</span>
</code></pre></td></tr></table>
</div>
</div><p>上面命令显示当前系统之中，默认的文件掩码是<code>0022</code>，转为二进制就是<code>000 000 010 010</code>。</p>
<p>可以看到，这个掩码是一个12位的二进制数，后面的9位分别代表文件三种使用对象的三类权限。只要对应位置上是<code>1</code>，就表示关闭该项权限，所以<code>010</code>就表示关闭读权限。</p>
<p>新建文件时，通常不会带有执行权限，也就是说，新建文件的默认权限是<code>rw-rw-rw-</code>。如果文件掩码是<code>0022</code>，那么用户组和其他人的写权限也会被拿掉。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ touch new.txt
$ ls -l new.txt
-rw-r--r-- <span class="m">1</span> me   me   <span class="m">0</span> 2016-03-06 14:52 new.txt
</code></pre></td></tr></table>
</div>
</div><p>上面代码中，<code>new.txt</code>的用户组和其他人的写权限就没了。</p>
<p><code>umask</code>后面跟着参数，就表示设置权限掩码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">umask</span> <span class="m">0000</span>
</code></pre></td></tr></table>
</div>
</div><p>上面命令将权限掩码设为<code>0000</code>，实际上就是关闭了权限掩码。</p>
<p><code>umask</code>命令设置的掩码值只能在当前Shell会话中生效，若当前Shell会话结束后，则必须重新设置。</p>
<h2 id="du">du</h2>
<p><code>du</code>命令用于查看指定目录的大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ du -hs /path/to/directory
</code></pre></td></tr></table>
</div>
</div><p>显示第一层子目录的大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ du -h --max-depth<span class="o">=</span><span class="m">1</span> /path/to/folder
</code></pre></td></tr></table>
</div>
</div><p>参数的含义。</p>
<ul>
<li><code>-h</code> 表示人类可读的格式</li>
<li><code>-s</code> 表示总结信息，否则会显示该目录内所有文件和子目录的信息。</li>
</ul>
<p><code>tree</code>命令也可以显示子目录大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ tree --du -h /path/to/directory
</code></pre></td></tr></table>
</div>
</div><h2 id="md5sum">md5sum</h2>
<p><code>md5sum</code>命令用来显示一个文件的md5校验码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ md5sum image.iso
34e354760f9bb7fbf85c96f6a3f94ece    image.iso
</code></pre></td></tr></table>
</div>
</div><h2 id="locate">locate</h2>
<p><code>locate</code>程序快速搜索本机的路径名数据库，并且输出每个与给定字符串相匹配的文件名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ locate bin/zip
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
</code></pre></td></tr></table>
</div>
</div><p><code>locate</code>数据库由另一个叫做<code>updatedb</code>的程序创建。大多数装有 locate 的系统会每隔一天运行一回 updatedb 程序。因为数据库不能被持续地更新，所以当使用 locate 时，你会发现 目前最新的文件不会出现。为了克服这个问题，可以手动运行 updatedb 程序， 更改为超级用户身份，在提示符下运行 updatedb 命令。</p>
<p><code>locate</code>支持正则查找。<code>--regexp</code>参数支持基本的正则表达式，<code>--regex</code>参数支持扩展的正则表达式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ locate --regex <span class="s1">&#39;bin/(bz|gz|zip)&#39;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="find">find</h2>
<p><code>locate</code>程序只能依据文件名来查找文件，而<code>find</code>程序能基于各种各样的属性，搜索一个给定目录（以及它的子目录），来查找文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 输出当前目录的所有子目录和文件（含子目录）</span>
$ find
$ find .

<span class="c1"># 显示当前目录的文件总数</span>
$ find . <span class="p">|</span> wc -l

<span class="c1"># 当前目录的子目录总数</span>
$ find . -type d <span class="p">|</span> wc -l

<span class="c1"># 当前目录的文件总数（不含子目录）</span>
$ find . -type f <span class="p">|</span> wc -l

<span class="c1"># 当前目录的文件名匹配“*.JPG”且大于1M的文件总数</span>
$ find . -type f -name <span class="s2">&#34;\*.JPG&#34;</span> -size +1M <span class="p">|</span> wc -l
</code></pre></td></tr></table>
</div>
</div><p><code>-type</code>参数支持的文件类型。</p>
<ul>
<li><code>b</code>	块设备文件</li>
<li><code>c</code>	字符设备文件</li>
<li><code>d</code>	目录</li>
<li><code>f</code>	普通文件</li>
<li><code>l</code>	符号链接</li>
</ul>
<p><code>-size</code>参数支持的文件大小类型。</p>
<ul>
<li>b	512 个字节块。如果没有指定单位，则这是默认值。</li>
<li>c	字节</li>
<li>w	两个字节的字</li>
<li>k	千字节</li>
<li>M	兆字节</li>
<li>G	千兆字节</li>
</ul>
<p><code>find</code>程序支持的查询参数。</p>
<ul>
<li>-cmin n	匹配的文件和目录的内容或属性最后修改时间正好在 n 分钟之前。 指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。</li>
<li>-cnewer file	匹配的文件和目录的内容或属性最后修改时间早于那些文件。</li>
<li>-ctime n	匹配的文件和目录的内容和属性最后修改时间在 n*24小时之前。</li>
<li>-empty	匹配空文件和目录。</li>
<li>-group name	匹配的文件和目录属于一个组。组可以用组名或组 ID 来表示。</li>
<li>-iname pattern	就像-name 测试条件，但是不区分大小写。</li>
<li>-inum n	匹配的文件的 inode 号是 n。这对于找到某个特殊 inode 的所有硬链接很有帮助。</li>
<li>-mmin n	匹配的文件或目录的内容被修改于 n 分钟之前。</li>
<li>-mtime n	匹配的文件或目录的内容被修改于 n*24小时之前。</li>
<li>-name pattern	用指定的通配符模式匹配的文件和目录。</li>
<li>-newer file	匹配的文件和目录的内容早于指定的文件。当编写 shell 脚本，做文件备份时，非常有帮助。 每次你制作一个备份，更新文件（比如说日志），然后使用 find 命令来决定自从上次更新，哪一个文件已经更改了。</li>
<li>-nouser	匹配的文件和目录不属于一个有效用户。这可以用来查找 属于删除帐户的文件或监测攻击行为。</li>
<li>-nogroup	匹配的文件和目录不属于一个有效的组。</li>
<li>-perm mode	匹配的文件和目录的权限已经设置为指定的 mode。mode 可以用 八进制或符号表示法。</li>
<li>-samefile name	相似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。</li>
<li>-size n	匹配的文件大小为 n。</li>
<li>-type c	匹配的文件类型是 c。</li>
<li>-user name	匹配的文件或目录属于某个用户。这个用户可以通过用户名或用户 ID 来表示。</li>
<li>-depth	指导 find 程序先处理目录中的文件，再处理目录自身。当指定-delete 行为时，会自动 应用这个选项。</li>
<li>-maxdepth levels	当执行测试条件和行为的时候，设置 find 程序陷入目录树的最大级别数</li>
<li>-mindepth levels	在应用测试条件和行为之前，设置 find 程序陷入目录数的最小级别数。</li>
<li>-mount	指导 find 程序不要搜索挂载到其它文件系统上的目录。</li>
<li>-regex 指定正则表达式</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 找出包括空格或其它不规范字符的文件名或路径名</span>
$ find . -regex <span class="s1">&#39;.*[^-\_./0-9a-zA-Z].*&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>find</code>程序还支持逻辑操作符。</p>
<ul>
<li><code>-and</code>	如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。 注意若没有使用操作符，则默认使用 -and。</li>
<li><code>-or</code>	若操作符两边的任一个测试条件为真，则匹配。可以简写为 -o。</li>
<li><code>-not</code>	若操作符后面的测试条件是真，则匹配。可以简写为一个感叹号（!）。</li>
<li><code>()</code>	把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。注意 因为圆括号字符对于 shell 来说有特殊含义，所以在命令行中使用它们的时候，它们必须 用引号引起来，才能作为实参传递给 find 命令。通常反斜杠字符被用来转义圆括号字符。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 或关系</span>
<span class="o">(</span> expression <span class="m">1</span> <span class="o">)</span> -or <span class="o">(</span> expression <span class="m">2</span> <span class="o">)</span>

<span class="c1"># 找出不是600权限的文件，或者不是700权限的目录</span>
$ find ~ <span class="se">\(</span> -type f -not -perm <span class="m">0600</span> <span class="se">\)</span> -or <span class="se">\(</span> -type d -not -perm <span class="m">0700</span> <span class="se">\)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>find</code>程序的逻辑表达式，具有“短路运算”的特点，即对于<code>expr1 -operator expr2</code>这个表达式，<code>expr2</code>不一定执行。这是为了提高运行速度。</p>
<ul>
<li>expr1 为真，且操作符为<code>-and</code>，expr2 总是执行</li>
<li>expr1 为假，且操作符为<code>-and</code>，expr2 从不执行</li>
<li>expr1 为真，且操作符为<code>-or</code>，expr2 从不执行</li>
<li>expr1 为假，且操作符为<code>-or</code>，expr2 总是执行</li>
</ul>
<p>为了方便执行一些常见操作，<code>find</code>程序定义了一些预定义操作。</p>
<ul>
<li>-delete	删除当前匹配的文件。</li>
<li>-ls	对匹配的文件执行等同的 ls -dils 命令。并将结果发送到标准输出。</li>
<li>-print	把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。</li>
<li>-quit	一旦找到一个匹配，退出。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 找到匹配的文件，并显示在标准输出</span>
<span class="c1"># -print 是默认操作，可以省略</span>
$ find . -print

<span class="c1"># 删除后缀名为BAK的文件</span>
<span class="c1"># 执行 delete 操作前，最好先执行 print 操作，确认要删除哪些文件</span>
$ find . -type f -name <span class="s1">&#39;*.BAK&#39;</span> -delete
</code></pre></td></tr></table>
</div>
</div><p>预定义操作可以与逻辑表达式，结合使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ find ~ -type f -and -name <span class="s1">&#39;*.BAK&#39;</span> -and -print
</code></pre></td></tr></table>
</div>
</div><p>除了预定义操作以外，用户还可以使用<code>-exec</code>参数自定义操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">-exec <span class="nb">command</span> <span class="o">{}</span> <span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的命令中，<code>command</code>是一个命令行命令，<code>{}</code>用来指代当前路径，分号表示命令结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 预定义的 -delete 操作，等同于下面的操作</span>
-exec rm <span class="s1">&#39;{}&#39;</span> <span class="s1">&#39;;&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>-exec</code>使用时，每次找到一个匹配的文件，会启动一个新的指定命令的实例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ find ~ -type f -name <span class="s1">&#39;foo*&#39;</span> -exec ls -l <span class="s1">&#39;{}&#39;</span> <span class="s1">&#39;;&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>执行上面的命令，<code>ls</code>程序可能会被调用多次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls -l file1
$ ls -l file2
</code></pre></td></tr></table>
</div>
</div><p>如果想改成<code>ls</code>程序只调用一次，要把<code>find</code>命令里面的分号，改成加号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls -l file1 file2
<span class="c1"># 相当于</span>
$ find ~ -type f -name <span class="s1">&#39;foo*&#39;</span> -exec ls -l <span class="s1">&#39;{}&#39;</span> +
</code></pre></td></tr></table>
</div>
</div><h2 id="xargs">xargs</h2>
<p><code>xargs</code>命令从标准输入接受输入，并把输入转换为一个特定命令的参数列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ find ~ -type f -name <span class="s1">&#39;foo\*&#39;</span> -print <span class="p">|</span> xargs ls -l
</code></pre></td></tr></table>
</div>
</div><h1 id="文件操作">文件操作</h1>
<h2 id="cp">cp</h2>
<p><code>cp</code>命令用于将文件（或目录）拷贝到目的地。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 拷贝单个文件</span>
$ cp <span class="nb">source</span> dest

<span class="c1"># 拷贝多个文件</span>
$ cp source1 source2 source3 dest

<span class="c1"># -i 目的地有同名文件时会提示确认</span>
$ cp -i file1 file2

<span class="c1"># -r 递归拷贝，将dir1拷贝到dir2，完成后dir2生成一个子目录dir1</span>
<span class="c1"># dir2如果不存在，将被创建</span>
<span class="c1"># 拷贝目录时，该参数是必需的</span>
$ cp -r dir1 dir2

<span class="c1"># -u --update 只拷贝目的地没有的文件，或者比目的地同名文件更新的文件</span>
$ cp -u *.html destination
</code></pre></td></tr></table>
</div>
</div><p>其他参数</p>
<ul>
<li><code>-a</code> 拷贝时保留所有属性，包括所有者与权限</li>
<li><code>-v</code> 显示拷贝的详细信息</li>
</ul>
<h2 id="mkdir">mkdir</h2>
<p><code>mkdir</code>命令用于新建目录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 新建多个目录</span>
$ mkdir dir1 dir2 dir3
</code></pre></td></tr></table>
</div>
</div><h2 id="mv">mv</h2>
<p><code>mv</code>命令用于将源文件移动到目的地。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 移动单个文件</span>
$ mv item1 item2

<span class="c1"># 移动多个文件</span>
$ mv file1 file2 dir1

<span class="c1"># 将dir1拷贝进入dir2，完成后dir2将多出一个子目录dir1</span>
<span class="c1"># 如果dir2不存在，将会被创建</span>
$ mv dir1 dir2
</code></pre></td></tr></table>
</div>
</div><p>参数</p>
<ul>
<li><code>-i</code> 覆盖已经存在的文件时，会提示确认</li>
<li><code>-u</code> 只移动目的地不存在的文件，或比目的地更新的文件</li>
</ul>
<h2 id="rm">rm</h2>
<p><code>rm</code>命令用于删除文件。</p>
<p>参数。</p>
<ul>
<li><code>-i</code> 文件存在时，会提示确认。</li>
<li><code>-r</code> 递归删除一个子目录</li>
<li><code>-f</code> 如果删除不存在的文件，不报错</li>
<li><code>-v</code> 删除时展示详细信息</li>
</ul>
<h2 id="ln">ln</h2>
<p><code>ln</code>命令用于建立链接文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 新建硬链接</span>
$ ln file link

<span class="c1"># 新建软链接</span>
$ ln -s item link
</code></pre></td></tr></table>
</div>
</div><h1 id="硬件操作">硬件操作</h1>
<h2 id="df">df</h2>
<p><code>df</code>命令查看硬盘信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ df
Filesystem 1K-blocks Used Available Use% Mounted on
/dev/sda2 <span class="m">15115452</span> <span class="m">5012392</span> <span class="m">9949716</span> 34% /
/dev/sda5 <span class="m">59631908</span> <span class="m">26545424</span> <span class="m">30008432</span> 47% /home
/dev/sda1 <span class="m">147764</span> <span class="m">17370</span> <span class="m">122765</span> 13% /boot
</code></pre></td></tr></table>
</div>
</div><h2 id="free">free</h2>
<p><code>free</code>命令查看内存占用情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ free
 total used free shared buffers cached
Mem: <span class="m">513712</span> <span class="m">503976</span> <span class="m">9736</span> <span class="m">0</span> <span class="m">5312</span> <span class="m">122916</span>
-/+ buffers/cache: <span class="m">375748</span> <span class="m">137964</span>
Swap: <span class="m">1052248</span> <span class="m">104712</span> <span class="m">947536</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="硬盘">硬盘</h2>
<p>文件<code>/etc/fstab</code>配置系统启动时要挂载的设备。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">LABEL=/12               /               ext3        defaults        1   1
LABEL=/home             /home           ext3        defaults        1   2
LABEL=/boot             /boot           ext3        defaults        1   2
</code></pre></td></tr></table>
</div>
</div><p>输出结果一共有6个字段，含义依次如下。</p>
<ul>
<li>设备名：与物理设备相关联的设备文件（或设备标签）的名字，比如说<code>/dev/hda1</code>（第一个 IDE 通道上第一个主设备分区）。</li>
<li>挂载点：设备所连接到的文件系统树的目录。</li>
<li>文件系统类型：Linux 允许挂载许多文件系统类型。</li>
<li>选项：文件系统可以通过各种各样的选项来挂载。</li>
<li>频率：一位数字，指定是否和在什么时间用 dump 命令来备份一个文件系统。</li>
<li>次序：一位数字，指定 fsck 命令按照什么次序来检查文件系统。</li>
</ul>
<h2 id="mount">mount</h2>
<p><code>mount</code>不带参数时，显示当前挂载的文件系统。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ mount
/dev/sda2 on / <span class="nb">type</span> ext3 <span class="o">(</span>rw<span class="o">)</span>
proc on /proc <span class="nb">type</span> proc <span class="o">(</span>rw<span class="o">)</span>
sysfs on /sys <span class="nb">type</span> sysfs <span class="o">(</span>rw<span class="o">)</span>
devpts on /dev/pts <span class="nb">type</span> devpts <span class="o">(</span>rw,gid<span class="o">=</span>5,mode<span class="o">=</span>620<span class="o">)</span>
/dev/sda5 on /home <span class="nb">type</span> ext3 <span class="o">(</span>rw<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这个列表的格式是：设备 on 挂载点 type 文件系统类型（可选的）。</p>
<p><code>mount</code>带参数时，用于将设备文件挂载到挂载点，<code>-t</code>参数用来指定文件系统类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ mount -t iso9660 /dev/hdc /mnt/cdrom

<span class="c1"># 挂载一个iso文件</span>
$ mount -t iso9660 -o loop image.iso /mnt/iso_image
</code></pre></td></tr></table>
</div>
</div><h2 id="umount">umount</h2>
<p><code>umount</code>命令用来卸载设备。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ umount <span class="o">[</span>设备名<span class="o">]</span>

$ umount /dev/hdc
</code></pre></td></tr></table>
</div>
</div><h2 id="fdisk">fdisk</h2>
<p><code>fdisk</code>命令用于格式化磁盘。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo umount /dev/sdb1
$ sudo fdisk /dev/sdb
</code></pre></td></tr></table>
</div>
</div><h2 id="mkfs">mkfs</h2>
<p><code>mkfs</code>命令用于在一个设备上新建文件系统。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo mkfs -t ext3 /dev/sdb1
$ sudo mkfs -t vfat /dev/sdb1
</code></pre></td></tr></table>
</div>
</div><h2 id="fsck">fsck</h2>
<p><code>fsck</code>命令用于检查（修复）文件系统。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo fsck /dev/sdb1
</code></pre></td></tr></table>
</div>
</div><h2 id="dd">dd</h2>
<p><code>dd</code>命令用于将大型数据块，从一个磁盘复制到另一个磁盘。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ dd <span class="k">if</span><span class="o">=</span>input_file <span class="nv">of</span><span class="o">=</span>output_file <span class="o">[</span><span class="nv">bs</span><span class="o">=</span>block_size <span class="o">[</span><span class="nv">count</span><span class="o">=</span>blocks<span class="o">]]</span>

<span class="c1"># 将 /dev/sdb 的所有数据复制到 /dev/sdc</span>
$ dd <span class="k">if</span><span class="o">=</span>/dev/sdb <span class="nv">of</span><span class="o">=</span>/dev/sdc

<span class="c1"># 将 /dev/sdb 的所有数据拷贝到一个镜像文件</span>
$ dd <span class="k">if</span><span class="o">=</span>/dev/sdb <span class="nv">of</span><span class="o">=</span>flash_drive.img

<span class="c1"># 从cdrom制作一个iso文件</span>
$ dd <span class="k">if</span><span class="o">=</span>/dev/cdrom <span class="nv">of</span><span class="o">=</span>ubuntu.iso
</code></pre></td></tr></table>
</div>
</div><h2 id="dmidecode">dmidecode</h2>
<p><code>dmidecode</code>命令用于输出BIOS信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo dmidecode
</code></pre></td></tr></table>
</div>
</div><p>以上命令会输出全部BIOS信息。为了便于查看，往往需要指定所需信息的类别。</p>
<ul>
<li>0 BIOS</li>
<li>1 System</li>
<li>2 Base Board</li>
<li>3 Chassis 4 Processor</li>
<li>5 Memory Controller</li>
<li>6 Memory Module</li>
<li>7 Cache</li>
<li>8 Port Connector</li>
<li>9 System Slots</li>
<li>10 On Board Devices</li>
<li>11 OEM Strings</li>
<li>12 System Configuration Options</li>
<li>13 BIOS Language</li>
<li>14 Group Associations</li>
<li>15 System Event Log</li>
<li>16 Physical Memory Array</li>
<li>17 Memory Device</li>
<li>18 32-bit Memory Error</li>
<li>19 Memory Array Mapped Address</li>
<li>20 Memory Device Mapped Address</li>
<li>21 Built-in Pointing Device</li>
<li>22 Portable Battery</li>
<li>23 System Reset</li>
<li>24 Hardware Security</li>
<li>25 System Power Controls</li>
<li>26 Voltage Probe</li>
<li>27 Cooling Device</li>
<li>28 Temperature Probe</li>
<li>29 Electrical Current Probe</li>
<li>30 Out-of-band Remote Access</li>
<li>31 Boot Integrity Services</li>
<li>32 System Boot</li>
<li>33 64-bit Memory Error</li>
<li>34 Management Device</li>
<li>35 Management Device Component</li>
<li>36 Management Device Threshold Data</li>
<li>37 Memory Channel</li>
<li>38 IPMI Device</li>
<li>39 Power Supply</li>
</ul>
<p>查看内存信息的命令如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo dmidecode -t <span class="m">17</span>
<span class="c1"># 或者</span>
$ dmidecode --type <span class="m">17</span>
</code></pre></td></tr></table>
</div>
</div><p>以下是其他一些选项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 查看BIOS信息</span>
$ sudo dmidecode –t <span class="m">0</span>

<span class="c1"># 查看CPU信息</span>
$ sudo dmidecode -t <span class="m">4</span>
</code></pre></td></tr></table>
</div>
</div><p><code>dmidecode</code>也支持关键词查看，关键词与类别的对应关系如下。</p>
<ul>
<li>bios 0, 13</li>
<li>system 1, 12, 15, 23, 32</li>
<li>baseboard 2, 10</li>
<li>chassis 3</li>
<li>processor 4</li>
<li>memory 5, 6, 16, 17</li>
<li>cache 7</li>
<li>connector 8</li>
<li>slot 9</li>
</ul>
<p>查看系统信息的命令如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo dmidecode -t system
</code></pre></td></tr></table>
</div>
</div><h2 id="lspci">lspci</h2>
<p><code>lspci</code>命令列出本机的所有PCI设备。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ lspci
</code></pre></td></tr></table>
</div>
</div><p>该命令输出信息的格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">03:00.0 Unassigned class <span class="o">[</span>ff00<span class="o">]</span>: Realtek Semiconductor Co., Ltd. RTS5209 PCI Express Card Reader <span class="o">(</span>rev 01<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>输出信息一共分成三个字段。</p>
<ul>
<li>Field 1：PCI bus slot 的编号</li>
<li>Field 2：PCI slot的名字</li>
<li>Field 3：设备名和厂商名</li>
</ul>
<p>如果想查看更详细信息，可以使用下面的命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ lspci -vmm
</code></pre></td></tr></table>
</div>
</div><h2 id="lsusb">lsusb</h2>
<p><code>lsusb</code>命令用于操作USB端口。</p>
<p>下面命令列出本机所有USB端口。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ lsusb
</code></pre></td></tr></table>
</div>
</div><p>它的输出格式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">Bus <span class="m">002</span> Device 003: ID 0781:5567 SanDisk Corp. Cruzer Blade
</code></pre></td></tr></table>
</div>
</div><p>各个字段的含义如下。</p>
<ul>
<li>Bus 002 : bus编号</li>
<li>Device 003：bus 002连接的第三个设备</li>
<li>ID 0781:5567：当前设备的编号，冒号前是厂商编号，冒号后是设备编号</li>
<li>SanDisk Corp. Cruzer Blade：厂商和设备名</li>
</ul>
<p>找出本机有多少个USB接口可用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ find /dev/bus/
/dev/bus/
/dev/bus/usb
/dev/bus/usb/002
/dev/bus/usb/002/006
/dev/bus/usb/002/005
/dev/bus/usb/002/004
/dev/bus/usb/002/002
/dev/bus/usb/002/001
/dev/bus/usb/001
/dev/bus/usb/001/007
/dev/bus/usb/001/003
/dev/bus/usb/001/002
/dev/bus/usb/001/001
</code></pre></td></tr></table>
</div>
</div><p>查看某个USB设备的详细情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ lsusb -D /dev/bus/usb/002/005
</code></pre></td></tr></table>
</div>
</div><p>查看所有设备的详细情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ lsusb -v
</code></pre></td></tr></table>
</div>
</div><p>查看USB端口的版本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ lsusb -v <span class="p">|</span> grep -i bcdusb
</code></pre></td></tr></table>
</div>
</div><h1 id="主机管理">主机管理</h1>
<h2 id="hostname命令">hostname命令</h2>
<p><code>hostname</code>命令返回当前服务器的主机名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ hostname
</code></pre></td></tr></table>
</div>
</div><h1 id="命名管道">命名管道</h1>
<p>在大多数类似 Unix 的操作系统中，有可能创建一种特殊类型的文件，叫做命名管道。命名管道用来在 两个进程之间建立连接，也可以像其它类型的文件一样使用。</p>
<p>命令管道的行为类似于文件，但实际上形成了先入先出（FIFO）的缓冲。和普通（未命令的）管道一样， 数据从一端进入，然后从另一端出现。通过命令管道，有可能像这样设置一些东西：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">process1 &gt; named_pipe
</code></pre></td></tr></table>
</div>
</div><p>和</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">process2 &lt; named_pipe
</code></pre></td></tr></table>
</div>
</div><p>表现出来就像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">process1 <span class="p">|</span> process2
</code></pre></td></tr></table>
</div>
</div><h2 id="设置一个命名管道">设置一个命名管道</h2>
<p>使用 mkfifo 命令能够创建命令管道：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ mkfifo pipe1
$ ls -l pipe1
prw-r--r-- <span class="m">1</span> me me <span class="m">0</span> 2009-07-17 06:41 pipe1
</code></pre></td></tr></table>
</div>
</div><p>这里我们使用 mkfifo 创建了一个名为 pipe1 的命名管道。使用 ls 命令，我们查看这个文件， 看到位于属性字段的第一个字母是 “p”，表明它是一个命名管道。</p>
<h2 id="使用命名管道">使用命名管道</h2>
<p>为了演示命名管道是如何工作的，我们将需要两个终端窗口（或用两个虚拟控制台代替）。 在第一个终端中，我们输入一个简单命令，并把命令的输出重定向到命名管道：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls -l &gt; pipe1
</code></pre></td></tr></table>
</div>
</div><p>我们按下 Enter 按键之后，命令将会挂起。这是因为在管道的另一端没有任何接受数据。当这种现象发生的时候， 据说是管道阻塞了。一旦我们绑定一个进程到管道的另一端，该进程开始从管道中读取输入的时候，这种情况会消失。 使用第二个终端窗口，我们输入这个命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ cat &lt; pipe1
</code></pre></td></tr></table>
</div>
</div><p>然后产自第一个终端窗口的目录列表出现在第二个终端中，并作为来自 cat 命令的输出。在第一个终端 窗口中的 ls 命令一旦它不再阻塞，会成功地结束。</p>
<h1 id="进程管理">进程管理</h1>
<h2 id="ps">ps</h2>
<p><code>ps</code>命令用来列出进程信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ps
PID TTY           TIME CMD
<span class="m">5198</span> pts/1    00:00:00 bash
<span class="m">10129</span> pts/1   00:00:00 ps
</code></pre></td></tr></table>
</div>
</div><p>不带任何参数时，<code>ps</code>只列出与当前Session相关的进程。输出结果中，<code>PID</code>是进程ID、<code>TTY</code>是进程的终端号（如果显示<code>?</code>，则表示进程没有终端），<code>TIME</code>是消耗的CPU时间，<code>CMD</code>是触发进程的命令。</p>
<p><code>x</code>参数列出所有进程的详细信息，包括不在当前Session的信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ps x
PID TTY   STAT   TIME COMMAND
<span class="m">2799</span> ?    Ssl    0:00 /usr/libexec/bonobo-activation-server –ac
<span class="m">2820</span> ?    Sl     0:01 /usr/libexec/evolution-data-server-1.10 --
</code></pre></td></tr></table>
</div>
</div><p>这时的输出结果，会多出<code>STAT</code>一栏，表示状态。它的各种值如下。</p>
<ul>
<li><code>R</code> 正在运行或准备运行</li>
<li><code>S</code> 正在睡眠，即没有运行，正在等待一个事件唤醒</li>
<li><code>D</code> 不可中断睡眠。进程正在等待 I/O，比如磁盘驱动器的I/O</li>
<li><code>T</code> 已停止，即进程停止运行</li>
<li><code>Z</code> “僵尸”进程。即这是一个已经终止的子进程，但父进程还没有清空它（没有把子进程从进程表中删除）</li>
<li><code>&lt;</code> 高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。</li>
<li><code>N</code> 低优先级进程。一个低优先级进程（一个“好”进程）只有当其它高优先级进程执行之后，才会得到处理器时间。</li>
</ul>
<p><code>aux</code>参数可以显示更多信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ps aux
USER   PID  %CPU  %MEM     VSZ    RSS  TTY   STAT   START   TIME  COMMAND
root     <span class="m">1</span>   0.0   0.0    <span class="m">2136</span>    <span class="m">644</span>  ?     Ss     Mar05   0:31  init
root     <span class="m">2</span>   0.0   0.0       <span class="m">0</span>      <span class="m">0</span>  ?     S<span class="p">&amp;</span>lt<span class="p">;</span>     Mar05   0:00  <span class="o">[</span>kt<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果包含的列的含义如下。</p>
<ul>
<li><code>USER</code> 用户ID，表示进程的所有者</li>
<li><code>%CPU</code> 百分比表示的 CPU 使用率</li>
<li><code>%MEM</code> 百分比表示的内存使用率</li>
<li><code>VSZ</code> 虚拟内存大小</li>
<li><code>RSS</code> 进程占用的物理内存的大小，以千字节为单位。</li>
<li><code>START</code> 进程运行的起始时间。若超过24小时，则用天表示。</li>
</ul>
<h2 id="top">top</h2>
<p><code>top</code>命令可以查看机器的当前状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ top
</code></pre></td></tr></table>
</div>
</div><p>它的输出结果分为两部分，最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。</p>
<p>输出结果是动态更新的，默认每三分钟更新一次。</p>
<h2 id="jobs">jobs</h2>
<p><code>jobs</code>命令用来查看后台任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">jobs</span>
<span class="o">[</span>1<span class="o">]</span>+ Running            xlogo <span class="p">&amp;</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果之中，每个后台任务会有一个编号。上面结果中，<code>xlogo</code>的编号是<code>1</code>，<code>+</code>表示正在运行。</p>
<h2 id="fg">fg</h2>
<p><code>fg</code>命令用于将后台任务切换到前台。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">fg</span> %1
</code></pre></td></tr></table>
</div>
</div><p><code>fg</code>命令之后，跟随着一个百分号和工作序号，用来指定切换哪一个后台任务。如果只有一个后台任务，那么<code>fg</code>命令可以不带参数。</p>
<h2 id="bg">bg</h2>
<p><code>bg</code>命令用于将一个暂停的前台任务，转移到后台。只有暂停的任务，才能使用<code>bg</code>命令，因为正在运行的任务，命令行是无法输入的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">bg</span> %1
</code></pre></td></tr></table>
</div>
</div><p><code>Ctrl + z</code>可以暂停正在运行的前台任务。</p>
<h2 id="kill">kill</h2>
<p><code>kill</code>命令用于杀死进程。它的参数是进程ID。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">kill</span> <span class="m">28401</span>
</code></pre></td></tr></table>
</div>
</div><p><code>kill</code>命令的实质是操作系统向进程发送信号。在使用 Ctrl-c 的情况下，会发送一个叫做 INT（中断）的信号；当使用 Ctrl-z 时，则发送一个叫做 TSTP（终端停止）的信号。</p>
<p><code>kill</code>命令可以用来向进程发送指定信号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">kill</span> <span class="o">[</span>-signal<span class="o">]</span> PID
</code></pre></td></tr></table>
</div>
</div><p>下面是常见信号。</p>
<ul>
<li>HUP：编号1，表示挂起。发送这个信号到前台程序，程序会终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</li>
<li>INT：编号2，中断。实现和<code>Ctrl-c</code>一样的功能，由终端发送。通常，它会终止一个程序。</li>
<li>KILL：编号9，杀死。进程可能选择忽略这个信号。所以，操作系统不发送该信号到目标进程，而是内核立即终止这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存劳动成果。因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。</li>
<li>TERM：编号15，终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么这个信号终止。</li>
<li>CONT：编号18，继续。在停止一段时间后，进程恢复运行。</li>
<li>STOP：编号19，停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。</li>
<li>QUIT：编号3，退出</li>
<li>SEGV：编号11，段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说，程序试图写入内存，而这个内存空间是不允许此程序写入的。</li>
<li>TSTP：编号20，终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。</li>
<li>WINCH：编号28，改变窗口大小。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。</li>
</ul>
<p><code>-l</code>参数可以列出所有信号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">kill</span> -l
</code></pre></td></tr></table>
</div>
</div><h2 id="killall">killall</h2>
<p><code>killall</code>命令用于向指定的程序或用户发送信号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ killall <span class="o">[</span>-u user<span class="o">]</span> <span class="o">[</span>-signal<span class="o">]</span> name
</code></pre></td></tr></table>
</div>
</div><h2 id="其他进程相关命令">其他进程相关命令</h2>
<ul>
<li><code>pstree</code> 输出树型结构的进程列表，这个列表展示了进程间父/子关系。</li>
<li><code>vmstat</code> 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。 为了看到连续的显示结果，则在命令名后加上延时的时间（以秒为单位）。例如，“vmstat 5”。 终止输出，按下 Ctrl-c 组合键。</li>
<li><code>xload</code> 一个图形界面程序，可以画出系统负载的图形。</li>
<li><code>tload</code> 与<code>xload</code>程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。</li>
</ul>
<h1 id="重定向">重定向</h1>
<p>重定向指的是将命令行输出写入指定位置。</p>
<ul>
<li><code>cmd1 | cmd2</code>：Pipe; take standard output of cmd1 as standard input to cmd2.</li>
<li><code>&gt; file</code>：Direct standard output to file.</li>
<li><code>&lt; file</code>：Take standard input from file.</li>
<li><code>&gt;&gt; file</code>：Direct standard output to file; append to file if it already exists.</li>
<li><code>&gt;| file</code>：Force standard output to file even if noclobber is set.</li>
<li><code>n&gt;| file</code>：Force output to file from file descriptor n even if noclobber is set.</li>
<li><code>&lt;&gt; file</code>：Use file as both standard input and standard output.</li>
<li><code>n&lt;&gt; file</code>：Use file as both input and output for file descriptor n.</li>
<li><code>&lt;&lt; label</code>：Here-document; see text.</li>
<li><code>n &gt; file</code>：Direct file descriptor n to file.</li>
<li><code>n &lt; file</code>：Take file descriptor n from file.</li>
<li><code>n &gt;&gt; file</code>：Direct file descriptor n to file; append to file if it already exists.</li>
<li><code>n&gt;&amp;</code>：Duplicate standard output to file descriptor n.</li>
<li><code>n&lt;&amp;</code>：Duplicate standard input from file descriptor n.</li>
<li><code>n&gt;&amp;m</code>：File descriptor  n is made to be a copy of the output file descriptor.</li>
<li><code>n&lt;&amp;m</code>：File descriptor  n is made to be a copy of the input file descriptor.</li>
<li><code>&amp;&gt;file</code>：Directs standard output and standard error to file.</li>
<li><code>&lt;&amp;-</code>：Close the standard input.</li>
<li><code>&gt;&amp;-</code>：Close the standard output.</li>
<li><code>n&gt;&amp;-</code>：Close the output from file descriptor  n.</li>
<li><code>n&lt;&amp;-</code>：Close the input from file descriptor  n.</li>
<li><code>n&gt;&amp;word</code>：If  n is not specified, the standard output (file descriptor 1) is used. If the digits in word do not specify a file descriptor open for output, a redirection error occurs. As a special case, if n is omitted, and word does not expand to one or more digits, the standard output and standard error are redirected as described previously.</li>
<li><code>n&lt;&amp;word</code>：If word expands to one or more digits, the file descriptor denoted by  n is made to be a copy of that file descriptor. If the digits in word do not specify a file descriptor open for input, a redirection error occurs. If word evaluates to -, file descriptor n is closed. If n is not specified, the standard input (file descriptor 0) is used.</li>
<li><code>n&gt;&amp;digit-</code>：Moves the file descriptor digit to file descriptor  n, or the standard output (file descriptor 1) if n is not specified.</li>
<li><code>n&lt;&amp;digit-</code>：Moves the file descriptor digit to file descriptor  n, or the standard input (file descriptor 0) if n is not specified. digit is closed after being duplicated to n.</li>
</ul>
<p><code>&gt;</code>用来将标准输出重定向到指定文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls -l /usr/bin &gt; ls-output.txt
</code></pre></td></tr></table>
</div>
</div><p>如果重定向后的指定文件已经存在，就会被覆盖，不会有任何提示。</p>
<p>如果命令没有任何输出，那么重定向之后，得到的是一个长度为<code>0</code>的文件。因此，<code>&gt;</code>具有创建新文件或改写现存文件、将其改为长度<code>0</code>的作用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ &gt; ls-output.txt
</code></pre></td></tr></table>
</div>
</div><p><code>&gt;&gt;</code>用来将标准输出重定向追加到指定文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls -l /usr/bin &gt;&gt; ls-output.txt
</code></pre></td></tr></table>
</div>
</div><p><code>2&gt;</code>用来将标准错误重定向到指定文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls -l /bin/usr 2&gt; ls-error.txt
</code></pre></td></tr></table>
</div>
</div><p>标准输出和标准错误，可以重定向到同一个文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls -l /bin/usr &gt; ls-output.txt 2&gt;<span class="p">&amp;</span><span class="m">1</span>
<span class="c1"># 或者</span>
$ ls -l /bin/usr <span class="p">&amp;</span>&gt; ls-output.txt

<span class="c1"># 追加到同一个文件</span>
$ ls -l /bin/usr <span class="p">&amp;</span>&gt;&gt; ls-output.txt
</code></pre></td></tr></table>
</div>
</div><p>如果不希望输出错误信息，可以将它重定向到一个特殊文件<code>/dev/null</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls -l /bin/usr 2&gt; /dev/null
</code></pre></td></tr></table>
</div>
</div><p><code>|</code>用于将一个命令的标准输出，重定向到另一个命令的标准输入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls -l /usr/bin <span class="p">|</span> less
</code></pre></td></tr></table>
</div>
</div><p>不要将<code>&gt;</code>与<code>|</code>混淆。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls &gt; less
</code></pre></td></tr></table>
</div>
</div><p>上面命令会在当前目录，生成一个名为<code>less</code>的文本文件。</p>
<p>下面是标准错误重定向的一个例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">invalid_input <span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">&#34;Invalid input &#39;</span><span class="nv">$REPLY</span><span class="s2">&#39;&#34;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
    <span class="nb">exit</span> <span class="m">1</span>
<span class="o">}</span>
<span class="nb">read</span> -p <span class="s2">&#34;Enter a single item &gt; &#34;</span>
<span class="o">[[</span> -z <span class="nv">$REPLY</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> invalid_input
</code></pre></td></tr></table>
</div>
</div><h2 id="tee">tee</h2>
<p><code>tee</code>命令用于同时将标准输出重定向到文件，以及另一个命令的标准输入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls /usr/bin <span class="p">|</span> tee ls.txt <span class="p">|</span> grep zip
</code></pre></td></tr></table>
</div>
</div><h2 id="命令替换">命令替换</h2>
<p>命令替换（command substitution）指的是将一个命令的输出，替换进入另一个命令。<code>$(command)</code>表示命令替换，另一种写法是使用反引号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">echo</span> <span class="k">$(</span>ls<span class="k">)</span>
<span class="c1"># 或者</span>
$ <span class="nb">echo</span> <span class="sb">`</span>ls<span class="sb">`</span>

$ ls -l <span class="k">$(</span>which cp<span class="k">)</span>
<span class="c1"># 或者</span>
$ ls -l <span class="sb">`</span>which cp<span class="sb">`</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="basename">basename</h2>
<p><code>basename</code>命令清除 一个路径名的开头部分，只留下一个文件的基本名称。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="c1"># file_info: simple file information program</span>
<span class="nv">PROGNAME</span><span class="o">=</span><span class="k">$(</span>basename <span class="nv">$0</span><span class="k">)</span>
<span class="k">if</span> <span class="o">[[</span> -e <span class="nv">$1</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> -e <span class="s2">&#34;\nFile Type:&#34;</span>
    file <span class="nv">$1</span>
    <span class="nb">echo</span> -e <span class="s2">&#34;\nFile Status:&#34;</span>
    stat <span class="nv">$1</span>
<span class="k">else</span>
    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$PROGNAME</span><span class="s2">: usage: </span><span class="nv">$PROGNAME</span><span class="s2"> file&#34;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
    <span class="nb">exit</span> <span class="m">1</span>
<span class="k">fi</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="正则表达式">正则表达式</h1>
<p><code>正则表达式</code>是表达文本模式的方法。</p>
<ul>
<li><code>.</code>：匹配任何单个字符。</li>
<li><code>?</code>：上一项是可选的，最多匹配一次。</li>
<li><code>*</code>：前一项将被匹配零次或多次。</li>
<li><code>+</code>：前一项将被匹配一次或多次。</li>
<li><code>{N}</code>：上一项完全匹配N次。</li>
<li><code>{N，}</code>：前一项匹配N次或多次。</li>
<li><code>{N，M}</code>：前一项至少匹配N次，但不超过M次。</li>
<li><code>--</code>：表示范围，如果它不是列表中的第一个或最后一个，也不是列表中某个范围的终点。</li>
<li><code>^</code>：匹配行首的空字符串；也代表不在列表范围内的字符。</li>
<li><code>$</code>：匹配行尾的空字符串。</li>
<li><code>\b</code>：匹配单词边缘的空字符串。</li>
<li><code>\B</code>：匹配空字符串，前提是它不在单词的边缘。</li>
<li><code>\&lt;</code>：匹配单词开头的空字符串。</li>
<li><code>\&gt;</code>：匹配单词末尾的空字符串。</li>
</ul>
<h2 id="元字符">元字符</h2>
<p><code>元字符</code>是表示特殊函数的字符，包括以下这些<code>^ $ . [ ] { } - ? * + ( ) | \\</code>。除了元字符，其他字符在正则表达式中，都表示原来的含义。</p>
<ul>
<li><code>.</code> 匹配任意字符，但不含空字符</li>
<li><code>^</code> 匹配文本行开头</li>
<li><code>$</code> 匹配文本行结尾</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ grep -h <span class="s1">&#39;.zip&#39;</span> dirlist*.txt
</code></pre></td></tr></table>
</div>
</div><p>上面命令在文件中查找包含正则表达式“.zip”的文本行。注意，上面命令不会匹配<code>zip</code>程序，因为<code>zip</code>只有三个字符，而<code>.zip</code>要求四个字符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ grep -h <span class="s1">&#39;^zip&#39;</span> dirlist*.txt
$ grep -h <span class="s1">&#39;zip$&#39;</span> dirlist*.txt
</code></pre></td></tr></table>
</div>
</div><p>上面命令分别在文件列表中搜索行首，行尾以及行首和行尾同时包含字符串“zip”（例如，zip 独占一行）的匹配行。 注意正则表达式‘^$’（行首和行尾之间没有字符）会匹配空行。</p>
<h2 id="方括号">方括号</h2>
<p>方括号之中的字符，表示可以任意匹配其中的一个。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ grep -h <span class="s1">&#39;[bg]zip&#39;</span> dirlist*.txt
</code></pre></td></tr></table>
</div>
</div><p>上面命令匹配包含字符串“bzip”或者“gzip”的任意行。</p>
<p>注意，元字符放入方括号之中，会失去其特殊含义。但有两种情况除外，<code>^</code>在方括号的开头，表示否定，否则只是一个普通字符，表示原义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ grep -h <span class="s1">&#39;[^bg]zip&#39;</span> dirlist*.txt
</code></pre></td></tr></table>
</div>
</div><p>上面命令匹配不以<code>b</code>或<code>g</code>开头的<code>zip</code>字符串。注意，上面命令不会匹配<code>zip</code>，因为一个否定的字符集仍然要求存在一个字符。</p>
<p><code>-</code>在方括号之中表示一个字符区域。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ grep -h <span class="s1">&#39;^[A-Z]&#39;</span> dirlist*.txt
</code></pre></td></tr></table>
</div>
</div><p>上面命令匹配所有以大写字母开头的文本行。类似的，<code>^[A-Za-z0-9]</code>表示以大写字母、小写字母、数字开头的文本行。</p>
<p>注意，连字号如果不构成一个字符区域，则表示其本来的含义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ grep -h <span class="s1">&#39;[-AZ]&#39;</span> dirlist*.txt
</code></pre></td></tr></table>
</div>
</div><p>上面命令匹配包含一个连字符，或一个大写字母“A”，或一个大写字母“Z”的文件名。</p>
<h2 id="预定义字符类">预定义字符类</h2>
<p>由于<code>locale</code>设置不同，Shell展开正则表达式<code>[A-Z]</code>时，可能不是解释为所有大写字母，而是解释为包括所有字母的字典顺序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls /usr/sbin/<span class="o">[</span>A-Z<span class="o">]</span>*
</code></pre></td></tr></table>
</div>
</div><p>上面命令在某些发行版里面，会返回所有大写字母或小写字母开头的文件。</p>
<p>为了避免这个问题，可以使用正则表达式的预定义字符类。</p>
<ul>
<li><code>[:alnum:]</code>	字母数字字符。在 ASCII 中，等价于：<code>[A-Za-z0-9]</code></li>
<li><code>[:word:]</code>	与<code>[:alnum:]</code>相同, 但增加了下划线字符。</li>
<li><code>[:alpha:]</code>	字母字符。在 ASCII 中，等价于<code>[A-Za-z]</code></li>
<li><code>[:blank:]</code>	包含空格和 tab 字符。</li>
<li><code>[:cntrl:]</code>	ASCII 的控制码。包含了0到31，和127的 ASCII 字符。</li>
<li><code>[:digit:]</code>	数字0到9</li>
<li><code>[:graph:]</code>	可视字符。在 ASCII 中，它包含33到126的字符。</li>
<li><code>[:lower:]</code>	小写字母。</li>
<li><code>[:punct:]</code>	标点符号字符。</li>
<li><code>[:print:]</code>	可打印的字符。等于<code>[:graph:]</code>中的所有字符，再加上空格字符。</li>
<li><code>[:space:]</code>	空白字符，包括空格，tab，回车，换行，vertical tab, 和 form feed.在 ASCII 中， 等价于<code>[ \t\r\n\v\f]</code></li>
<li><code>[:upper:]</code>	大写字母。</li>
<li><code>[:xdigit:]</code>	用来表示十六进制数字的字符。在 ASCII 中，等价于<code>[0-9A-Fa-f]</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls /usr/sbin/<span class="o">[[</span>:upper:<span class="o">]]</span>*
</code></pre></td></tr></table>
</div>
</div><p>上面命令返回所有大写字母开头的文件名。</p>
<h2 id="选择">选择</h2>
<p><code>|</code>表示匹配一系列字符串之中的一个。注意与方括号区分，方括号表示匹配一系列字符之中的一个。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">echo</span> <span class="s2">&#34;AAA&#34;</span> <span class="p">|</span> grep -E <span class="s1">&#39;AAA|BBB&#39;</span>
AAA
$ <span class="nb">echo</span> <span class="s2">&#34;BBB&#34;</span> <span class="p">|</span> grep -E <span class="s1">&#39;AAA|BBB&#39;</span>
BBB
$ <span class="nb">echo</span> <span class="s2">&#34;CCC&#34;</span> <span class="p">|</span> grep -E <span class="s1">&#39;AAA|BBB&#39;</span>
$
</code></pre></td></tr></table>
</div>
</div><p>上面代码中，<code>AAA|BBB</code>表示匹配字符串<code>AAA</code>或者是字符串<code>BBB</code>。<code>grep</code>程序使用<code>-E</code>参数，表示按照正则表达式规则匹配。并且，这个正则表达式放在单引号之中，为的是阻止Shell把<code>|</code>解释为管道操作符。</p>
<p><code>|</code>可以多个连用，也可以与其他正则规则结合使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">echo</span> <span class="s2">&#34;AAA&#34;</span> <span class="p">|</span> grep -E <span class="s1">&#39;AAA|BBB|CCC&#39;</span>

$ grep -Eh <span class="s1">&#39;^(bz|gz|zip)&#39;</span> dirlist*.txt
</code></pre></td></tr></table>
</div>
</div><h2 id="量词操作符">量词操作符</h2>
<p>量词操作符表示一个元素被匹配的次数。</p>
<ul>
<li><code>?</code> 匹配前面的元素出现0次或1次</li>
<li><code>*</code> 匹配前面的元素出现0次或多次</li>
<li><code>+</code> 匹配前面的元素出现1次或多次</li>
<li><code>{n}</code> 匹配前面的元素出现了<code>n</code>次</li>
<li><code>{n,m}</code> 匹配前面的元素它至少出现了<code>n</code>次，但是不多于<code>m</code>次</li>
<li><code>{n,}</code> 匹配前面的元素至少出现了<code>n</code>次</li>
<li><code>{,m}</code> 匹配前面的元素，如果它出现的次数不多于 m 次。</li>
</ul>
<h1 id="系统信息">系统信息</h1>
<h2 id="uname">uname</h2>
<p><code>uname</code>命令返回当前机器的信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 内核的版本</span>
$ uname -r
3.2.0-24-virtual

<span class="c1"># CPU 架构</span>
$ uname -m
x86_64
</code></pre></td></tr></table>
</div>
</div><p>如果要了解操作系统的版本，可以查看<code>/etc/issue</code>文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ cat /etc/issue
Debian GNU/Linux <span class="m">9</span> <span class="se">\n</span> <span class="se">\l</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="service">service</h2>
<p><code>service</code>命令可以查看当前正在运行的服务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ service --status-all
 <span class="o">[</span> + <span class="o">]</span>  apache2
 <span class="o">[</span> ? <span class="o">]</span>  atd
 <span class="o">[</span> - <span class="o">]</span>  bootlogd
</code></pre></td></tr></table>
</div>
</div><p>上面代码中，<code>+</code>表示正在运行，<code>-</code>表示已经停止，<code>?</code>表示<code>service</code>命令不了解相关信息。</p>
<h1 id="文本处理">文本处理</h1>
<h2 id="cat">cat</h2>
<p><code>cat</code>可以文件的内容，显示在标准输出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ cat text1
<span class="m">1</span> apple
<span class="m">2</span> pear
<span class="m">3</span> banana
</code></pre></td></tr></table>
</div>
</div><p>它也可以同时输出多个文件内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ cat text1 text2
</code></pre></td></tr></table>
</div>
</div><p>它与重定向结合，就可以合并多个文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 合并文本文件</span>
$ cat text* &gt; text.all

<span class="c1"># 合并二进制文件</span>
$ cat movie.mpeg.0* &gt; movie.mpeg
</code></pre></td></tr></table>
</div>
</div><p>如果调用<code>cat</code>命令时没有任何参数，它将读取标准输入，然后显示到标准输出。按下<code>Ctrl + d</code>，将会结束<code>cat</code>读取标准输入。利用这一点，可以将键盘输入写入指定文件，按下<code>Ctrl + d</code>结束输入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ cat &gt; lazy_dog.txt
</code></pre></td></tr></table>
</div>
</div><p>它的参数如下。</p>
<ul>
<li><code>-n</code> 输出结果显示行号</li>
<li><code>-s</code> 将多个连续的空白行，输出为一行</li>
<li><code>-A</code> 输出结果中显示控制符，比如Tab键显示为<code>^I</code>，行尾显示<code>$</code></li>
</ul>
<p><code>cat</code>支持Here document，显示多行文本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">cat <span class="s">&lt;&lt; _EOF_
</span><span class="s">&lt;HTML&gt;
</span><span class="s">         &lt;HEAD&gt;
</span><span class="s">                &lt;TITLE&gt;$TITLE&lt;/TITLE&gt;
</span><span class="s">         &lt;/HEAD&gt;
</span><span class="s">         &lt;BODY&gt;
</span><span class="s">                &lt;H1&gt;$TITLE&lt;/H1&gt;
</span><span class="s">                &lt;P&gt;$TIME_STAMP&lt;/P&gt;
</span><span class="s">         &lt;/BODY&gt;
</span><span class="s">&lt;/HTML&gt;
</span><span class="s">_EOF_</span>
</code></pre></td></tr></table>
</div>
</div><p>Here document 常在脚本当中作为输入的手段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sort -k2 <span class="s">&lt;&lt;END
</span><span class="s">&gt; 1 apple
</span><span class="s">&gt; 2 pear
</span><span class="s">&gt; 3 banana
</span><span class="s">&gt; END</span>
<span class="m">1</span> apple
<span class="m">3</span> banana
<span class="m">2</span> pear
</code></pre></td></tr></table>
</div>
</div><p>如果使用<code>&lt;&lt;-</code>代替<code>&lt;&lt;</code>，行首的tab键将被剥离。</p>
<h2 id="nl">nl</h2>
<p><code>nl</code>命令为文本文件添加行号，显示在标准输出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ nl example.txt
</code></pre></td></tr></table>
</div>
</div><h2 id="sort">sort</h2>
<p><code>sort</code>命令将文本文件的所有行排序后输出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sort file1.txt file2.txt file3.txt &gt; final_sorted_list.txt
</code></pre></td></tr></table>
</div>
</div><p>它的参数如下。</p>
<ul>
<li><code>-b</code> <code>--ignore-leading-blanks</code> 默认情况下，排序用的是每行的第一个字符。这个参数忽略每行开头的空格，从第一个非空白字符开始排序。</li>
<li><code>-f</code> <code>--ignore-case</code> 让排序不区分大小写。</li>
<li><code>-n</code> <code>--numeric-sort</code> 按照数值排序，而不是字符值，用于行首是数值的情况。</li>
<li><code>-r</code> <code>--reverse</code> 按相反顺序排序。结果按照降序排列，而不是升序。</li>
<li><code>-k</code> <code>--key=field1[,field2]</code> 指定按照每行的第几个字段（从1开始）排序，而不是按照行首字符排序。该属性可以多个连用，用于指定多重排序标准，还可以指定每个字段指定排序标准，这些值与全局属性一致，比如b（忽略开头的空格），n（数值排序），r（逆向排序）等等。</li>
<li><code>-m</code> <code>--merge</code> 把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。</li>
<li><code>-o</code> <code>--output=file</code> 把排好序的输出结果发送到文件，而不是标准输出。</li>
<li><code>-t</code> <code>--field-separator=char</code> 定义字段分隔字符。默认情况下，字段由空格或制表符分隔。</li>
<li><code>-u</code> 输出结果中删除重复行</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sort --key<span class="o">=</span>1,1 --key<span class="o">=</span>2n distros.txt
</code></pre></td></tr></table>
</div>
</div><p>上面命令中，第一个<code>--key</code>指定第一排序标准是只用第一字段（<code>1,1</code>），也可以指定使用第一字段第一个字符（<code>1.1</code>）；第二排序标准是第二字段，按数值排序。</p>
<h2 id="uniq">uniq</h2>
<p><code>uniq</code>命令在排序后的行中，删除所有重复的行，保证所有输出没有重复。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls /bin /usr/bin <span class="p">|</span> sort <span class="p">|</span> uniq
</code></pre></td></tr></table>
</div>
</div><p>它的参数如下。</p>
<ul>
<li><code>-c</code>	输出所有的重复行，并且每行开头显示重复的次数。</li>
<li><code>-d</code>	只输出重复行，而不是不重复的文本行。</li>
<li><code>-f n</code>	忽略每行开头的 n 个字段，字段之间由空格分隔，正如 sort 程序中的空格分隔符；然而， 不同于 sort 程序，uniq 没有选项来设置备用的字段分隔符。</li>
<li><code>-i</code>	在比较文本行的时候忽略大小写。</li>
<li><code>-s n</code>	跳过（忽略）每行开头的 n 个字符。</li>
<li><code>-u</code>	只是输出独有的文本行。这是默认的。</li>
<li><code>-V</code> 按照版本号排序。</li>
</ul>
<p><code>-V</code>参数可以按版本号排列（从小到大）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sort -V input.txt
1.0.15
1.3.0
2.1.2
3.0.0
</code></pre></td></tr></table>
</div>
</div><p><code>-rV</code>参数可以按版本号逆序排列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sort -rV input.txt
3.0.0
2.1.2
1.3.0
1.0.15
</code></pre></td></tr></table>
</div>
</div><h2 id="cut">cut</h2>
<p><code>cut</code>程序用来从文本行中抽取文本，并把其输出到标准输出。它能够接受多个文件参数或者标准输入。</p>
<p>它的参数如下。</p>
<ul>
<li><code>-c char_list</code> 抽取指定范围的文本</li>
<li><code>-f field_list</code> 抽取指定字段，字段之间可以tab分隔也可以逗号分隔</li>
<li><code>-d delim_char</code> 指定字段分隔符，默认是tab键</li>
<li><code>--complement</code>	抽取整个文本行，除了那些由-c 和／或-f 选项指定的文本。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 抽取每行的第三个字段</span>
$ cut -f <span class="m">3</span> distros.txt

<span class="c1"># 抽取每行的第7到第10个字符</span>
$ cut -c 7-10 distros.txt

<span class="c1"># 抽取每行的第23个到结尾的字符1</span>
$ cut -c 23- distros.txt

<span class="c1"># 指定字段分隔符为冒号</span>
$ cut -d <span class="s1">&#39;:&#39;</span> -f <span class="m">1</span> /etc/passwd
</code></pre></td></tr></table>
</div>
</div><h2 id="paste">paste</h2>
<p><code>paste</code>程序将多个文本文件按行合并，即每一行都由原来文本文件的每一行组成，显示在标准输出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ paste distros-dates.txt distros-versions.txt
</code></pre></td></tr></table>
</div>
</div><h2 id="wc">wc</h2>
<p><code>wc</code>命令输出一个文本文件的统计信息（word count），一共有三个值，分别为行数、词数和字节数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ wc ls-output.txt
 <span class="m">7902</span> <span class="m">64566</span> <span class="m">503634</span> ls-output.txt
</code></pre></td></tr></table>
</div>
</div><p>如果使用<code>-l</code>参数，则只输出行数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls /bin /usr/bin <span class="p">|</span> sort <span class="p">|</span> uniq <span class="p">|</span> wc -l
 <span class="m">2728</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="head">head</h2>
<p><code>head</code>命令返回文本文件的头部，默认显示10行。</p>
<p><code>-n</code>参数指定显示的行数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ head -n <span class="m">5</span> ls-output.txt
</code></pre></td></tr></table>
</div>
</div><h2 id="tail">tail</h2>
<p><code>tail</code>命令返回文本文件的尾部，默认显示10行。</p>
<p><code>-n</code>参数指定显示的行数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ tail -n <span class="m">5</span> ls-output.txt
</code></pre></td></tr></table>
</div>
</div><p><code>-f</code>会实时追加显示新增的内容，常用于实时监控日志，按<code>Ctrl + c</code>停止。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ tail -f /var/log/messages
</code></pre></td></tr></table>
</div>
</div><h2 id="grep">grep</h2>
<p><code>grep</code>程序用于在指定文件之中，搜索符合某个模式的行，并把搜索结果输出到标准输出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ grep keyword foo.txt
</code></pre></td></tr></table>
</div>
</div><p>上面命令输出<code>foo.txt</code>之中匹配<code>keyword</code>的行。</p>
<p><code>grep</code>程序可以同时搜索多个文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ grep keyword f*.txt
</code></pre></td></tr></table>
</div>
</div><p>上面命令输出多个文件中匹配<code>keyword</code>的行。</p>
<p><code>-l</code>参数输出匹配的文件名，而不是文件行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ grep -l bzip dirlist*.txt
</code></pre></td></tr></table>
</div>
</div><p>如果想搜索文件名，而不是文件内容，可以使用重定向。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ ls /usr/bin <span class="p">|</span> grep zip
</code></pre></td></tr></table>
</div>
</div><p>上面命令会输出<code>/usr/bin</code>目录中，文件名中包含子字符串<code>zip</code>的所有文件。</p>
<p>参数的含义。</p>
<ul>
<li><code>-c</code>或<code>--count</code> 输出匹配的数量，而不是匹配的文本行。如果使用了<code>-v</code>，则输出不匹配的数量。</li>
<li><code>-h</code>或<code>--no-filename</code> 应用于多文件搜索，不在每行匹配的文本前，输出文件名</li>
<li><code>-i</code>或<code>--ignore-case</code> 忽略大小写</li>
<li><code>-l</code>或<code>--files-with-matches</code> 输出包含匹配项的文件名，而不是文本行本身</li>
<li><code>-L</code>或<code>--files-without-match</code> 类似于<code>-l</code>，但输出不包含匹配项的文件名</li>
<li><code>-n</code>或<code>--line-number</code> 每个匹配行之前输出其对应的行号</li>
<li><code>-v</code>或<code>--invert-match</code> 只返回不符合模式的行</li>
</ul>
<h2 id="sed">sed</h2>
<p><code>sed</code>是一个强大的文本编辑工具。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 输出前5行</span>
$ sed -n <span class="s1">&#39;1,5p&#39;</span> distros.txt

<span class="c1"># 输出包含指定内容的行</span>
$ sed -n <span class="s1">&#39;/SUSE/p&#39;</span> distros.txt

<span class="c1"># 输出不包含指定内容的行</span>
$ sed -n <span class="s1">&#39;/SUSE/!p&#39;</span> distros.txt

<span class="c1"># 替换内容（只替换第一个）</span>
$ sed <span class="s1">&#39;s/regexp/replacement/&#39;</span> distros.txt

<span class="c1"># 替换内容（全局替换）</span>
$ sed <span class="s1">&#39;s/regexp/replacement/g&#39;</span> distros.txt
</code></pre></td></tr></table>
</div>
</div><h1 id="时间管理">时间管理</h1>
<h2 id="date-命令">date 命令</h2>
<p><code>date</code>命令用于输出当前时间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ date
2016年 03月 14日 星期一 17:32:35 CST
</code></pre></td></tr></table>
</div>
</div><p><code>date</code>命令后面用加号（<code>+</code>）指定显示的格式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ date +%d_%b_%Y
10_Sep_2018

$ date +%D
09/10/18

$ date +%F-%T
2018-09-10-11:09:51
</code></pre></td></tr></table>
</div>
</div><p>完整的格式参数如下。</p>
<ul>
<li>%a 星期名的缩写（Sun）</li>
<li>%A 星期名的全称（Sunday）</li>
<li>%b 月份的缩写（Jan）</li>
<li>%B 月份的全称（January）</li>
<li>%c 日期和时间（Thu Mar  3 23:05:25 2005）</li>
<li>%C 世纪，就是年份数省略后两位（20）</li>
<li>%d 一个月的第几天（01）</li>
<li>%D 日期，等同于<code>%m/%d/%y</code></li>
<li>%e 一个月的第几天，用空格补零，等同于<code>%_d</code></li>
<li>%F 完整的日期，等同于<code>%Y-%m-%d</code></li>
<li>%g     last two digits of year of ISO week number (see %G)</li>
<li>%G     year of ISO week number (see %V); normally useful only with %V</li>
<li>%h   等同于<code>%b</code></li>
<li>%H   小时（00..23）</li>
<li>%I   小时（01..12）</li>
<li>%j     day of year (001..366)</li>
<li>%k     hour ( 0..23)</li>
<li>%l     hour ( 1..12)</li>
<li>%m     month (01..12)</li>
<li>%M     minute (00..59)</li>
<li>%N     nanoseconds (000000000..999999999)</li>
<li>%p     locale’s equivalent of either AM or PM; blank if not known</li>
<li>%P     like %p, but lower case</li>
<li>%r     locale’s 12-hour clock time (e.g., 11:11:04 PM)</li>
<li>%R     24-hour hour and minute; same as %H:%M</li>
<li>%s     seconds since 1970-01-01 00:00:00 UTC</li>
<li>%S     second (00..60)</li>
<li>%T     time; same as %H:%M:%S</li>
<li>%u     day of week (1..7); 1 is Monday</li>
<li>%U     week number of year, with Sunday as first day of week (00..53)</li>
<li>%V     ISO week number, with Monday as first day of week (01..53)</li>
<li>%w     day of week (0..6); 0 is Sunday</li>
<li>%W     week number of year, with Monday as first day of week (00..53)</li>
<li>%x     locale’s date representation (e.g., 12/31/99)</li>
<li>%X     locale’s time representation (e.g., 23:13:48)</li>
<li>%y     last two digits of year (00..99)</li>
<li>%Y     year</li>
<li>%z     +hhmm numeric timezone (e.g., -0400)</li>
<li>%:z    +hh:mm numeric timezone (e.g., -04:00)</li>
<li>%::z   +hh:mm:ss numeric time zone (e.g., -04:00:00)</li>
<li>%Z     alphabetic time zone abbreviation (e.g., EDT)</li>
</ul>
<h2 id="cal-命令">cal 命令</h2>
<p><code>cal</code>命令用于显示日历。不带有参数时，显示的是当前月份。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ cal
      三月 <span class="m">2016</span>
日 一 二 三 四 五 六
       <span class="m">1</span>  <span class="m">2</span>  <span class="m">3</span>  <span class="m">4</span>  <span class="m">5</span>
 <span class="m">6</span>  <span class="m">7</span>  <span class="m">8</span>  <span class="m">9</span> <span class="m">10</span> <span class="m">11</span> <span class="m">12</span>
<span class="m">13</span> <span class="m">14</span> <span class="m">15</span> <span class="m">16</span> <span class="m">17</span> <span class="m">18</span> <span class="m">19</span>
<span class="m">20</span> <span class="m">21</span> <span class="m">22</span> <span class="m">23</span> <span class="m">24</span> <span class="m">25</span> <span class="m">26</span>
<span class="m">27</span> <span class="m">28</span> <span class="m">29</span> <span class="m">30</span> <span class="m">31</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="用户管理">用户管理</h1>
<h2 id="id">id</h2>
<p><code>id</code>命令用于查看指定用户的用户名和组名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ id
<span class="nv">uid</span><span class="o">=</span>500<span class="o">(</span>me<span class="o">)</span> <span class="nv">gid</span><span class="o">=</span>500<span class="o">(</span>me<span class="o">)</span> <span class="nv">groups</span><span class="o">=</span>500<span class="o">(</span>me<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>id</code>输出结果分为三个部分，分别是UID（用户编号和用户名）、GID（组编号和组名），groups（用户所在的所有组）。</p>
<p>用户帐户的信息，存放在<code>/etc/passwd</code>文件里面；用户组的信息，存放在<code>/etc/group</code>文件里面。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 返回UID</span>
$ id -u <span class="o">[</span>UserName<span class="o">]</span>

<span class="c1"># 返回GID</span>
$ id -g <span class="o">[</span>UserName<span class="o">]</span>

<span class="c1"># 返回用户名</span>
$ id -un <span class="o">[</span>UserName<span class="o">]</span>

<span class="c1"># 返回组名</span>
$ id -gn <span class="o">[</span>UserName<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的命令，如果省略用户名，则返回当前用户的信息。</p>
<h2 id="su">su</h2>
<p><code>su</code>命令允许你以另一个用户的身份，启动一个新的 shell 会话，或者是以这个用户的身份来发布一个命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ su otherUser
</code></pre></td></tr></table>
</div>
</div><p>执行上面的命令以后，系统会提示输入密码。通过以后，就以另一个用户身份在执行命令了。</p>
<p>如果不加用户名，则表示切换到root用户。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ su
</code></pre></td></tr></table>
</div>
</div><p><code>-l</code>参数表示启动一个需要登录的新的Shell，这意味着工作目录会切换到该用户的主目录。它的缩写形式是<code>-</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ su -
</code></pre></td></tr></table>
</div>
</div><p>上面命令表示，切换到root用户的身份，且工作目录也切换到root用户的主目录。</p>
<p><code>-c</code>参数表示只以其他用户的身份，执行单个命令，而不是启动一个新的Session。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ su -c <span class="s1">&#39;command&#39;</span>

<span class="c1"># 实例</span>
$ su -c <span class="s1">&#39;ls -l /root/*&#39;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="sudo">sudo</h2>
<p><code>sudo</code>命令很类似<code>su</code>命令，但有几点差别。</p>
<ul>
<li>对于管理员来说，<code>sudo</code>命令的可配置性更高</li>
<li><code>sudo</code>命令通常只用于执行单个命令，而不是开启另一个Session。</li>
<li><code>sudo</code>命令不要求超级用户的密码，而是用户使自己的密码来认证。</li>
</ul>
<p><code>sudo</code>的设置在文件<code>/etc/sudoers</code>之中。</p>
<p><code>-l</code>参数列出用户拥有的所有权限。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo -l
</code></pre></td></tr></table>
</div>
</div><h2 id="chown">chown</h2>
<p><code>chown</code>命令用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ chown <span class="o">[</span>owner<span class="o">][</span>:<span class="o">[</span>group<span class="o">]]</span> file
</code></pre></td></tr></table>
</div>
</div><p>下面是一些例子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 更改文件所有者</span>
$ sudo chown bob foo.txt

<span class="c1"># 更改文件所有者和用户组</span>
$ sudo chown bob:users foo.txt

<span class="c1"># 更改用户组</span>
$ sudo chown :admins foo.txt

<span class="c1"># 更改文件所有者和用户组（用户 bob 登录系统时，所属的用户组）</span>
$ sudo chown bob: foo.txt
</code></pre></td></tr></table>
</div>
</div><h2 id="chgrp">chgrp</h2>
<p><code>chgrp</code>命令更改用户组，用法与<code>chown</code>命令类似。</p>
<h2 id="useradd">useradd</h2>
<p><code>useradd</code>命令用来新增用户。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ useradd -G admin -d /home/bill -s /bin/bash -m bill
</code></pre></td></tr></table>
</div>
</div><p>上面命令新增用户<code>bill</code>，参数<code>-G</code>指定用户所在的组，参数<code>d</code>指定用户的主目录，参数<code>s</code>指定用户的 Shell，参数<code>m</code>表示如果该目录不存在，则创建该目录。</p>
<h2 id="usermod">usermod</h2>
<p><code>usermod</code>命令用来修改用户的各项属性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ usermod -g sales jerry
</code></pre></td></tr></table>
</div>
</div><p>上面的命令修改用户<code>jerry</code>属于的主要用户组为<code>sales</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ usermod -G sales jerry
</code></pre></td></tr></table>
</div>
</div><p>上面的命令修改用户<code>jerry</code>属于的次要用户组为<code>sales</code>。</p>
<h2 id="adduser">adduser</h2>
<p><code>adduser</code>命令用来将一个用户加入用户组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo adduser username grouptoadd
</code></pre></td></tr></table>
</div>
</div><h2 id="groupadd">groupadd</h2>
<p><code>groupadd</code>命令用来新建一个用户组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo groupadd group1
$ sudo adduser foobar group1
</code></pre></td></tr></table>
</div>
</div><h2 id="groupdel">groupdel</h2>
<p><code>groupdel</code>命令用来删除一个用户组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo groupdel group1
</code></pre></td></tr></table>
</div>
</div><h2 id="passwd">passwd</h2>
<p><code>passwd</code>命令用于修改密码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 修改自己的密码</span>
$ passwd

<span class="c1"># 修改其他用户的密码</span>
$ sudo passwd <span class="o">[</span>user<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Firefly</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2020-12-29
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/notepad/docs/bash/bash/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">bash</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/notepad/docs/bash/bash-commands/">
            <span class="next-text nav-default">bash-commands</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="http://github.com/fierygit" class="iconfont icon-github" title="github"></a>
  <a href="http://fireflying.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>Firefly</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
