<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <title>
        图 |
        
        Firefly
    </title>
    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true},"style":{"primary_color":"#0066CC","avatar":"images/avatar.png","favicon":"images/logo.svg","img_position":"left","left_side_width":"260px","content_max_width":"900px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":false,"description":"Welcome"}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"version":"3.0.3"};
    KEEP.language = {"search":"Search...","prev":"Prev","next":"Next","prev_posts":"Prev posts","next_posts":"Next posts","page":"Page %d","recent_posts":"Recent Posts","share":"Share","powered_by":"Powered by %s","theme":"Theme","rss_feed":"RSS Feed","category":"Category","categories":"Categories","tag":"Tag","tags":"Tags","tagcloud":"Tag Cloud","comment":"Comment","home":"Home","archive":"Archive","archives":"Archives","about":"About","site_uv":"Visitor Count","site_pv":"Totalview","links":"Links","link":"Link","top":"TOP","read_more":"Read more","wordcount":"Words","min2read":"Mins","changelog":"Changelog","copyright":{"author":"Post author","title":"Post title","link":"Post link","create_time":"Create time","license_title":"Copyright Notice","license_content":"All articles in this blog are licensed under %s unless stating additionally."},"ago":{"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days age","week":"%s weeks age","month":"%s months age","year":"%s years age"}};
  </script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
<div class="page-container">

    

    <header class="page-header">
        <div class="header-progress"></div>
    </header>

    <main class="page-main">

        <div class="page-main-content">

            <div class="page-main-content-top">
                <header class="header-wrapper">

    <div class="header-content">
        <a class="logo-title" href="/">
            Firefly
        </a>

        <ul class="menu-list">
            
                <li class="menu-item">
                    <a class=""
                       href="/"
                    >
                        HOME
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/archives"
                    >
                        ARCHIVES
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/categories"
                    >
                        CATEGORIES
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/links"
                    >
                        LINKS
                    </a>
                </li>
            
        </ul>

        <div class="menu-bar">
            <div class="menu-bar-middle"></div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">LINKS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


            </div>

            <div class="page-main-content-middle">

                <main class="main-content normal-code-theme">

                    
                        <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">图</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span>Firefly</span>
                        <span class="level">Lv5</span>
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-calendar"></i> 2020-03-28 00:00:00
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>
            <ul>
                
                    <li>
                        <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/leetcode/">leetcode</a>
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i> <span>3.3k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i> <span>16 Mins</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="图论总结"><a href="#图论总结" class="headerlink" title="图论总结"></a><center>图论总结</center></h1><p>[toc]</p>
<p>算法这东西，容易忘记， 捡起来很快， 但也要时间， 因此，做一些简短的记录！</p>
<h3 id="图是什么？"><a href="#图是什么？" class="headerlink" title="图是什么？"></a>图是什么？</h3><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200219203748.png"></p>
<p>树可以存线， 图可以存树，树是一种无环图， 线是最简单的数据结构， 图是较为复杂的一种数据结构！</p>
<h3 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">有向</th>
<th align="center">无向</th>
</tr>
</thead>
<tbody><tr>
<td align="center">有权</td>
<td align="center">有向有权图</td>
<td align="center">无向有权图</td>
</tr>
<tr>
<td align="center">无权</td>
<td align="center">有向无权图</td>
<td align="center">无向无权图</td>
</tr>
</tbody></table>
<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><ul>
<li>邻接矩阵</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vaecotr&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Graph4;</span><br></pre></td></tr></table></figure>

<p>i点到j点的距离！ 空间复杂度： V^2 ,  求一个点的临接点:  V</p>
<ul>
<li>邻接表（链表）</li>
</ul>
<p>只存每个点能到达的点</p>
<p>空间复杂度： O（V+E  ），建图： O（E*V），求一个点的临接点：（O（V））</p>
<p>可以用 hash 或者 红黑树  替换 链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无向无权图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Graph1[maxn];</span><br><span class="line"><span class="comment">// 无向有权图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Graph2[maxn];</span><br><span class="line"><span class="comment">// hash 找很快！ 红黑树  to  cost  </span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;Graph3[maxn];  <span class="comment">// map 默认为0， </span></span><br></pre></td></tr></table></figure>



<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><ul>
<li>树</li>
</ul>
<p>分为 前序， （二叉树）中序， 后序， ==不用记录遍历过的点==！</p>
<ul>
<li>图</li>
</ul>
<p>分为 先序，后续（基本不用），要记录每一个每一个点是否遍历过， visited 记录</p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs41</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">bool</span> *visited)</span> </span>&#123;</span><br><span class="line">  visited[index] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;  <span class="comment">// 前序遍历*************</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[i] &amp;&amp; Graph4[index][i] != <span class="number">0</span>) &#123;</span><br><span class="line">      dfs41(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cout &lt;&lt; index &lt;&lt; &quot; -&gt; &quot;;后序遍历*****************</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs42</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">  <span class="built_in">stack</span>.push(start);</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="built_in">stack</span>.top();</span><br><span class="line">    <span class="built_in">stack</span>.pop();</span><br><span class="line">    visited[temp] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">      <span class="keyword">if</span> (!visited[i] &amp;&amp; Graph4[temp][i] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">stack</span>.push(i);</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>树的BFS和图的BFS是一样的！<br><strong>无权图的最短路径</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs4</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(start);</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    visited[temp] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">      <span class="keyword">if</span> (!visited[i] &amp;&amp; Graph4[temp][i]) &#123;</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        q.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>做题最好用dfs， 基于递归不用容器（自带的栈）存储太多东西！</p>
<p>栈（DFS），队列（BFS）， 随机容器（迷宫生成！）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vvint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">int</span> rs_len = <span class="number">2000</span>;</span><br><span class="line"><span class="function">vint <span class="title">cap</span><span class="params">(rs_len)</span></span>; <span class="comment">//容器</span></span><br><span class="line"><span class="keyword">int</span> cap_len = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//自己造一个随机容器！</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cap_empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cap_len == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cap_put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; cap[cap_len++] = value; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cap_get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cap_empty()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error: out of index!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  srand(time(<span class="literal">NULL</span>));  <span class="comment">// 随机获取一个数</span></span><br><span class="line">  <span class="keyword">int</span> index = rand() % cap_len;</span><br><span class="line">  <span class="comment">// cout &lt;&lt; &quot;random&quot; &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; cap_len &lt;&lt; endl;</span></span><br><span class="line">  <span class="keyword">int</span> ret = cap[index];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; cap_len - <span class="number">1</span>; i++) cap[i] = cap[i + <span class="number">1</span>];</span><br><span class="line">  cap_len--;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_map</span><span class="params">(vvint <span class="built_in">map</span>)</span></span>;</span><br><span class="line"><span class="comment">// @param 迷宫的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rs4</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  rs_len = len;</span><br><span class="line">  <span class="function">vvint <span class="title">map</span><span class="params">(rs_len * rs_len, vint(rs_len * rs_len))</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rs_len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rs_len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="built_in">map</span>[j + i * rs_len][j + i * rs_len + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">map</span>[j + i * rs_len + <span class="number">1</span>][j + i * rs_len] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">map</span>[j * rs_len + i][(j * rs_len + i) + rs_len] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">map</span>[j * rs_len + i + rs_len][j * rs_len + i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从 0 开始  随机搜索， 迷宫入口</span></span><br><span class="line">  cap_put(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">bool</span> visited[rs_len * rs_len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  visited[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!cap_empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = cap_get();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rs_len * rs_len; i++)</span><br><span class="line">      <span class="keyword">if</span> (!visited[i] &amp;&amp; <span class="built_in">map</span>[temp][i] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; temp &lt;&lt; &quot;  &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">map</span>[temp][i] = <span class="built_in">map</span>[i][temp] = <span class="number">2</span>;</span><br><span class="line">        cap_put(i);</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// traverse4(map);</span></span><br><span class="line">  gen_map(<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把遍历的经过转换成地图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_map</span><span class="params">(vvint <span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">  <span class="function">vvint <span class="title">temp</span><span class="params">(rs_len * <span class="number">2</span>, vint(rs_len * <span class="number">2</span>))</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rs_len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rs_len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">map</span>[j + i * rs_len][j + i * rs_len + <span class="number">1</span>] == <span class="number">2</span>) &#123;  <span class="comment">// 每一行</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; * &quot; &lt;&lt; j;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot; &quot; &lt;&lt; j + i * rs_len &lt;&lt; &quot; &quot; &lt;&lt; j + i * rs_len + 1 &lt;&lt; endl;</span></span><br><span class="line">        temp[i * <span class="number">2</span>][j * <span class="number">2</span>] = temp[i * <span class="number">2</span>][(j + <span class="number">1</span>) * <span class="number">2</span>] = temp[i * <span class="number">2</span>][j * <span class="number">2</span> + <span class="number">1</span>] =</span><br><span class="line">            <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">map</span>[j * rs_len + i][(j * rs_len + i) + rs_len] == <span class="number">2</span>) &#123;  <span class="comment">// 每一列</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; j &lt;&lt; &quot; / &quot; &lt;&lt; i;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot; &quot; &lt;&lt; j * rs_len + i &lt;&lt; &quot; &quot; &lt;&lt; j * rs_len + i + rs_len &lt;&lt; endl;</span></span><br><span class="line">        temp[j * <span class="number">2</span>][i * <span class="number">2</span>] = temp[(j + <span class="number">1</span>) * <span class="number">2</span>][i * <span class="number">2</span>] = temp[j * <span class="number">2</span> + <span class="number">1</span>][i * <span class="number">2</span>] =</span><br><span class="line">            <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rs_len * <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rs_len * <span class="number">2</span> - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> out = (temp[i][j] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; out &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>求联通分量（图分成了多少块！？）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">component</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) ans ++;      <span class="comment">// 只要有没有访问到的， 就计数加上一</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;				<span class="comment">// 其它 更遍历是一样的</span></span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">      <span class="keyword">int</span> temp = q.front();</span><br><span class="line">      q.pop();</span><br><span class="line">      visited[temp] = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//cout &lt;&lt; temp &lt;&lt; &quot; -&gt; &quot;;</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (!visited[i] &amp;&amp; Graph4[temp][i]) &#123;</span><br><span class="line">          visited[i] = <span class="number">1</span>;</span><br><span class="line">          q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unicom component is : &quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>路径问题（从一个点到另一个点是否通？）回溯（dfs）， 广搜</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_connected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(a);</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    visited[temp] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">      <span class="keyword">if</span> (Graph4[temp][i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == b)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">          visited[i] = <span class="number">1</span>;</span><br><span class="line">          q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>检测环</p>
</li>
<li><p>二分图检测</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200219211503.png"></p>
<p>定点V可以分为两部分， 所有边的两个顶点分别属于这两部分！ </p>
<h4 id="floodfill算法"><a href="#floodfill算法" class="headerlink" title="floodfill算法"></a>floodfill算法</h4><p>把图联通的某一部分填满！</p>
<p>算法思路：</p>
<p>​    直接遍历！</p>
<p>例题： 游戏开发 -&gt; 扫雷，   最大人工岛屿</p>
<h3 id="桥和隔点"><a href="#桥和隔点" class="headerlink" title="桥和隔点"></a>桥和隔点</h3><blockquote>
<p>桥： 删除了某一条边，联通分量发生改变！</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200219215253.png"></p>
<p>寻找所有桥！只有DFS可以求！(dfs遍历树)</p>
<p>对于每一条边 v - w ， 通过w， 能否通过另一条路回到v</p>
<blockquote>
<p>隔点： 删除隔点， 图的联通分量产生变化！</p>
</blockquote>
<p>类似寻找桥的算法！</p>
<h3 id="欧拉回路和欧拉路径"><a href="#欧拉回路和欧拉路径" class="headerlink" title="欧拉回路和欧拉路径"></a>欧拉回路和欧拉路径</h3><p>哈密尔顿回路</p>
<p>从一个点出发， 经过<strong>每个点一次</strong>，回到原点</p>
<p>欧拉回路</p>
<p>从一条点出发， 经过<strong>每一条边一次</strong>， 回到原点</p>
<p>// 离散数学知识， 不会考</p>
<h5 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h5><p> 无权图可以直接使用<strong>位</strong>来存储图</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>Kruskal 需要用到并查集判断有无环， 因此先列一下！ </p>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><blockquote>
<p>并查集是一种树型的数据结构，用于处理一些不相交<a class="link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117" >集合<i class="fas fa-external-link-alt"></i></a>（Disjoint Sets）的<strong>合==并==**及</strong>==查==询**问题。</p>
</blockquote>
<p><strong>example:</strong></p>
<p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">测试输入包含若干测试用例。每个测试用例的第<span class="number">1</span>行给出两个正整数，分别是城镇数目N ( &lt; <span class="number">1000</span> )和道路数目M；</span><br><span class="line">随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。</span><br><span class="line">为简单起见，城镇从<span class="number">1</span>到N编号。</span><br><span class="line">注意:两个城市之间可以有多条道路相通,也就是说</span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line">这种输入也是合法的</span><br><span class="line">当N为<span class="number">0</span>时，输入结束，该用例不被处理。</span><br></pre></td></tr></table></figure>

<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/niushuai666/article/details/6662911" >https://blog.csdn.net/niushuai666/article/details/6662911<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1010</span>];  <span class="comment">//里面全是掌门</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unionsearch</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> son, tmp;</span><br><span class="line">  son = root;</span><br><span class="line">  <span class="keyword">while</span> (root != pre[root])  <span class="comment">//寻找掌门ing……</span></span><br><span class="line">    root = pre[root];</span><br><span class="line">  <span class="keyword">while</span> (son != root) &#123;  <span class="comment">//路径压缩</span></span><br><span class="line">    tmp = pre[son];</span><br><span class="line">    pre[son] = root;</span><br><span class="line">    son = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;  <span class="comment">//掌门驾到~</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num, road, total, i, start, end, root1, root2;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;num, &amp;road) , num) &#123;</span><br><span class="line">    total = num - <span class="number">1</span>;            <span class="comment">//共num-1个门派</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; ++i)  <span class="comment">//每条路都是掌门</span></span><br><span class="line">      pre[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (road--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;start, &amp;end);  <span class="comment">//他俩要结拜</span></span><br><span class="line">      root1 = unionsearch(start);</span><br><span class="line">      root2 = unionsearch(end);</span><br><span class="line">      <span class="keyword">if</span> (root1 != root2) &#123;  <span class="comment">//掌门不同？踢馆！~</span></span><br><span class="line">        pre[root1] = root2;</span><br><span class="line">        total--;  <span class="comment">//门派少一个，敌人（要建的路）就少一个</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, total);  <span class="comment">//天下局势：还剩几个门派</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><p>首先排序， 从最小的<strong>边</strong>开始选取， 只要不构成环加入！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isCircle</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> pre[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp, son = root;</span><br><span class="line">  <span class="keyword">while</span> (pre[root] != root) root = pre[root];</span><br><span class="line">  <span class="keyword">while</span> (son != root) &#123;</span><br><span class="line">    tmp = pre[son];</span><br><span class="line">    pre[son] = root;</span><br><span class="line">    son = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;Edge *&gt; <span class="title">edge</span><span class="params">(edges)</span></span>;</span><br><span class="line">  sort(edge.begin(), edge.end(),</span><br><span class="line">       [](Edge *a, Edge *b) &#123; <span class="keyword">return</span> a-&gt;value &lt; b-&gt;value; &#125;);</span><br><span class="line">  <span class="keyword">int</span> pre[len] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//用作并查集的父节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) pre[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = isCircle(edge[i]-&gt;start, pre);</span><br><span class="line">    <span class="keyword">int</span> b = isCircle(edge[i]-&gt;end, pre);</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;  <span class="comment">// 不是环</span></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; edge[i]-&gt;start &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[i]-&gt;end &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      pre[b] = a;  <span class="comment">// 合并</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h4><p>选择离  已扩充节点集合 距离最小的<strong>点</strong>作为扩充点！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dis[len] = &#123;INF&#125;;  <span class="comment">// 关键 ！！！！！</span></span><br><span class="line">  <span class="keyword">int</span> p[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) dis[i] = INF;</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> index, min = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited[j] &amp;&amp; (min == <span class="number">-1</span> || dis[j] &lt; min)) &#123;</span><br><span class="line">        min = dis[j];</span><br><span class="line">        index = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[index] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p[index] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (Graph4[p[index]][index] != <span class="number">0</span>) addNode(root1, p[index], index);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Graph4[index][j] != <span class="number">0</span> &amp;&amp; dis[j] &gt; Graph4[index][j]) &#123;</span><br><span class="line">        dis[j] = Graph4[index][j];</span><br><span class="line">        p[j] = index;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;the tree is : \n&quot;</span>;</span><br><span class="line">  printTree();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="dijkstra和单源最短路径"><a href="#dijkstra和单源最短路径" class="headerlink" title="dijkstra和单源最短路径"></a>dijkstra和单源最短路径</h4><p>无负数, 一直选取当前未访问的最近的节点作为扩展！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> dis[len];</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">  dis[start] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) </span><br><span class="line">        <span class="comment">//选取当前未访问的最近的点作为扩展</span></span><br><span class="line">      <span class="keyword">if</span> (!visited[j] &amp;&amp; (index == <span class="number">-1</span> || dis[index] &gt; dis[j])) </span><br><span class="line">        index = j;</span><br><span class="line">    visited[index] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) </span><br><span class="line">      <span class="keyword">if</span> (Graph4[index][j] != <span class="number">0</span> &amp;&amp; dis[index] + Graph4[index][j] &lt; dis[j]) </span><br><span class="line">        dis[j] = dis[index] + Graph4[index][j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dijkstra: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; INF &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; start &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; len: &quot;</span> &lt;&lt; ((dis[i] == INF)? <span class="number">-1</span> : dis[i]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><p>迭代n次， 每次按边来缩短dis， 如果某一次迭代没有变化，停止迭代！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ford</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dis[len];</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">  dis[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  <span class="comment">// 循环  len 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.size(); j++) &#123; <span class="comment">// 对于每一条边</span></span><br><span class="line">      <span class="keyword">if</span> (dis[edges[j]-&gt;start] + edges[j]-&gt;value &lt; dis[edges[j]-&gt;end]) &#123;</span><br><span class="line">        dis[edges[j]-&gt;end] = dis[edges[j]-&gt;start] + edges[j]-&gt;value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ford:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; start &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; len: &quot;</span> &lt;&lt; ((dis[i] == INF) ? <span class="number">-1</span> : dis[i])</span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Floyed-Warshall"><a href="#Floyed-Warshall" class="headerlink" title="Floyed-Warshall"></a>Floyed-Warshall</h4><p>所有点对最短路径， 动态规划， 子的状态直接用在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dis[len][len];</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len * len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++)</span><br><span class="line">    dis[edges[i]-&gt;start][edges[i]-&gt;end] = dis[edges[i]-&gt;end][edges[i]-&gt;start] =</span><br><span class="line">        edges[i]-&gt;value;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != j &amp;&amp; i != k &amp;&amp; j != k) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;floyed:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dis[i][j] != INF)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; dis[i][j] &lt;&lt; <span class="string">&quot;;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><strong>一.定义</strong></p>
<p>对一个有向无环图(Directed Acyclic Graph, DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若&lt;u，v&gt; ∈E(G)，则u在线性序列中出现在v之前。</p>
<p>通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。</p>
<p>注意:</p>
<p>1)只有<strong>有向无环图</strong>才存在拓扑序列;</p>
<p>2)对于一个DAG,可能存在多个拓扑序列;</p>
<p><strong>二.拓扑序列算法思想</strong></p>
<p>(1)从有向图中选取一个没有前驱(即入度为0)的顶点，并输出之;</p>
<p>(2)从有向图中删去此顶点以及所有以它为尾的弧;</p>
<p>重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DAG</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printG2();</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    <span class="keyword">if</span> (in_cnt[i] == <span class="number">0</span> &amp;&amp; Graph2[i].size() != <span class="number">0</span>) q.push(i);</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;start topology:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Graph2[a].size(); i++)</span><br><span class="line">      <span class="keyword">if</span> (!--in_cnt[Graph2[a][i]-&gt;to]) q.push(Graph2[a][i]-&gt;to);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>以下用的比较少， 不做总结！</p>
<h3 id="网络流和最大流"><a href="#网络流和最大流" class="headerlink" title="网络流和最大流"></a>网络流和最大流</h3><h4 id="Ford-Fulkerson"><a href="#Ford-Fulkerson" class="headerlink" title="Ford-Fulkerson"></a>Ford-Fulkerson</h4><h4 id="Edmonds-Karp"><a href="#Edmonds-Karp" class="headerlink" title="Edmonds-Karp"></a>Edmonds-Karp</h4><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><p>BFS</p>
<p>DFS</p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2020/04/06/notepad/algorithm/exercise/tree/"
                        >
                            <span class="left arrow-icon flex-center" >
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">大数运算</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2020/03/14/notepad/algorithm/exercise/unionfind/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">并查集</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center" >
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                    
                </main>

            </div>

            <div class="page-main-content-bottom">
                <!--
 * @Author: Firefly
 * @Date: 2020-12-06 11:25:04
 * @Descripttion: 
 * @LastEditTime: 2020-12-06 17:25:59
-->
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2017</span> -
            
            2020 <i class="fas fa-heart icon-animate"></i> <a href="/">Firefly</a>
        </div>
        
    </div>
</footer>

            </div>
        </div>
    </main>

    <div class="sidebar-tools">
        <div class="tools-container">
    <ul class="tools-list">
        
            <li class="search popup-trigger">
                <i class="fas fa-search"></i>
            </li>
        

        

        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

    </ul>
</div>

    </div>

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">

    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center">
            <i class="fas fa-arrow-up"></i>
        </li>

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="tools-ul-1">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

    </ul>
</div>

    </div>

    <!-- page aside -->
    <aside class="page-aside">
        
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">图论总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.0.1.</span> <span class="nav-text">图是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.0.2.</span> <span class="nav-text">图的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.0.3.</span> <span class="nav-text">图的表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.0.4.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DFS"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BFS"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">BFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">1.0.4.4.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#floodfill%E7%AE%97%E6%B3%95"><span class="nav-number">1.0.4.5.</span> <span class="nav-text">floodfill算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%A5%E5%92%8C%E9%9A%94%E7%82%B9"><span class="nav-number">1.0.5.</span> <span class="nav-text">桥和隔点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E5%92%8C%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84"><span class="nav-number">1.0.6.</span> <span class="nav-text">欧拉回路和欧拉路径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9"><span class="nav-number">1.0.6.0.1.</span> <span class="nav-text">状态压缩</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">1.0.7.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">1.0.7.1.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal"><span class="nav-number">1.0.7.2.</span> <span class="nav-text">Kruskal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prim"><span class="nav-number">1.0.7.3.</span> <span class="nav-text">prim</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">1.0.8.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dijkstra%E5%92%8C%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">1.0.8.1.</span> <span class="nav-text">dijkstra和单源最短路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bellman-Ford"><span class="nav-number">1.0.8.2.</span> <span class="nav-text">Bellman-Ford</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyed-Warshall"><span class="nav-number">1.0.8.3.</span> <span class="nav-text">Floyed-Warshall</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.9.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E5%92%8C%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="nav-number">1.0.10.</span> <span class="nav-text">网络流和最大流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Ford-Fulkerson"><span class="nav-number">1.0.10.1.</span> <span class="nav-text">Ford-Fulkerson</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Edmonds-Karp"><span class="nav-number">1.0.10.2.</span> <span class="nav-text">Edmonds-Karp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="nav-number">1.0.10.3.</span> <span class="nav-text">匈牙利算法</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>
        
    </aside>

    <!-- image viewer -->
    <div class="image-viewer-container">
    <div class="img-box">
        <img src="">
    </div>
</div>


</div>



    <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-icon">
            <i class="fas fa-search"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/local-search.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/left-side-toggle.js"></script>

    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/code-copy.js"></script>
    

    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/toc.js"></script>
    


</body>
</html>