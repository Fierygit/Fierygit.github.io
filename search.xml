<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/09/10/notepad/README/</url>
    <content><![CDATA[<h1 id="notepad"><a href="#notepad" class="headerlink" title="notepad"></a>notepad</h1><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><ul>
<li>sql必知必回</li>
</ul>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><ul>
<li><p>netty</p>
</li>
<li><p>tomcat</p>
</li>
</ul>
<h2 id="数据密集型应用"><a href="#数据密集型应用" class="headerlink" title="数据密集型应用"></a>数据密集型应用</h2><h2 id="毕设"><a href="#毕设" class="headerlink" title="毕设"></a>毕设</h2>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/09/10/notepad/algorithm/README/</url>
    <content><![CDATA[<p>more is in <a class="link"   href="http://fireflying.top/" >firefly’s blog<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/09/10/notepad/cxx/README/</url>
    <content><![CDATA[<h3 id="firefly-的c-学习笔记"><a href="#firefly-的c-学习笔记" class="headerlink" title="firefly 的c++ 学习笔记"></a>firefly 的c++ 学习笔记</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/09/10/notepad/java/README/</url>
    <content><![CDATA[<h3 id="firefly-的-java-学习笔记"><a href="#firefly-的-java-学习笔记" class="headerlink" title="firefly 的 java 学习笔记"></a>firefly 的 java 学习笔记</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/03/notepad/read/reamde/</url>
    <content><![CDATA[<h2 id="这是firefly-的读书笔记"><a href="#这是firefly-的读书笔记" class="headerlink" title="这是firefly 的读书笔记"></a>这是firefly 的读书笔记</h2>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/30/notepad/read/DDIA.mm/</url>
    <content><![CDATA[<h1 id="数据密集型应用学习笔记"><a href="#数据密集型应用学习笔记" class="headerlink" title="数据密集型应用学习笔记"></a>数据密集型应用学习笔记</h1><h2 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h2><blockquote>
<p> 当今许多应用大多是数据数据密集（data-intensive）而不是计算密集型（compute-intensive）的。所以CPU的处理能力往往不是应用程序的瓶颈。关键在于数据的量、数据的复杂度以及数据的快速多变性。</p>
</blockquote>
<ul>
<li>应用往往包含以下模块：</li>
</ul>
<ol>
<li>数据库：用于存储数据</li>
<li>高速缓存：缓存复杂或者操作代价昂贵的结果，加快下一次访问</li>
<li>索引：用户可以按照关键字搜索数据并支持各种过滤</li>
<li>流式处理：持续发送消息到另一个进程，处理采用异步方式</li>
<li>批处理：定期处理大量积累的数据</li>
</ol>
<h3 id="认识数据系统"><a href="#认识数据系统" class="headerlink" title="认识数据系统"></a>认识数据系统</h3><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20201205234835.png" alt="一个数据架构系统，包含了不同的组件"></p>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><blockquote>
<p>出现意外情况，比如硬件、软件故障、人为失误等，系统可以继续正常运转，至少确保功能正确。</p>
</blockquote>
<h4 id="硬件故障"><a href="#硬件故障" class="headerlink" title="硬件故障"></a>硬件故障</h4><blockquote>
<p>比较容易出现的，硬盘崩溃，内存故障，电网停电。</p>
<p>第一反应是为硬件冗余来减少系统故障率。例如磁盘RAID，服务器双电源，甚至热插拔CPU，数据中心添加备用电源、发电机。</p>
<p>这样当一个组件发生故障时，冗余组件可以快速接管，之后运维人员可以修复或者更换坏掉的组件。</p>
<p>直到最近，采用硬件冗余方案对于大多数应用场景还是足够的，它让单机完全失效的概率降到最低。只要可以把备份迅速恢复到新的机器上，故障的停机时间在大多数应用中并不是灾难性的。</p>
<p>现在，通过软件容错的方式来容易多机失效成为新的手段，或者成为硬件容错方案的有力补充。例如滚动升级。</p>
</blockquote>
<h4 id="软件错误"><a href="#软件错误" class="headerlink" title="软件错误"></a>软件错误</h4><blockquote>
<p>这类故障更难预料。各个节点直接是由软件关联的，可能会导致更多的系统故障。</p>
</blockquote>
<ul>
<li>例如，</li>
</ul>
<ol>
<li>由于软件错误，导致特定的输入引发应用的崩溃。例如Linux内核bug，在2012年6月30的闰秒时候触发，导致很多应用程序被挂掉。</li>
<li>失控的进程把系统的资源耗尽，导致这些共享资源不能被释放。</li>
<li>系统的Dependency出了问题，返回值异常。</li>
<li>组件中的小故障触发另一个组件中的故障，进而触发更多的故障。</li>
</ol>
<ul>
<li>没有快速的解决方法。只能仔细考虑很多细节。</li>
</ul>
<ol>
<li>检查系统的假设条件和系统之间的交互</li>
<li>进行全面的测试</li>
<li>进程隔离，</li>
<li>允许进程崩溃后自动重启</li>
<li>反复评估、监控并分析生产环境中的行为表现。</li>
</ol>
<p>例如消息队列中，输出消息的数量应等于输入消息的数量。如果发现不一致，则立即告警。</p>
<h4 id="人为失误"><a href="#人为失误" class="headerlink" title="人为失误"></a>人为失误</h4><blockquote>
<p>人无法做到万无一失。运维人员的配置错误可能是系统下线的第一大原因。</p>
<p>要保证系统可靠，如何减少人为错误对它的影响？</p>
</blockquote>
<ol>
<li>用最小出错的方式来设计系统。让做错事更难。</li>
<li>想办法分离最容易出错的地方，容易引发故障的接口。使用Sandbox隔离真正的生产和测试环境。</li>
<li>充分的测试。单元测试，集成测试，手动测试。边界条件的考虑。</li>
<li>当出现人为失误时，有快速回滚或者回复的机制。滚动发布新代码。</li>
<li>监控子系统需要详细和清晰。</li>
<li>推行管理流程和相关培训。</li>
</ol>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><blockquote>
<p>随着规模的增长，例如数据量、流量和复杂性，系统应该可以用合理的方式进行应对，满足这种增长。</p>
<p>当应用负载增加的时候，比如用户从1w到100w，从100w到1000w，应用程序如何应对增长的负载。</p>
<p>相关参数：Web服务的QPS，数据库的写入比例，DAU，缓存命中率。有时候平均值很重要，有时候短时间内的峰值会成为系统瓶颈。</p>
<p>Twitter的Fan-out结构，对数据量提出了挑战。当一个人发Tweet时候，怎么处理Timeline这个请求。根据粉丝的数量，区别处理。</p>
</blockquote>
<h4 id="描述性能"><a href="#描述性能" class="headerlink" title="描述性能"></a>描述性能</h4><ul>
<li>系统负载增加后，会发生什么，两种思考方式</li>
</ul>
<ol>
<li>系统资源不变（CPU，内存，带宽），系统的性能会发生什么变化？</li>
<li>如果要保持性能不变，需要增加多少资源？</li>
</ol>
<ul>
<li>不同类型的系统关心的性能指标不同</li>
</ul>
<ol>
<li>批处理系统通常关心<strong>吞吐量（throughput）</strong>，例如Hadoop，每秒可以处理多少条数据或者完成一个作业总共需要多少时间。</li>
<li>Online系统中，更看重服务的<strong>响应时间（response time）</strong>，即客户端从发出请求到得到回复的总时间。</li>
</ol>
<p><a href="https://guoyongxin.github.io/2019/04/20/DDIA-1-%E5%8F%AF%E9%9D%A0%E5%8F%AF%E6%89%A9%E5%B1%95%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4.png"><img src="https://guoyongxin.github.io/2019/04/20/DDIA-1-%E5%8F%AF%E9%9D%A0%E5%8F%AF%E6%89%A9%E5%B1%95%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4.png" alt="展示了一个服务100次请求响应时间的均值与百分位数、中位数">展示了一个服务100次请求响应时间的均值与百分位数、中位数</a></p>
<ul>
<li><p>对于响应时间，如下图，有一些很长的，算异常请求，可能是由于数据大很多。但也有可能是其他因素造成的，例如上下文切换、进程调度、网络丢包、TCP重传、垃圾回收STW，缺页中断、磁盘IO。</p>
</li>
<li><p>最好使用百分位数，中位数（50%）来评估系统的响应时间。</p>
</li>
<li><p>采用较高的响应时间百分位数很重要，因为直接影响用户的总体服务体验。例如亚马逊采用99.9百分位来定义服务响应时间。优化99.9%的目标可能成本很高。能不能带来收益很关键。</p>
</li>
<li><p>排队延迟（queueing delay）通常占了高百分位点处响应时间的很大一部分。由于服务器只能并行处理少量的事务（如受其CPU核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为头部阻塞（head-of-line blocking）</p>
</li>
</ul>
<h4 id="应对负载增加"><a href="#应对负载增加" class="headerlink" title="应对负载增加"></a>应对负载增加</h4><ul>
<li><p>垂直扩展和水平扩展。</p>
</li>
<li><p>好的系统有弹性特征，可以自动检测负载的变化，来自动添加更多的计算资源。</p>
</li>
<li><p>可扩展架构通常都是从通用模块逐步构建出来的。</p>
</li>
</ul>
<h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><blockquote>
<p>项目会随着时间的推移，项目会需要新的人员参与到开发和运维工作中，来满足系统的稳定和新场景的适应。系统应该高效的变化。</p>
<p>软件的大部分开销并不在最初的开发阶段，而是在持续的维护阶段，包括修复漏洞、保持系统正常运行、调查失效、适配新的平台、为新的场景进行修改、偿还技术债、添加新的功能等等。</p>
<p>为此，我们将特别关注软件系统的三个设计原则：</p>
</blockquote>
<h4 id="可操作性（Operability）"><a href="#可操作性（Operability）" class="headerlink" title="可操作性（Operability）"></a>可操作性（Operability）</h4><blockquote>
<p> 便于运维团队保持系统平稳运行。</p>
<p>良好的可操作性意味着更轻松的日常工作，进而运维团队能专注于高价值的事情。</p>
<p>数据系统可以通过各种方式使日常任务更轻松</p>
</blockquote>
<h4 id="简单性（Simplicity）"><a href="#简单性（Simplicity）" class="headerlink" title="简单性（Simplicity）"></a>简单性（Simplicity）</h4><ul>
<li>从系统中消除尽可能多的复杂度（complexity），使新工程师也能轻松理解系统。（注意这和用户接口的简单性不一样。）<br><strong>复杂度（complexity）</strong>有各种可能的症状，例如：状态空间激增、模块间紧密耦合、纠结的依赖关系、不一致的命名和术语、解决性能问题的Hack、需要绕开的特例等等，</li>
</ul>
<h4 id="可演化性（evolability）"><a href="#可演化性（evolability）" class="headerlink" title="可演化性（evolability）"></a>可演化性（evolability）</h4><ul>
<li><p> 使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为可扩展性（extensibility），可修改性（modifiability）或可塑性（plasticity）。</p>
</li>
<li><p>组织流程方面，敏捷开发，TDD，重构。</p>
</li>
<li><p>修改数据系统并使其适应不断变化需求的容易程度，是与简单性和抽象性密切相关的：简单易懂的系统通常比复杂系统更容易修改</p>
</li>
</ul>
<h2 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h2><h3 id="数据库核心：-数据结构"><a href="#数据库核心：-数据结构" class="headerlink" title="数据库核心： 数据结构"></a>数据库核心： 数据结构</h3><blockquote>
<p>一个最简单的数据库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">db_set</span></span> () &#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>,<span class="variable">$2</span>&quot;</span> &gt;&gt; database</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">db_get</span></span> () &#123;</span><br><span class="line">	grep <span class="string">&quot;^<span class="variable">$1</span>,&quot;</span> database | sed -e <span class="string">&quot;s/^<span class="variable">$1</span>,//&quot;</span> | tail -n 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>db_set</p>
<ul>
<li>追加到文件尾部方式通常足够高效， 因而db_set函数性能很好。</li>
<li>与db_set相似， 许多数据库内部都使用日志(log) , 日志是一个仅支持追加式更新的数据文件</li>
</ul>
</li>
<li><p>db_get</p>
<ul>
<li>db_get函数的性能会非常差。</li>
<li>每次想查找一个键， db_get必须从头到尾扫描整个数据库文件来查找键的出现位置, 查找的开销是O(n)。</li>
</ul>
</li>
</ul>
<p>如何解决查找缓慢？ </p>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><blockquote>
<p>可以提供高性能的读和写， 只要所有的key可以放入内存（因为hash map需要保存在内存中）</p>
</blockquote>
<ul>
<li>引入新的问题<ul>
<li>哈希表必须全部放入内存， 如果有大量的键， 就没那么幸运了。</li>
<li>很难使磁盘上的hash map表现良好，需要大量的随机访问I/0。</li>
<li>当哈希变满时，增长代价昂贵，并且哈希冲突时需要复杂的处理逻辑。</li>
<li>区间查询效率不高。不能简单地扫描a和z区间内的所有键，只能采用逐个查找的方式查询每一个键。</li>
</ul>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>使用限制，用作存储点击量，访问量</li>
</ul>
<h4 id="SSTable和-LSM-Tree"><a href="#SSTable和-LSM-Tree" class="headerlink" title="SSTable和 LSM-Tree"></a>SSTable和 LSM-Tree</h4><blockquote>
<p><strong>键值对的序列按键排序</strong>。这就是<strong>SSTables（Sorted String Tables）</strong>的数据格式。我们还要求同一个key只会出现在一个段中。</p>
</blockquote>
<h5 id="SSTables优点："><a href="#SSTables优点：" class="headerlink" title="SSTables优点："></a>SSTables优点：</h5><ol>
<li>合并段更简单。就像merge sort一样。</li>
<li>查找数据使用二分查找</li>
<li>压缩时，可以利用稀疏索引，降低了IO带宽。</li>
</ol>
<h5 id="构建和维护SSTables"><a href="#构建和维护SSTables" class="headerlink" title="构建和维护SSTables"></a>构建和维护SSTables</h5><p>要解决排序问题。方法是，</p>
<ol>
<li>在内存中保存一个排序结构，比如红黑树，AVL树。</li>
<li>在插入修改时候可以很快的响应。</li>
<li>可以顺序的读区它们。</li>
</ol>
<h5 id="存储引擎工作流程"><a href="#存储引擎工作流程" class="headerlink" title="存储引擎工作流程"></a>存储引擎工作流程</h5><ol>
<li>写入时，将数据加入内存表中，可以是红黑树实现。</li>
<li>当内存中的红黑树大小超过阀值时，把它用SSTable的格式写入磁盘。</li>
<li>处理读请求时，先尝试查询内存表，如果miss就查询磁盘段文件s。</li>
<li>周期性的执行合并和压缩。丢弃被覆盖和删除的值。</li>
</ol>
<h5 id="实现LSM-Tree（Log-structured-Merge-Tree）"><a href="#实现LSM-Tree（Log-structured-Merge-Tree）" class="headerlink" title="实现LSM-Tree（Log-structured Merge-Tree）"></a>实现LSM-Tree（Log-structured Merge-Tree）</h5><ul>
<li><p>LevelDB，RocksDB，HBase， 都源于Google的BigTable论文。最初这个索引结构在早起的系统中被命名LSM-Tree。因此，基于合并和压缩的排序文件原理的存储引擎，通常都被称作LSM存储引擎。</p>
</li>
<li><p>全文搜索，Lucene是ElasticSearch和Solr的索引引擎。采用了类似的方法保存字典。全文索引复杂的多，但想法类似。</p>
</li>
</ul>
<h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><ol>
<li>查询不存在的key时，会从内存开始扫描到磁盘的最后一个段。解决方法是，Bloom Filter。</li>
<li>压缩合并的时机。分为大小分级和分层压缩两个方法。一个是小的SSTables被连续合并到大的旧的SSTables。另一个是key的范围分裂成多个更小的SSTables，旧数据被移动到单独的层级。</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul>
<li>由于数据是按照排序存储，因此可以高效的执行区间查询。</li>
<li>因为磁盘是顺序写入的，LSM-Tree的写入吞吐量可以非常高。</li>
</ul>
<h4 id="B-trees索引"><a href="#B-trees索引" class="headerlink" title="B-trees索引"></a>B-trees索引</h4><blockquote>
<p>应用最广泛的索引结构。和SSTable一样，B-tree保留按key排，也可以实现高效的范围查询。</p>
<p>B-tree将数据库分解成固定大小的块和页（4KB or more）。这种设计更接近底层硬件，因为磁盘也是固定大小的块的排列。</p>
<p>每个页可以用地址标志，是磁盘地址，而不是内存。这样可以用这些页面引用构造一个树状页面进行索引。索引的根是一个页面，之后的查找根据地址，读取相应的页。</p>
<p>分支因子：大多数数据库的索引适合3-4层的B-tree.因此不需要遍历非常深的页面层次即可找到所需的页。</p>
<ul>
<li> B树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</li>
<li>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</li>
</ul>
</blockquote>
<h5 id="使B-tree可靠"><a href="#使B-tree可靠" class="headerlink" title="使B-tree可靠"></a>使B-tree可靠</h5><ul>
<li><p>B-tree底层的基本操作是使用新数据覆盖磁盘的旧页。磁盘是覆盖扇区，对于SSD，擦除和重写的存储芯片块很大，情况更复杂。</p>
</li>
<li><p>页面溢出，需要分裂页时，也要覆盖其父页对更新后的两个子页的引用。属于复杂操作。在完成更新前发生崩溃，可能会产生孤儿页面。</p>
</li>
<li><p>崩溃恢复，使用redo Log。写数据之前先写日志。</p>
</li>
<li><p>并发控制。</p>
</li>
</ul>
<h5 id="优化B-tree"><a href="#优化B-tree" class="headerlink" title="优化B-tree"></a>优化B-tree</h5><ol>
<li>一些数据库不是用覆盖页，而是做复制。</li>
<li>保存key的缩略信息而不是完整的key，来节省空间。只需要提供足够的信息来描述key的起止范围。</li>
<li>页可以存在磁盘的任何位置。可能回有随机的IO，而不是连续的。有些B-tree尝试实现对B-tree进行布局，但是随着树的增长，这个顺序会越来越难维护。</li>
<li>添加额外指针。左到右的指针，加速遍历。</li>
</ol>
<h4 id="对比B-tree-LSM-tree"><a href="#对比B-tree-LSM-tree" class="headerlink" title="对比B-tree, LSM-tree"></a>对比B-tree, LSM-tree</h4><blockquote>
<p>根据经验，LSM-Tree写入更快，而B-tree读更快。读取通常在LSM—Tree中较慢，因为要检查多个不同的数据结构和SSTables。</p>
</blockquote>
<h5 id="LSM-Tree优点"><a href="#LSM-Tree优点" class="headerlink" title="LSM-Tree优点"></a>LSM-Tree优点</h5><ol>
<li>LSM只写入一次数据（不考虑写放大（写入引起的压缩和合并）），而B-tree写入两次（一次redo log，一次数据本身）。</li>
<li>LSM可以成熟比B-tree更大的吞吐量。有时具有较低的写放大，顺序写入速度快。</li>
<li>可以支持更好的压缩，文件比B-tree小很多。没有B-tree产生碎片的问题。</li>
</ol>
<h5 id="LSM-Tree缺点"><a href="#LSM-Tree缺点" class="headerlink" title="LSM-Tree缺点"></a>LSM-Tree缺点</h5><ol>
<li>响应延迟不确定，因为压缩和合并。</li>
<li>由于配置问题，会出现压缩跟不上写入速度的问题。来不及合并，直到磁盘空间不足。</li>
<li>事务支持不如B-tree</li>
</ol>
<h4 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h4><h5 id="在索引中存储值"><a href="#在索引中存储值" class="headerlink" title="在索引中存储值"></a>在索引中存储值</h5><blockquote>
<p>索引中存储行或则行的具体位置（堆文件法）。将索引行直接存在索引中，聚集索引。MySQL的InnoDB存储引擎中，表的主键是聚集索引，二级索引引用主键。</p>
</blockquote>
<h5 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h5><ul>
<li><p>级联索引，通过将一列追加到另一列，将几个字段组合成一个键。只能从前到后匹配。B-tree和LSM-tree都无法高效的应对这种查询。</p>
</li>
<li><p>更常见的索引空间，R树。PostGIS使用PostgreSQL的广义搜索书索引实现了地理空间索引作为R树。</p>
</li>
</ul>
<h5 id="全文搜索和模糊索引"><a href="#全文搜索和模糊索引" class="headerlink" title="全文搜索和模糊索引"></a>全文搜索和模糊索引</h5><blockquote>
<p>之前的搜索都是准确匹配，而不能应对类似的key的搜索，例如错误的拼写。</p>
<p>Lucene引擎支持在某个编辑距离内的模糊搜索。LevelDB中这个内存中的索引是一些key的稀疏集合。但在Lucene中，内存中的索引是key中的字符串序列的有限状态机，类似字典树。这个自动机可以转换成Leveshtein自动机，支持编辑距离内的搜索。</p>
</blockquote>
<h5 id="在内存中保存所有内容"><a href="#在内存中保存所有内容" class="headerlink" title="在内存中保存所有内容"></a>在内存中保存所有内容</h5><ul>
<li><p>内存数据库。例如Memcached，做缓存。数据在重启后可以恢复。</p>
</li>
<li><p>内存数据可以更快的原因，是因为它们可以避免使用写磁盘的格式对内存数据结构编码的开销。</p>
</li>
<li><p>提供了给予磁盘索引难以实现的数据结构，例如Redis中的优先级队列和集合。</p>
</li>
<li><p>可以使用反缓存的方法，当没有足够的内存时，将一部分不常用数据倒入磁盘，类似操作系统的虚拟内存。</p>
</li>
<li><p>将来的NVM（non-volatile memory）技术广泛的普及，也可能很大的改变存储引擎的设计。</p>
</li>
</ul>
<h3 id="事务处理OLTP与分析处理OLAP"><a href="#事务处理OLTP与分析处理OLAP" class="headerlink" title="事务处理OLTP与分析处理OLAP"></a>事务处理OLTP与分析处理OLAP</h3><blockquote>
<p>事务意味着允许客户端进行低延迟读区和写入，相比于只能周期性的运行的批处理作业。事务不一定具有ACID属性。</p>
<ul>
<li><p>OLTP每次返回<font color='red'>少量的数据</font>，随机访问，低延迟要求。</p>
</li>
<li><p>OLAP对大量数据访问，批量导入（ETL）或事件流，内部分析师，为决策提供支持。</p>
</li>
</ul>
</blockquote>
<h4 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h4><blockquote>
<p>数据仓库是一个单独的数据库，分析师可以在不影响OLTP的情况下，任意使用数据仓库。数据仓库包含公司所有OLTP数据库的只读副本。</p>
<p>单独使用数据仓库的优势在于数据仓库可以针对分析访问模式进行优化。本文前半部分讨论的索引模型只适合与OLTP而不适合做分析查询。</p>
</blockquote>
<h5 id="OLTP数据库和数据仓库的差异"><a href="#OLTP数据库和数据仓库的差异" class="headerlink" title="OLTP数据库和数据仓库的差异"></a>OLTP数据库和数据仓库的差异</h5><ul>
<li><p>数据仓库也支持SQL查询接口，但是和OLTP的实现差异很大。</p>
</li>
<li><p>一些数据库（SQL Server和SAP HANA）在同一产品中支持事务处理和数据仓库。然而，它们是两个独立的存储和查询引擎，只是通过一个SQL接口来访问。</p>
</li>
<li><p>一些商用的数据仓库，Teradata，Vertica，SAP HANA等很贵。还有开源的基于Hadoop的SQL项目，例如Apache Hive，Spark SQL，Cloudera Impala，Facebook Presto，Apache Tajo和Apache Drill. 其中一些是基于Google Dremel而构建的。</p>
</li>
</ul>
<h4 id="星型与雪花型分析模式"><a href="#星型与雪花型分析模式" class="headerlink" title="星型与雪花型分析模式"></a>星型与雪花型分析模式</h4><blockquote>
<p>许多数据仓库都使用了星型模式，也称为维度建模。</p>
<p>这种模式的中心是一个所谓的事实表。事实表的每一行表示在特定时间发生的事件。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20201205232229.png"></p>
<ul>
<li><p>通常，事实被捕获为单独的事件，这样之后的分析具有很大的灵活性。</p>
</li>
<li><p>事实表中的列是属性，其他列可能会引用其他表的外键，成为维度表，这些维度代表事件的发生地点，时间，方式和原因。</p>
</li>
<li><p>名称<strong>星型模式</strong>来源于关系表可视化的适合，事实表位于中间，被一系列维度表包围。</p>
</li>
<li><p>该模型的一个变体成为<strong>雪花模型</strong>，其中维度进一步细分为子空间。例如，dimproduct表中的每一行可以再次向外引用品牌和类型的外键。这样更规范，但是更复杂。分析人员一般首选星型。</p>
</li>
<li><p>典型的数据仓库中，表都非常宽，事实表通常超过100列，甚至几百列。维度表也可能很宽。</p>
</li>
</ul>
<h3 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h3><ol>
<li><p>主要关注事实表的海量数据问题，通常有万亿行、PB级别的数据。</p>
</li>
<li><p>虽然通常事实表超过100列，但是一般一次分析也只会访问其中的4，5列。如何高效的执行这中类型的查询？</p>
</li>
<li><p>OLTP系统中，数据库的存储都是面向行的。如果属性超过100列，那么需要把很多不需要的数据读入内存，然后丢弃。非常低效。</p>
</li>
<li><p>面向列存储，不是将一行的内容存在一起，而是把每一列的所有值存在一起。</p>
</li>
</ol>
<h4 id="列压缩"><a href="#列压缩" class="headerlink" title="列压缩"></a>列压缩</h4><blockquote>
<p>面向列的存储非常适合压缩。一种技术是位图编码。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20201205232510.png"></p>
<ul>
<li><p>每一个不同的值一个位图，位图的位数是行数。</p>
</li>
<li><p>Bigtable模型仍然主要是面向行的。</p>
</li>
</ul>
<h5 id="内存带宽和矢量化处理"><a href="#内存带宽和矢量化处理" class="headerlink" title="内存带宽和矢量化处理"></a>内存带宽和矢量化处理</h5><ul>
<li>除了减少需要从磁盘加载的数据量之外，列存储也有利于高效利用CPU的周期性。</li>
</ul>
<h4 id="列存储中的排序"><a href="#列存储中的排序" class="headerlink" title="列存储中的排序"></a>列存储中的排序</h4><ul>
<li>列的存储如果是按照某个常见的顺序，例如date，就可以做类似于SSTables的索引机制。注意单独排序某列没用，需要正行排序。</li>
</ul>
<p>– 数据仓库管理员需要基于经验选择合适的排序列，可以单列也可以是多列。这样查询优化器可以更高效。</p>
<ul>
<li>另一个好处是可以进行压缩。可以进行游程编码，位图那样。</li>
</ul>
<h5 id="几种不同的排序"><a href="#几种不同的排序" class="headerlink" title="几种不同的排序"></a>几种不同的排序</h5><ol>
<li>C-Store的改进。用不同的方式存储相同的数据。使不同的排序查询都获益。也就是通过排序后的冗余数据加速。</li>
<li>列排序，类似于面向行的二级索引。区别是，列的索引中，存的是值而不是地址。</li>
</ol>
<h4 id="列存储与写操作"><a href="#列存储与写操作" class="headerlink" title="列存储与写操作"></a>列存储与写操作</h4><ul>
<li><p>上述的优化，都是对读的优化，这会让写变得更困难。类似B-tree的就地更新的操作，对压缩列是不可能的。</p>
</li>
<li><p>一个方案是类似LSM-tree。先写入内存的排序数据结构，然后在一定的时候把内存的数据顺序的倒入磁盘，接着进行有可能的文件合并。这样查询的时候需要检查内存中的数据，和磁盘中的数据。这对于查询方是透明的。</p>
</li>
</ul>
<h4 id="聚合：数据立方体和物化视图"><a href="#聚合：数据立方体和物化视图" class="headerlink" title="聚合：数据立方体和物化视图"></a>聚合：数据立方体和物化视图</h4><ul>
<li><p>数据仓库不是一定要用列存储的。但是列存储因为查询分析更快，所以正在迅速普及。数据仓库另一个方面是物化聚合，就是把常用的查询物理存储化，缓存一些查询结果。</p>
</li>
<li><p>实现：物化视图。 物化视图的常见特例称为数据立方体或OLAP立方。它是按不同维度分组的聚合网格。以沿着每行或每列应用相同的汇总，并获得一个维度减少的汇总（按产品的销售额，无论日期，还是按日期销售，无论产品如何）。</p>
</li>
<li><p>缺点是数据立方体不具有查询原始数据的灵活性。因此，大多数数据仓库试图保留尽可能多的原始数据，并将聚合数据（如数据立方体）仅用作某些查询的性能提升。</p>
</li>
</ul>
<h2 id="第9章-一致性与共识"><a href="#第9章-一致性与共识" class="headerlink" title="第9章 一致性与共识"></a>第9章 一致性与共识</h2><blockquote>
<p> 分布式最庸的抽象之一就是共识： 所有的节点就某一项提议达成一致.</p>
</blockquote>
<h3 id="可线性化"><a href="#可线性化" class="headerlink" title="可线性化"></a>可线性化</h3><blockquote>
<p>也称为原子一致性， 强一致性。</p>
<p>其基本的想法是让一个系统看起来好像只有一个数据副本， 且所有的操作都是原子的。有了这个保证， 应用程序就不需要关心系统内部的多个副本。</p>
</blockquote>
<h4 id="如何达到线性化？"><a href="#如何达到线性化？" class="headerlink" title="如何达到线性化？"></a>如何达到线性化？</h4><blockquote>
<p>可线性化背后的基本思想很简单：使系统看起来好像只有一个数据副本。</p>
</blockquote>
<blockquote>
<p><strong>可线性化与可串行化</strong></p>
<ul>
<li><p>可串行化</p>
<p>可串行化是事务的隔离属性， 其中每个事务可以读写多个对象（行， 文档， 记录等。它用来确保事务执行的结果<font color='red'>与串行执行（即每次执行一个事务）的结果完全相同</font>， 即使串行执行的顺序可能与事务实际执行顺序不同 。</p>
</li>
<li><p>可线性化</p>
<p>可线性化是<font color='red'>读写寄存器（单个对象）的最新值保证</font>。它并不要求将操作组合到事务中， 因此无法避免写倾针等问题 除非采取其他额外措施。</p>
</li>
</ul>
</blockquote>
<h4 id="线性化的依赖条件"><a href="#线性化的依赖条件" class="headerlink" title="线性化的依赖条件"></a>线性化的依赖条件</h4><ul>
<li>加锁与主节点选取</li>
<li>约束与唯一性保证</li>
<li>跨通道的时间依赖</li>
</ul>
<h4 id="实现线性化系统"><a href="#实现线性化系统" class="headerlink" title="实现线性化系统"></a>实现线性化系统</h4><ul>
<li><p>主从复制（部分支持可线性化）</p>
<p>在主从复制的系统中（参阅第5章的“主节点与从节点”) 只有主节点承担数据写入， 从节点则在各自节点上维护数据的备份副本。<strong>如果从主节点或者同步更新的从节点上读取， 则可以满足线性化。</strong>但并非每个主从复制的具体数据库实例都是可线性化的， 主要是因为它们可能采用了快照隔离的设计， 或者实现时存在并发方面的bug 。</p>
<p>而从主节点上读取的前提是你确定知道哪个节点是主节点。正如在第8章“ 真相由多数决定” 中所讨论的， 某节点可能自认为是主节点， 但事实并非如此， 这个“自以为是＂ 的主节点如果对外提供服务， 就会违反线性。</p>
<p>如果使用了异步复制， 故障切换过程中甚至可能会丢失一些已提交的写入，结果是同时违反持久性和线性化。</p>
</li>
<li><p>共识算法（可线性化）</p>
<p>与主从复制机制相似。不过共识协议通常内置一些措施来防止裂脑和过期的副本。正是由于这些专门的设计， 共识算法可以安全地实现线性化存储， 这些系统包括Zo0Keepe r l2 ‘1和etcdl22 」等。</p>
</li>
<li><p>多主复制（不可线性化）</p>
<p>具有多主节点复制的系统通常无法线性化的， 主要由于它们同时在多个节点上执行并发写入， 并将数据异步复制到其他节点。因此它们可能会产生冲突的写入，需要额外的解决方案。这类冲突其实正是多副本所引入的结果。</p>
</li>
<li><p>无主复制（可能不可线性化）</p>
<p>对千无主节点复制的系统（即Dynamo风格， 参阅第5章的“无主节点复制) 有些入认为只要配置法定读取和写入满足(w+r&gt;n)就可以获得“ 强一致性” 。但这完全取决千具体的quorum的配置， 以及如何定义强一致性， 它可能并不保证线性化。</p>
<p>例如基于墙上时钟（包括Cassandra, 参阅第8章“ 依赖于同步的时钟,,)的“ 最后写入获胜＂ 冲突解决方法几乎肯定是非线性化， 因为这种时间戳无法保证与实际事件顺序一致（例如由于时钟偏移）。</p>
<p>不规范的quorum(参阅第5章“ 宽松的quorum与数据回传) 也会破坏线性化。甚至即使是严格的quorum, 正如之后即将介绍的， 也会发生违背线性化的情况。</p>
</li>
</ul>
<h5 id="线性化与-quorum"><a href="#线性化与-quorum" class="headerlink" title="线性化与 quorum"></a>线性化与 quorum</h5><h4 id="线性化的代价"><a href="#线性化的代价" class="headerlink" title="线性化的代价"></a>线性化的代价</h4><h5 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h5>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/30/notepad/read/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8.mm/</url>
    <content><![CDATA[<h1 id="数据密集型应用学习笔记"><a href="#数据密集型应用学习笔记" class="headerlink" title="数据密集型应用学习笔记"></a>数据密集型应用学习笔记</h1><h2 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h2><h3 id="数据库核心：-数据结构"><a href="#数据库核心：-数据结构" class="headerlink" title="数据库核心： 数据结构"></a>数据库核心： 数据结构</h3><blockquote>
<p>一个最简单的数据库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">db_set</span></span> () &#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>,<span class="variable">$2</span>&quot;</span> &gt;&gt; database</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">db_get</span></span> () &#123;</span><br><span class="line">	grep <span class="string">&quot;^<span class="variable">$1</span>,&quot;</span> database | sed -e <span class="string">&quot;s/^<span class="variable">$1</span>,//&quot;</span> | tail -n 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>db_set</p>
<ul>
<li>追加到文件尾部方式通常足够高效， 因而db_set函数性能很好。</li>
<li>与db_set相似， 许多数据库内部都使用日志(log) , 日志是一个仅支持追加式更新的数据文件</li>
</ul>
</li>
<li><p>db_get</p>
<ul>
<li>db_get函数的性能会非常差。</li>
<li>每次想查找一个键， db_get必须从头到尾扫描整个数据库文件来查找键的出现位置, 查找的开销是O(n)。</li>
</ul>
</li>
</ul>
<p>如何解决查找缓慢？ </p>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><blockquote>
<p>可以提供高性能的读和写， 只要所有的key可以放入内存（因为hash map需要保存在内存中）</p>
</blockquote>
<ul>
<li>引入新的问题<ul>
<li>哈希表必须全部放入内存， 如果有大量的键， 就没那么幸运了。</li>
<li>很难使磁盘上的hash map表现良好，需要大量的随机访问I/0。</li>
<li>当哈希变满时，增长代价昂贵，并且哈希冲突时需要复杂的处理逻辑。</li>
<li>区间查询效率不高。不能简单地扫描a和z区间内的所有键，只能采用逐个查找的方式查询每一个键。</li>
</ul>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>使用限制，用作存储点击量，访问量</li>
</ul>
<h4 id="SSTable和-LSM-Tree"><a href="#SSTable和-LSM-Tree" class="headerlink" title="SSTable和 LSM-Tree"></a>SSTable和 LSM-Tree</h4><blockquote>
<p><strong>键值对的序列按键排序</strong>。这就是<strong>SSTables（Sorted String Tables）</strong>的数据格式。我们还要求同一个key只会出现在一个段中。</p>
</blockquote>
<h5 id="SSTables优点："><a href="#SSTables优点：" class="headerlink" title="SSTables优点："></a>SSTables优点：</h5><ol>
<li>合并段更简单。就像merge sort一样。</li>
<li>查找数据使用二分查找</li>
<li>压缩时，可以利用稀疏索引，降低了IO带宽。</li>
</ol>
<h5 id="构建和维护SSTables"><a href="#构建和维护SSTables" class="headerlink" title="构建和维护SSTables"></a>构建和维护SSTables</h5><p>要解决排序问题。方法是，</p>
<ol>
<li>在内存中保存一个排序结构，比如红黑树，AVL树。</li>
<li>在插入修改时候可以很快的响应。</li>
<li>可以顺序的读区它们。</li>
</ol>
<h5 id="存储引擎工作流程"><a href="#存储引擎工作流程" class="headerlink" title="存储引擎工作流程"></a>存储引擎工作流程</h5><ol>
<li>写入时，将数据加入内存表中，可以是红黑树实现。</li>
<li>当内存中的红黑树大小超过阀值时，把它用SSTable的格式写入磁盘。</li>
<li>处理读请求时，先尝试查询内存表，如果miss就查询磁盘段文件s。</li>
<li>周期性的执行合并和压缩。丢弃被覆盖和删除的值。</li>
</ol>
<h5 id="实现LSM-Tree（Log-structured-Merge-Tree）"><a href="#实现LSM-Tree（Log-structured-Merge-Tree）" class="headerlink" title="实现LSM-Tree（Log-structured Merge-Tree）"></a>实现LSM-Tree（Log-structured Merge-Tree）</h5><ul>
<li><p>LevelDB，RocksDB，HBase， 都源于Google的BigTable论文。最初这个索引结构在早起的系统中被命名LSM-Tree。因此，基于合并和压缩的排序文件原理的存储引擎，通常都被称作LSM存储引擎。</p>
</li>
<li><p>全文搜索，Lucene是ElasticSearch和Solr的索引引擎。采用了类似的方法保存字典。全文索引复杂的多，但想法类似。</p>
</li>
</ul>
<h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><ol>
<li>查询不存在的key时，会从内存开始扫描到磁盘的最后一个段。解决方法是，Bloom Filter。</li>
<li>压缩合并的时机。分为大小分级和分层压缩两个方法。一个是小的SSTables被连续合并到大的旧的SSTables。另一个是key的范围分裂成多个更小的SSTables，旧数据被移动到单独的层级。</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul>
<li>由于数据是按照排序存储，因此可以高效的执行区间查询。</li>
<li>因为磁盘是顺序写入的，LSM-Tree的写入吞吐量可以非常高。</li>
</ul>
<h4 id="B-trees索引"><a href="#B-trees索引" class="headerlink" title="B-trees索引"></a>B-trees索引</h4><blockquote>
<p>应用最广泛的索引结构。和SSTable一样，B-tree保留按key排，也可以实现高效的范围查询。</p>
<p>B-tree将数据库分解成固定大小的块和页（4KB or more）。这种设计更接近底层硬件，因为磁盘也是固定大小的块的排列。</p>
<p>每个页可以用地址标志，是磁盘地址，而不是内存。这样可以用这些页面引用构造一个树状页面进行索引。索引的根是一个页面，之后的查找根据地址，读取相应的页。</p>
<p>分支因子：大多数数据库的索引适合3-4层的B-tree.因此不需要遍历非常深的页面层次即可找到所需的页。</p>
<ul>
<li> B树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</li>
<li>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</li>
</ul>
</blockquote>
<h5 id="使B-tree可靠"><a href="#使B-tree可靠" class="headerlink" title="使B-tree可靠"></a>使B-tree可靠</h5><ul>
<li><p>B-tree底层的基本操作是使用新数据覆盖磁盘的旧页。磁盘是覆盖扇区，对于SSD，擦除和重写的存储芯片块很大，情况更复杂。</p>
</li>
<li><p>页面溢出，需要分裂页时，也要覆盖其父页对更新后的两个子页的引用。属于复杂操作。在完成更新前发生崩溃，可能会产生孤儿页面。</p>
</li>
<li><p>崩溃恢复，使用redo Log。写数据之前先写日志。</p>
</li>
<li><p>并发控制。</p>
</li>
</ul>
<h5 id="优化B-tree"><a href="#优化B-tree" class="headerlink" title="优化B-tree"></a>优化B-tree</h5><ol>
<li>一些数据库不是用覆盖页，而是做复制。</li>
<li>保存key的缩略信息而不是完整的key，来节省空间。只需要提供足够的信息来描述key的起止范围。</li>
<li>页可以存在磁盘的任何位置。可能回有随机的IO，而不是连续的。有些B-tree尝试实现对B-tree进行布局，但是随着树的增长，这个顺序会越来越难维护。</li>
<li>添加额外指针。左到右的指针，加速遍历。</li>
</ol>
<h4 id="对比B-tree-LSM-tree"><a href="#对比B-tree-LSM-tree" class="headerlink" title="对比B-tree, LSM-tree"></a>对比B-tree, LSM-tree</h4><blockquote>
<p>根据经验，LSM-Tree写入更快，而B-tree读更快。读取通常在LSM—Tree中较慢，因为要检查多个不同的数据结构和SSTables。</p>
</blockquote>
<h5 id="LSM-Tree优点"><a href="#LSM-Tree优点" class="headerlink" title="LSM-Tree优点"></a>LSM-Tree优点</h5><ol>
<li>LSM只写入一次数据（不考虑写放大（写入引起的压缩和合并）），而B-tree写入两次（一次redo log，一次数据本身）。</li>
<li>LSM可以成熟比B-tree更大的吞吐量。有时具有较低的写放大，顺序写入速度快。</li>
<li>可以支持更好的压缩，文件比B-tree小很多。没有B-tree产生碎片的问题。</li>
</ol>
<h5 id="LSM-Tree缺点"><a href="#LSM-Tree缺点" class="headerlink" title="LSM-Tree缺点"></a>LSM-Tree缺点</h5><ol>
<li>响应延迟不确定，因为压缩和合并。</li>
<li>由于配置问题，会出现压缩跟不上写入速度的问题。来不及合并，直到磁盘空间不足。</li>
<li>事务支持不如B-tree</li>
</ol>
<h4 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h4><h5 id="在索引中存储值"><a href="#在索引中存储值" class="headerlink" title="在索引中存储值"></a>在索引中存储值</h5><blockquote>
<p>索引中存储行或则行的具体位置（堆文件法）。将索引行直接存在索引中，聚集索引。MySQL的InnoDB存储引擎中，表的主键是聚集索引，二级索引引用主键。</p>
</blockquote>
<h5 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h5><ul>
<li><p>级联索引，通过将一列追加到另一列，将几个字段组合成一个键。只能从前到后匹配。B-tree和LSM-tree都无法高效的应对这种查询。</p>
</li>
<li><p>更常见的索引空间，R树。PostGIS使用PostgreSQL的广义搜索书索引实现了地理空间索引作为R树。</p>
</li>
</ul>
<h5 id="全文搜索和模糊索引"><a href="#全文搜索和模糊索引" class="headerlink" title="全文搜索和模糊索引"></a>全文搜索和模糊索引</h5><blockquote>
<p>之前的搜索都是准确匹配，而不能应对类似的key的搜索，例如错误的拼写。</p>
<p>Lucene引擎支持在某个编辑距离内的模糊搜索。LevelDB中这个内存中的索引是一些key的稀疏集合。但在Lucene中，内存中的索引是key中的字符串序列的有限状态机，类似字典树。这个自动机可以转换成Leveshtein自动机，支持编辑距离内的搜索。</p>
</blockquote>
<h5 id="在内存中保存所有内容"><a href="#在内存中保存所有内容" class="headerlink" title="在内存中保存所有内容"></a>在内存中保存所有内容</h5><ul>
<li><p>内存数据库。例如Memcached，做缓存。数据在重启后可以恢复。</p>
</li>
<li><p>内存数据可以更快的原因，是因为它们可以避免使用写磁盘的格式对内存数据结构编码的开销。</p>
</li>
<li><p>提供了给予磁盘索引难以实现的数据结构，例如Redis中的优先级队列和集合。</p>
</li>
<li><p>可以使用反缓存的方法，当没有足够的内存时，将一部分不常用数据倒入磁盘，类似操作系统的虚拟内存。</p>
</li>
<li><p>将来的NVM（non-volatile memory）技术广泛的普及，也可能很大的改变存储引擎的设计。</p>
</li>
</ul>
<h3 id="事务处理OLTP与分析处理OLAP"><a href="#事务处理OLTP与分析处理OLAP" class="headerlink" title="事务处理OLTP与分析处理OLAP"></a>事务处理OLTP与分析处理OLAP</h3><blockquote>
<p>事务意味着允许客户端进行低延迟读区和写入，相比于只能周期性的运行的批处理作业。事务不一定具有ACID属性。</p>
<ul>
<li><p>OLTP每次返回<font color='red'>少量的数据</font>，随机访问，低延迟要求。</p>
</li>
<li><p>OLAP对大量数据访问，批量导入（ETL）或事件流，内部分析师，为决策提供支持。</p>
</li>
</ul>
</blockquote>
<h4 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h4><blockquote>
<p>数据仓库是一个单独的数据库，分析师可以在不影响OLTP的情况下，任意使用数据仓库。数据仓库包含公司所有OLTP数据库的只读副本。</p>
<p>单独使用数据仓库的优势在于数据仓库可以针对分析访问模式进行优化。本文前半部分讨论的索引模型只适合与OLTP而不适合做分析查询。</p>
</blockquote>
<h5 id="OLTP数据库和数据仓库的差异"><a href="#OLTP数据库和数据仓库的差异" class="headerlink" title="OLTP数据库和数据仓库的差异"></a>OLTP数据库和数据仓库的差异</h5><ul>
<li><p>数据仓库也支持SQL查询接口，但是和OLTP的实现差异很大。</p>
</li>
<li><p>一些数据库（SQL Server和SAP HANA）在同一产品中支持事务处理和数据仓库。然而，它们是两个独立的存储和查询引擎，只是通过一个SQL接口来访问。</p>
</li>
<li><p>一些商用的数据仓库，Teradata，Vertica，SAP HANA等很贵。还有开源的基于Hadoop的SQL项目，例如Apache Hive，Spark SQL，Cloudera Impala，Facebook Presto，Apache Tajo和Apache Drill. 其中一些是基于Google Dremel而构建的。</p>
</li>
</ul>
<h4 id="星型与雪花型分析模式"><a href="#星型与雪花型分析模式" class="headerlink" title="星型与雪花型分析模式"></a>星型与雪花型分析模式</h4><blockquote>
<p>许多数据仓库都使用了星型模式，也称为维度建模。</p>
<p>这种模式的中心是一个所谓的事实表。事实表的每一行表示在特定时间发生的事件。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20201205232229.png"></p>
<ul>
<li><p>通常，事实被捕获为单独的事件，这样之后的分析具有很大的灵活性。</p>
</li>
<li><p>事实表中的列是属性，其他列可能会引用其他表的外键，成为维度表，这些维度代表事件的发生地点，时间，方式和原因。</p>
</li>
<li><p>名称<strong>星型模式</strong>来源于关系表可视化的适合，事实表位于中间，被一系列维度表包围。</p>
</li>
<li><p>该模型的一个变体成为<strong>雪花模型</strong>，其中维度进一步细分为子空间。例如，dimproduct表中的每一行可以再次向外引用品牌和类型的外键。这样更规范，但是更复杂。分析人员一般首选星型。</p>
</li>
<li><p>典型的数据仓库中，表都非常宽，事实表通常超过100列，甚至几百列。维度表也可能很宽。</p>
</li>
</ul>
<h3 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h3><ol>
<li><p>主要关注事实表的海量数据问题，通常有万亿行、PB级别的数据。</p>
</li>
<li><p>虽然通常事实表超过100列，但是一般一次分析也只会访问其中的4，5列。如何高效的执行这中类型的查询？</p>
</li>
<li><p>OLTP系统中，数据库的存储都是面向行的。如果属性超过100列，那么需要把很多不需要的数据读入内存，然后丢弃。非常低效。</p>
</li>
<li><p>面向列存储，不是将一行的内容存在一起，而是把每一列的所有值存在一起。</p>
</li>
</ol>
<h4 id="列压缩"><a href="#列压缩" class="headerlink" title="列压缩"></a>列压缩</h4><blockquote>
<p>面向列的存储非常适合压缩。一种技术是位图编码。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20201205232510.png"></p>
<ul>
<li><p>每一个不同的值一个位图，位图的位数是行数。</p>
</li>
<li><p>Bigtable模型仍然主要是面向行的。</p>
</li>
</ul>
<h5 id="内存带宽和矢量化处理"><a href="#内存带宽和矢量化处理" class="headerlink" title="内存带宽和矢量化处理"></a>内存带宽和矢量化处理</h5><ul>
<li>除了减少需要从磁盘加载的数据量之外，列存储也有利于高效利用CPU的周期性。</li>
</ul>
<h4 id="列存储中的排序"><a href="#列存储中的排序" class="headerlink" title="列存储中的排序"></a>列存储中的排序</h4><ul>
<li>列的存储如果是按照某个常见的顺序，例如date，就可以做类似于SSTables的索引机制。注意单独排序某列没用，需要正行排序。</li>
</ul>
<p>– 数据仓库管理员需要基于经验选择合适的排序列，可以单列也可以是多列。这样查询优化器可以更高效。</p>
<ul>
<li>另一个好处是可以进行压缩。可以进行游程编码，位图那样。</li>
</ul>
<h5 id="几种不同的排序"><a href="#几种不同的排序" class="headerlink" title="几种不同的排序"></a>几种不同的排序</h5><ol>
<li>C-Store的改进。用不同的方式存储相同的数据。使不同的排序查询都获益。也就是通过排序后的冗余数据加速。</li>
<li>列排序，类似于面向行的二级索引。区别是，列的索引中，存的是值而不是地址。</li>
</ol>
<h4 id="列存储与写操作"><a href="#列存储与写操作" class="headerlink" title="列存储与写操作"></a>列存储与写操作</h4><ul>
<li><p>上述的优化，都是对读的优化，这会让写变得更困难。类似B-tree的就地更新的操作，对压缩列是不可能的。</p>
</li>
<li><p>一个方案是类似LSM-tree。先写入内存的排序数据结构，然后在一定的时候把内存的数据顺序的倒入磁盘，接着进行有可能的文件合并。这样查询的时候需要检查内存中的数据，和磁盘中的数据。这对于查询方是透明的。</p>
</li>
</ul>
<h4 id="聚合：数据立方体和物化视图"><a href="#聚合：数据立方体和物化视图" class="headerlink" title="聚合：数据立方体和物化视图"></a>聚合：数据立方体和物化视图</h4><ul>
<li><p>数据仓库不是一定要用列存储的。但是列存储因为查询分析更快，所以正在迅速普及。数据仓库另一个方面是物化聚合，就是把常用的查询物理存储化，缓存一些查询结果。</p>
</li>
<li><p>实现：物化视图。 物化视图的常见特例称为数据立方体或OLAP立方。它是按不同维度分组的聚合网格。以沿着每行或每列应用相同的汇总，并获得一个维度减少的汇总（按产品的销售额，无论日期，还是按日期销售，无论产品如何）。</p>
</li>
<li><p>缺点是数据立方体不具有查询原始数据的灵活性。因此，大多数数据仓库试图保留尽可能多的原始数据，并将聚合数据（如数据立方体）仅用作某些查询的性能提升。</p>
</li>
</ul>
<h2 id="第9章-一致性与共识"><a href="#第9章-一致性与共识" class="headerlink" title="第9章 一致性与共识"></a>第9章 一致性与共识</h2><blockquote>
<p> 分布式最庸的抽象之一就是共识： 所有的节点就某一项提议达成一致.</p>
</blockquote>
<h3 id="可线性化"><a href="#可线性化" class="headerlink" title="可线性化"></a>可线性化</h3><blockquote>
<p>也称为原子一致性， 强一致性。</p>
<p>其基本的想法是让一个系统看起来好像只有一个数据副本， 且所有的操作都是原子的。有了这个保证， 应用程序就不需要关心系统内部的多个副本。</p>
</blockquote>
<h4 id="如何达到线性化？"><a href="#如何达到线性化？" class="headerlink" title="如何达到线性化？"></a>如何达到线性化？</h4><blockquote>
<p>可线性化背后的基本思想很简单：使系统看起来好像只有一个数据副本。</p>
</blockquote>
<blockquote>
<p><strong>可线性化与可串行化</strong></p>
<ul>
<li><p>可串行化</p>
<p>可串行化是事务的隔离属性， 其中每个事务可以读写多个对象（行， 文档， 记录等。它用来确保事务执行的结果<font color='red'>与串行执行（即每次执行一个事务）的结果完全相同</font>， 即使串行执行的顺序可能与事务实际执行顺序不同 。</p>
</li>
<li><p>可线性化</p>
<p>可线性化是<font color='red'>读写寄存器（单个对象）的最新值保证</font>。它并不要求将操作组合到事务中， 因此无法避免写倾针等问题 除非采取其他额外措施。</p>
</li>
</ul>
</blockquote>
<h4 id="线性化的依赖条件"><a href="#线性化的依赖条件" class="headerlink" title="线性化的依赖条件"></a>线性化的依赖条件</h4><ul>
<li>加锁与主节点选取</li>
<li>约束与唯一性保证</li>
<li>跨通道的时间依赖</li>
</ul>
<h4 id="实现线性化系统"><a href="#实现线性化系统" class="headerlink" title="实现线性化系统"></a>实现线性化系统</h4><ul>
<li><p>主从复制（部分支持可线性化）</p>
<p>在主从复制的系统中（参阅第5章的“主节点与从节点”) 只有主节点承担数据写入， 从节点则在各自节点上维护数据的备份副本。<strong>如果从主节点或者同步更新的从节点上读取， 则可以满足线性化。</strong>但并非每个主从复制的具体数据库实例都是可线性化的， 主要是因为它们可能采用了快照隔离的设计， 或者实现时存在并发方面的bug 。</p>
<p>而从主节点上读取的前提是你确定知道哪个节点是主节点。正如在第8章“ 真相由多数决定” 中所讨论的， 某节点可能自认为是主节点， 但事实并非如此， 这个“自以为是＂ 的主节点如果对外提供服务， 就会违反线性。</p>
<p>如果使用了异步复制， 故障切换过程中甚至可能会丢失一些已提交的写入，结果是同时违反持久性和线性化。</p>
</li>
<li><p>共识算法（可线性化）</p>
<p>与主从复制机制相似。不过共识协议通常内置一些措施来防止裂脑和过期的副本。正是由于这些专门的设计， 共识算法可以安全地实现线性化存储， 这些系统包括Zo0Keepe r l2 ‘1和etcdl22 」等。</p>
</li>
<li><p>多主复制（不可线性化）</p>
<p>具有多主节点复制的系统通常无法线性化的， 主要由于它们同时在多个节点上执行并发写入， 并将数据异步复制到其他节点。因此它们可能会产生冲突的写入，需要额外的解决方案。这类冲突其实正是多副本所引入的结果。</p>
</li>
<li><p>无主复制（可能不可线性化）</p>
<p>对千无主节点复制的系统（即Dynamo风格， 参阅第5章的“无主节点复制) 有些入认为只要配置法定读取和写入满足(w+r&gt;n)就可以获得“ 强一致性” 。但这完全取决千具体的quorum的配置， 以及如何定义强一致性， 它可能并不保证线性化。</p>
<p>例如基于墙上时钟（包括Cassandra, 参阅第8章“ 依赖于同步的时钟,,)的“ 最后写入获胜＂ 冲突解决方法几乎肯定是非线性化， 因为这种时间戳无法保证与实际事件顺序一致（例如由于时钟偏移）。</p>
<p>不规范的quorum(参阅第5章“ 宽松的quorum与数据回传) 也会破坏线性化。甚至即使是严格的quorum, 正如之后即将介绍的， 也会发生违背线性化的情况。</p>
</li>
</ul>
<h5 id="线性化与-quorum"><a href="#线性化与-quorum" class="headerlink" title="线性化与 quorum"></a>线性化与 quorum</h5><h4 id="线性化的代价"><a href="#线性化的代价" class="headerlink" title="线性化的代价"></a>线性化的代价</h4><h5 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h5>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/05/notepad/read/DDIA/</url>
    <content><![CDATA[<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.4/dist/style.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.3.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.4/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(function anonymous(
) {
const toolbar = new markmap.Toolbar();
toolbar.attach(mm);
const el = toolbar.render();
el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
document.body.append(el);
})</script><script>((getMarkmap, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', null, data);
      })(() => window.markmap,{"t":"heading","d":1,"p":{},"v":"数据密集型应用学习笔记","c":[{"t":"heading","d":2,"p":{},"v":"第1章","c":[{"t":"blockquote","d":3,"p":{},"v":"","c":[{"t":"paragraph","d":4,"p":{},"v":"当今许多应用大多是数据数据密集（data-intensive）而不是计算密集型（compute-intensive）的。所以CPU的处理能力往往不是应用程序的瓶颈。关键在于数据的量、数据的复杂度以及数据的快速多变性。"}]},{"t":"bullet_list","d":3,"p":{},"v":"","c":[{"t":"list_item","d":4,"p":{},"v":"应用往往包含以下模块："}]},{"t":"ordered_list","d":3,"p":{"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"index":1},"v":"1. 数据库：用于存储数据"},{"t":"list_item","d":4,"p":{"index":2},"v":"2. 高速缓存：缓存复杂或者操作代价昂贵的结果，加快下一次访问"},{"t":"list_item","d":4,"p":{"index":3},"v":"3. 索引：用户可以按照关键字搜索数据并支持各种过滤"},{"t":"list_item","d":4,"p":{"index":4},"v":"4. 流式处理：持续发送消息到另一个进程，处理采用异步方式"},{"t":"list_item","d":4,"p":{"index":5},"v":"5. 批处理：定期处理大量积累的数据"}]},{"t":"heading","d":3,"p":{},"v":"认识数据系统"},{"t":"heading","d":3,"p":{},"v":"可靠性","c":[{"t":"blockquote","d":4,"p":{},"v":"","c":[{"t":"paragraph","d":5,"p":{},"v":"出现意外情况，比如硬件、软件故障、人为失误等，系统可以继续正常运转，至少确保功能正确。"}]},{"t":"heading","d":4,"p":{},"v":"硬件故障","c":[{"t":"paragraph","d":6,"p":{},"v":"比较容易出现的，硬盘崩溃，内存故障，电网停电。"},{"t":"paragraph","d":6,"p":{},"v":"第一反应是为硬件冗余来减少系统故障率。例如磁盘RAID，服务器双电源，甚至热插拔CPU，数据中心添加备用电源、发电机。"},{"t":"paragraph","d":6,"p":{},"v":"这样当一个组件发生故障时，冗余组件可以快速接管，之后运维人员可以修复或者更换坏掉的组件。"},{"t":"paragraph","d":6,"p":{},"v":"直到最近，采用硬件冗余方案对于大多数应用场景还是足够的，它让单机完全失效的概率降到最低。只要可以把备份迅速恢复到新的机器上，故障的停机时间在大多数应用中并不是灾难性的。"},{"t":"paragraph","d":6,"p":{},"v":"现在，通过软件容错的方式来容易多机失效成为新的手段，或者成为硬件容错方案的有力补充。例如滚动升级。"}]},{"t":"heading","d":4,"p":{},"v":"软件错误","c":[{"t":"blockquote","d":5,"p":{},"v":"","c":[{"t":"paragraph","d":6,"p":{},"v":"这类故障更难预料。各个节点直接是由软件关联的，可能会导致更多的系统故障。"}]},{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"例如，"}]},{"t":"ordered_list","d":5,"p":{"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"index":1},"v":"1. 由于软件错误，导致特定的输入引发应用的崩溃。例如Linux内核bug，在2012年6月30的闰秒时候触发，导致很多应用程序被挂掉。"},{"t":"list_item","d":6,"p":{"index":2},"v":"2. 失控的进程把系统的资源耗尽，导致这些共享资源不能被释放。"},{"t":"list_item","d":6,"p":{"index":3},"v":"3. 系统的Dependency出了问题，返回值异常。"},{"t":"list_item","d":6,"p":{"index":4},"v":"4. 组件中的小故障触发另一个组件中的故障，进而触发更多的故障。"}]},{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"没有快速的解决方法。只能仔细考虑很多细节。"}]},{"t":"ordered_list","d":5,"p":{"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"index":1},"v":"1. 检查系统的假设条件和系统之间的交互"},{"t":"list_item","d":6,"p":{"index":2},"v":"2. 进行全面的测试"},{"t":"list_item","d":6,"p":{"index":3},"v":"3. 进程隔离，"},{"t":"list_item","d":6,"p":{"index":4},"v":"4. 允许进程崩溃后自动重启"},{"t":"list_item","d":6,"p":{"index":5},"v":"5. 反复评估、监控并分析生产环境中的行为表现。"}]}]},{"t":"heading","d":4,"p":{},"v":"人为失误","c":[{"t":"blockquote","d":5,"p":{},"v":"","c":[{"t":"paragraph","d":6,"p":{},"v":"人无法做到万无一失。运维人员的配置错误可能是系统下线的第一大原因。"},{"t":"paragraph","d":6,"p":{},"v":"要保证系统可靠，如何减少人为错误对它的影响？"}]},{"t":"ordered_list","d":5,"p":{"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"index":1},"v":"1. 用最小出错的方式来设计系统。让做错事更难。"},{"t":"list_item","d":6,"p":{"index":2},"v":"2. 想办法分离最容易出错的地方，容易引发故障的接口。使用Sandbox隔离真正的生产和测试环境。"},{"t":"list_item","d":6,"p":{"index":3},"v":"3. 充分的测试。单元测试，集成测试，手动测试。边界条件的考虑。"},{"t":"list_item","d":6,"p":{"index":4},"v":"4. 当出现人为失误时，有快速回滚或者回复的机制。滚动发布新代码。"},{"t":"list_item","d":6,"p":{"index":5},"v":"5. 监控子系统需要详细和清晰。"},{"t":"list_item","d":6,"p":{"index":6},"v":"6. 推行管理流程和相关培训。"}]}]}]},{"t":"heading","d":3,"p":{},"v":"可扩展性","c":[{"t":"blockquote","d":4,"p":{},"v":"","c":[{"t":"paragraph","d":5,"p":{},"v":"随着规模的增长，例如数据量、流量和复杂性，系统应该可以用合理的方式进行应对，满足这种增长。"},{"t":"paragraph","d":5,"p":{},"v":"当应用负载增加的时候，比如用户从1w到100w，从100w到1000w，应用程序如何应对增长的负载。"},{"t":"paragraph","d":5,"p":{},"v":"相关参数：Web服务的QPS，数据库的写入比例，DAU，缓存命中率。有时候平均值很重要，有时候短时间内的峰值会成为系统瓶颈。"},{"t":"paragraph","d":5,"p":{},"v":"Twitter的Fan-out结构，对数据量提出了挑战。当一个人发Tweet时候，怎么处理Timeline这个请求。根据粉丝的数量，区别处理。"}]},{"t":"heading","d":4,"p":{},"v":"描述性能","c":[{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"系统负载增加后，会发生什么，两种思考方式"}]},{"t":"ordered_list","d":5,"p":{"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"index":1},"v":"1. 系统资源不变（CPU，内存，带宽），系统的性能会发生什么变化？"},{"t":"list_item","d":6,"p":{"index":2},"v":"2. 如果要保持性能不变，需要增加多少资源？"}]},{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"不同类型的系统关心的性能指标不同"}]},{"t":"ordered_list","d":5,"p":{"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"index":1},"v":"1. 批处理系统通常关心<strong>吞吐量（throughput）</strong>，例如Hadoop，每秒可以处理多少条数据或者完成一个作业总共需要多少时间。"},{"t":"list_item","d":6,"p":{"index":2},"v":"2. Online系统中，更看重服务的<strong>响应时间（response time）</strong>，即客户端从发出请求到得到回复的总时间。"}]},{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"对于响应时间，如下图，有一些很长的，算异常请求，可能是由于数据大很多。但也有可能是其他因素造成的，例如上下文切换、进程调度、网络丢包、TCP重传、垃圾回收STW，缺页中断、磁盘IO。"},{"t":"list_item","d":6,"p":{},"v":"最好使用百分位数，中位数（50%）来评估系统的响应时间。"},{"t":"list_item","d":6,"p":{},"v":"采用较高的响应时间百分位数很重要，因为直接影响用户的总体服务体验。例如亚马逊采用99.9百分位来定义服务响应时间。优化99.9%的目标可能成本很高。能不能带来收益很关键。"},{"t":"list_item","d":6,"p":{},"v":"排队延迟（queueing delay）通常占了高百分位点处响应时间的很大一部分。由于服务器只能并行处理少量的事务（如受其CPU核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为头部阻塞（head-of-line blocking）"}]}]},{"t":"heading","d":4,"p":{},"v":"应对负载增加","c":[{"t":"list_item","d":6,"p":{},"v":"垂直扩展和水平扩展。"},{"t":"list_item","d":6,"p":{},"v":"好的系统有弹性特征，可以自动检测负载的变化，来自动添加更多的计算资源。"},{"t":"list_item","d":6,"p":{},"v":"可扩展架构通常都是从通用模块逐步构建出来的。"}]}]},{"t":"heading","d":3,"p":{},"v":"可维护性","c":[{"t":"blockquote","d":4,"p":{},"v":"","c":[{"t":"paragraph","d":5,"p":{},"v":"项目会随着时间的推移，项目会需要新的人员参与到开发和运维工作中，来满足系统的稳定和新场景的适应。系统应该高效的变化。"},{"t":"paragraph","d":5,"p":{},"v":"软件的大部分开销并不在最初的开发阶段，而是在持续的维护阶段，包括修复漏洞、保持系统正常运行、调查失效、适配新的平台、为新的场景进行修改、偿还技术债、添加新的功能等等。"},{"t":"paragraph","d":5,"p":{},"v":"为此，我们将特别关注软件系统的三个设计原则："}]},{"t":"heading","d":4,"p":{},"v":"可操作性（Operability）","c":[{"t":"paragraph","d":6,"p":{},"v":"便于运维团队保持系统平稳运行。"},{"t":"paragraph","d":6,"p":{},"v":"良好的可操作性意味着更轻松的日常工作，进而运维团队能专注于高价值的事情。"},{"t":"paragraph","d":6,"p":{},"v":"数据系统可以通过各种方式使日常任务更轻松"}]},{"t":"heading","d":4,"p":{},"v":"简单性（Simplicity）","c":[{"t":"list_item","d":6,"p":{},"v":"从系统中消除尽可能多的复杂度（complexity），使新工程师也能轻松理解系统。（注意这和用户接口的简单性不一样。）<br>\n<strong>复杂度（complexity）</strong>有各种可能的症状，例如：状态空间激增、模块间紧密耦合、纠结的依赖关系、不一致的命名和术语、解决性能问题的Hack、需要绕开的特例等等，"}]},{"t":"heading","d":4,"p":{},"v":"可演化性（evolability）","c":[{"t":"list_item","d":6,"p":{},"v":"使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为可扩展性（extensibility），可修改性（modifiability）或可塑性（plasticity）。"},{"t":"list_item","d":6,"p":{},"v":"组织流程方面，敏捷开发，TDD，重构。"},{"t":"list_item","d":6,"p":{},"v":"修改数据系统并使其适应不断变化需求的容易程度，是与简单性和抽象性密切相关的：简单易懂的系统通常比复杂系统更容易修改"}]}]}]},{"t":"heading","d":2,"p":{},"v":"第3章","c":[{"t":"heading","d":3,"p":{},"v":"数据库核心： 数据结构","c":[{"t":"blockquote","d":4,"p":{},"v":"","c":[{"t":"paragraph","d":5,"p":{},"v":"一个最简单的数据库"}]},{"t":"fence","d":4,"v":"<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token function-name function\">db_set</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>,<span class=\"token variable\">$2</span>\"</span> <span class=\"token operator\">>></span> database\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token function-name function\">db_get</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">grep</span> <span class=\"token string\">\"^<span class=\"token variable\">$1</span>,\"</span> database <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> -e <span class=\"token string\">\"s/^<span class=\"token variable\">$1</span>,//\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">tail</span> -n <span class=\"token number\">1</span>\n<span class=\"token punctuation\">&#125;</span>\n</code></pre>\n"},{"t":"bullet_list","d":4,"p":{},"v":"","c":[{"t":"list_item","d":5,"p":{},"v":"db_set","c":[{"t":"list_item","d":7,"p":{},"v":"追加到文件尾部方式通常足够高效， 因而db_set函数性能很好。"},{"t":"list_item","d":7,"p":{},"v":"与db_set相似， 许多数据库内部都使用日志(log) , 日志是一个仅支持追加式更新的数据文件"}]},{"t":"list_item","d":5,"p":{},"v":"db_get","c":[{"t":"list_item","d":7,"p":{},"v":"db_get函数的性能会非常差。"},{"t":"list_item","d":7,"p":{},"v":"每次想查找一个键， db_get必须从头到尾扫描整个数据库文件来查找键的出现位置, 查找的开销是O(n)。"}]}]},{"t":"heading","d":4,"p":{},"v":"哈希索引","c":[{"t":"blockquote","d":5,"p":{},"v":"","c":[{"t":"paragraph","d":6,"p":{},"v":"可以提供高性能的读和写， 只要所有的key可以放入内存（因为hash map需要保存在内存中）"}]},{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"引入新的问题","c":[{"t":"list_item","d":8,"p":{},"v":"哈希表必须全部放入内存， 如果有大量的键， 就没那么幸运了。"},{"t":"list_item","d":8,"p":{},"v":"很难使磁盘上的hash map表现良好，需要大量的随机访问I/0。"},{"t":"list_item","d":8,"p":{},"v":"当哈希变满时，增长代价昂贵，并且哈希冲突时需要复杂的处理逻辑。"},{"t":"list_item","d":8,"p":{},"v":"区间查询效率不高。不能简单地扫描a和z区间内的所有键，只能采用逐个查找的方式查询每一个键。"}]}]},{"t":"heading","d":5,"p":{},"v":"总结","c":[{"t":"list_item","d":7,"p":{},"v":"使用限制，用作存储点击量，访问量"}]}]},{"t":"heading","d":4,"p":{},"v":"SSTable和 LSM-Tree","c":[{"t":"blockquote","d":5,"p":{},"v":"","c":[{"t":"paragraph","d":6,"p":{},"v":"<strong>键值对的序列按键排序</strong>。这就是<strong>SSTables（Sorted String Tables）</strong>的数据格式。我们还要求同一个key只会出现在一个段中。"}]},{"t":"heading","d":5,"p":{},"v":"SSTables优点：","c":[{"t":"list_item","d":7,"p":{"index":1},"v":"1. 合并段更简单。就像merge sort一样。"},{"t":"list_item","d":7,"p":{"index":2},"v":"2. 查找数据使用二分查找"},{"t":"list_item","d":7,"p":{"index":3},"v":"3. 压缩时，可以利用稀疏索引，降低了IO带宽。"}]},{"t":"heading","d":5,"p":{},"v":"构建和维护SSTables","c":[{"t":"list_item","d":7,"p":{"index":1},"v":"1. 在内存中保存一个排序结构，比如红黑树，AVL树。"},{"t":"list_item","d":7,"p":{"index":2},"v":"2. 在插入修改时候可以很快的响应。"},{"t":"list_item","d":7,"p":{"index":3},"v":"3. 可以顺序的读区它们。"}]},{"t":"heading","d":5,"p":{},"v":"存储引擎工作流程","c":[{"t":"list_item","d":7,"p":{"index":1},"v":"1. 写入时，将数据加入内存表中，可以是红黑树实现。"},{"t":"list_item","d":7,"p":{"index":2},"v":"2. 当内存中的红黑树大小超过阀值时，把它用SSTable的格式写入磁盘。"},{"t":"list_item","d":7,"p":{"index":3},"v":"3. 处理读请求时，先尝试查询内存表，如果miss就查询磁盘段文件s。"},{"t":"list_item","d":7,"p":{"index":4},"v":"4. 周期性的执行合并和压缩。丢弃被覆盖和删除的值。"}]},{"t":"heading","d":5,"p":{},"v":"实现LSM-Tree（Log-structured Merge-Tree）","c":[{"t":"list_item","d":7,"p":{},"v":"LevelDB，RocksDB，HBase， 都源于Google的BigTable论文。最初这个索引结构在早起的系统中被命名LSM-Tree。因此，基于合并和压缩的排序文件原理的存储引擎，通常都被称作LSM存储引擎。"},{"t":"list_item","d":7,"p":{},"v":"全文搜索，Lucene是ElasticSearch和Solr的索引引擎。采用了类似的方法保存字典。全文索引复杂的多，但想法类似。"}]},{"t":"heading","d":5,"p":{},"v":"性能优化","c":[{"t":"list_item","d":7,"p":{"index":1},"v":"1. 查询不存在的key时，会从内存开始扫描到磁盘的最后一个段。解决方法是，Bloom Filter。"},{"t":"list_item","d":7,"p":{"index":2},"v":"2. 压缩合并的时机。分为大小分级和分层压缩两个方法。一个是小的SSTables被连续合并到大的旧的SSTables。另一个是key的范围分裂成多个更小的SSTables，旧数据被移动到单独的层级。"}]},{"t":"heading","d":5,"p":{},"v":"总结","c":[{"t":"list_item","d":7,"p":{},"v":"由于数据是按照排序存储，因此可以高效的执行区间查询。"},{"t":"list_item","d":7,"p":{},"v":"因为磁盘是顺序写入的，LSM-Tree的写入吞吐量可以非常高。"}]}]},{"t":"heading","d":4,"p":{},"v":"B-trees索引","c":[{"t":"blockquote","d":5,"p":{},"v":"","c":[{"t":"paragraph","d":6,"p":{},"v":"应用最广泛的索引结构。和SSTable一样，B-tree保留按key排，也可以实现高效的范围查询。"},{"t":"paragraph","d":6,"p":{},"v":"B-tree将数据库分解成固定大小的块和页（4KB or more）。这种设计更接近底层硬件，因为磁盘也是固定大小的块的排列。"},{"t":"paragraph","d":6,"p":{},"v":"每个页可以用地址标志，是磁盘地址，而不是内存。这样可以用这些页面引用构造一个树状页面进行索引。索引的根是一个页面，之后的查找根据地址，读取相应的页。"},{"t":"paragraph","d":6,"p":{},"v":"分支因子：大多数数据库的索引适合3-4层的B-tree.因此不需要遍历非常深的页面层次即可找到所需的页。"},{"t":"bullet_list","d":6,"p":{},"v":"","c":[{"t":"list_item","d":7,"p":{},"v":"B树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；"},{"t":"list_item","d":7,"p":{},"v":"B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；"}]}]},{"t":"heading","d":5,"p":{},"v":"使B-tree可靠","c":[{"t":"list_item","d":7,"p":{},"v":"B-tree底层的基本操作是使用新数据覆盖磁盘的旧页。磁盘是覆盖扇区，对于SSD，擦除和重写的存储芯片块很大，情况更复杂。"},{"t":"list_item","d":7,"p":{},"v":"页面溢出，需要分裂页时，也要覆盖其父页对更新后的两个子页的引用。属于复杂操作。在完成更新前发生崩溃，可能会产生孤儿页面。"},{"t":"list_item","d":7,"p":{},"v":"崩溃恢复，使用redo Log。写数据之前先写日志。"},{"t":"list_item","d":7,"p":{},"v":"并发控制。"}]},{"t":"heading","d":5,"p":{},"v":"优化B-tree","c":[{"t":"list_item","d":7,"p":{"index":1},"v":"1. 一些数据库不是用覆盖页，而是做复制。"},{"t":"list_item","d":7,"p":{"index":2},"v":"2. 保存key的缩略信息而不是完整的key，来节省空间。只需要提供足够的信息来描述key的起止范围。"},{"t":"list_item","d":7,"p":{"index":3},"v":"3. 页可以存在磁盘的任何位置。可能回有随机的IO，而不是连续的。有些B-tree尝试实现对B-tree进行布局，但是随着树的增长，这个顺序会越来越难维护。"},{"t":"list_item","d":7,"p":{"index":4},"v":"4. 添加额外指针。左到右的指针，加速遍历。"}]}]},{"t":"heading","d":4,"p":{},"v":"对比B-tree, LSM-tree","c":[{"t":"blockquote","d":5,"p":{},"v":"","c":[{"t":"paragraph","d":6,"p":{},"v":"根据经验，LSM-Tree写入更快，而B-tree读更快。读取通常在LSM—Tree中较慢，因为要检查多个不同的数据结构和SSTables。"}]},{"t":"heading","d":5,"p":{},"v":"LSM-Tree优点","c":[{"t":"list_item","d":7,"p":{"index":1},"v":"1. LSM只写入一次数据（不考虑写放大（写入引起的压缩和合并）），而B-tree写入两次（一次redo log，一次数据本身）。"},{"t":"list_item","d":7,"p":{"index":2},"v":"2. LSM可以成熟比B-tree更大的吞吐量。有时具有较低的写放大，顺序写入速度快。"},{"t":"list_item","d":7,"p":{"index":3},"v":"3. 可以支持更好的压缩，文件比B-tree小很多。没有B-tree产生碎片的问题。"}]},{"t":"heading","d":5,"p":{},"v":"LSM-Tree缺点","c":[{"t":"list_item","d":7,"p":{"index":1},"v":"1. 响应延迟不确定，因为压缩和合并。"},{"t":"list_item","d":7,"p":{"index":2},"v":"2. 由于配置问题，会出现压缩跟不上写入速度的问题。来不及合并，直到磁盘空间不足。"},{"t":"list_item","d":7,"p":{"index":3},"v":"3. 事务支持不如B-tree"}]}]},{"t":"heading","d":4,"p":{},"v":"其他索引","c":[{"t":"heading","d":5,"p":{},"v":"在索引中存储值","c":[{"t":"paragraph","d":7,"p":{},"v":"索引中存储行或则行的具体位置（堆文件法）。将索引行直接存在索引中，聚集索引。MySQL的InnoDB存储引擎中，表的主键是聚集索引，二级索引引用主键。"}]},{"t":"heading","d":5,"p":{},"v":"多列索引","c":[{"t":"list_item","d":7,"p":{},"v":"级联索引，通过将一列追加到另一列，将几个字段组合成一个键。只能从前到后匹配。B-tree和LSM-tree都无法高效的应对这种查询。"},{"t":"list_item","d":7,"p":{},"v":"更常见的索引空间，R树。PostGIS使用PostgreSQL的广义搜索书索引实现了地理空间索引作为R树。"}]},{"t":"heading","d":5,"p":{},"v":"全文搜索和模糊索引","c":[{"t":"paragraph","d":7,"p":{},"v":"之前的搜索都是准确匹配，而不能应对类似的key的搜索，例如错误的拼写。"},{"t":"paragraph","d":7,"p":{},"v":"Lucene引擎支持在某个编辑距离内的模糊搜索。LevelDB中这个内存中的索引是一些key的稀疏集合。但在Lucene中，内存中的索引是key中的字符串序列的有限状态机，类似字典树。这个自动机可以转换成Leveshtein自动机，支持编辑距离内的搜索。"}]},{"t":"heading","d":5,"p":{},"v":"在内存中保存所有内容","c":[{"t":"list_item","d":7,"p":{},"v":"内存数据库。例如Memcached，做缓存。数据在重启后可以恢复。"},{"t":"list_item","d":7,"p":{},"v":"内存数据可以更快的原因，是因为它们可以避免使用写磁盘的格式对内存数据结构编码的开销。"},{"t":"list_item","d":7,"p":{},"v":"提供了给予磁盘索引难以实现的数据结构，例如Redis中的优先级队列和集合。"},{"t":"list_item","d":7,"p":{},"v":"可以使用反缓存的方法，当没有足够的内存时，将一部分不常用数据倒入磁盘，类似操作系统的虚拟内存。"},{"t":"list_item","d":7,"p":{},"v":"将来的NVM（non-volatile memory）技术广泛的普及，也可能很大的改变存储引擎的设计。"}]}]}]},{"t":"heading","d":3,"p":{},"v":"事务处理OLTP与分析处理OLAP","c":[{"t":"blockquote","d":4,"p":{},"v":"","c":[{"t":"paragraph","d":5,"p":{},"v":"事务意味着允许客户端进行低延迟读区和写入，相比于只能周期性的运行的批处理作业。事务不一定具有ACID属性。"},{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"OLTP每次返回<font color='red'>少量的数据</font>，随机访问，低延迟要求。"},{"t":"list_item","d":6,"p":{},"v":"OLAP对大量数据访问，批量导入（ETL）或事件流，内部分析师，为决策提供支持。"}]}]},{"t":"heading","d":4,"p":{},"v":"数据仓库","c":[{"t":"blockquote","d":5,"p":{},"v":"","c":[{"t":"paragraph","d":6,"p":{},"v":"数据仓库是一个单独的数据库，分析师可以在不影响OLTP的情况下，任意使用数据仓库。数据仓库包含公司所有OLTP数据库的只读副本。"},{"t":"paragraph","d":6,"p":{},"v":"单独使用数据仓库的优势在于数据仓库可以针对分析访问模式进行优化。本文前半部分讨论的索引模型只适合与OLTP而不适合做分析查询。"}]},{"t":"heading","d":5,"p":{},"v":"OLTP数据库和数据仓库的差异","c":[{"t":"list_item","d":7,"p":{},"v":"数据仓库也支持SQL查询接口，但是和OLTP的实现差异很大。"},{"t":"list_item","d":7,"p":{},"v":"一些数据库（SQL Server和SAP HANA）在同一产品中支持事务处理和数据仓库。然而，它们是两个独立的存储和查询引擎，只是通过一个SQL接口来访问。"},{"t":"list_item","d":7,"p":{},"v":"一些商用的数据仓库，Teradata，Vertica，SAP HANA等很贵。还有开源的基于Hadoop的SQL项目，例如Apache Hive，Spark SQL，Cloudera Impala，Facebook Presto，Apache Tajo和Apache Drill. 其中一些是基于Google Dremel而构建的。"}]}]},{"t":"heading","d":4,"p":{},"v":"星型与雪花型分析模式","c":[{"t":"blockquote","d":5,"p":{},"v":"","c":[{"t":"paragraph","d":6,"p":{},"v":"许多数据仓库都使用了星型模式，也称为维度建模。"},{"t":"paragraph","d":6,"p":{},"v":"这种模式的中心是一个所谓的事实表。事实表的每一行表示在特定时间发生的事件。"}]},{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"通常，事实被捕获为单独的事件，这样之后的分析具有很大的灵活性。"},{"t":"list_item","d":6,"p":{},"v":"事实表中的列是属性，其他列可能会引用其他表的外键，成为维度表，这些维度代表事件的发生地点，时间，方式和原因。"},{"t":"list_item","d":6,"p":{},"v":"名称<strong>星型模式</strong>来源于关系表可视化的适合，事实表位于中间，被一系列维度表包围。"},{"t":"list_item","d":6,"p":{},"v":"该模型的一个变体成为<strong>雪花模型</strong>，其中维度进一步细分为子空间。例如，dimproduct表中的每一行可以再次向外引用品牌和类型的外键。这样更规范，但是更复杂。分析人员一般首选星型。"},{"t":"list_item","d":6,"p":{},"v":"典型的数据仓库中，表都非常宽，事实表通常超过100列，甚至几百列。维度表也可能很宽。"}]}]}]},{"t":"heading","d":3,"p":{},"v":"列式存储","c":[{"t":"ordered_list","d":4,"p":{"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"index":1},"v":"1. 主要关注事实表的海量数据问题，通常有万亿行、PB级别的数据。"},{"t":"list_item","d":5,"p":{"index":2},"v":"2. 虽然通常事实表超过100列，但是一般一次分析也只会访问其中的4，5列。如何高效的执行这中类型的查询？"},{"t":"list_item","d":5,"p":{"index":3},"v":"3. OLTP系统中，数据库的存储都是面向行的。如果属性超过100列，那么需要把很多不需要的数据读入内存，然后丢弃。非常低效。"},{"t":"list_item","d":5,"p":{"index":4},"v":"4. 面向列存储，不是将一行的内容存在一起，而是把每一列的所有值存在一起。"}]},{"t":"heading","d":4,"p":{},"v":"列压缩","c":[{"t":"blockquote","d":5,"p":{},"v":"","c":[{"t":"paragraph","d":6,"p":{},"v":"面向列的存储非常适合压缩。一种技术是位图编码。"}]},{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"每一个不同的值一个位图，位图的位数是行数。"},{"t":"list_item","d":6,"p":{},"v":"Bigtable模型仍然主要是面向行的。"}]},{"t":"heading","d":5,"p":{},"v":"内存带宽和矢量化处理","c":[{"t":"list_item","d":7,"p":{},"v":"除了减少需要从磁盘加载的数据量之外，列存储也有利于高效利用CPU的周期性。"}]}]},{"t":"heading","d":4,"p":{},"v":"列存储中的排序","c":[{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"列的存储如果是按照某个常见的顺序，例如date，就可以做类似于SSTables的索引机制。注意单独排序某列没用，需要正行排序。"}]},{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"另一个好处是可以进行压缩。可以进行游程编码，位图那样。"}]},{"t":"heading","d":5,"p":{},"v":"几种不同的排序","c":[{"t":"list_item","d":7,"p":{"index":1},"v":"1. C-Store的改进。用不同的方式存储相同的数据。使不同的排序查询都获益。也就是通过排序后的冗余数据加速。"},{"t":"list_item","d":7,"p":{"index":2},"v":"2. 列排序，类似于面向行的二级索引。区别是，列的索引中，存的是值而不是地址。"}]}]},{"t":"heading","d":4,"p":{},"v":"列存储与写操作","c":[{"t":"list_item","d":6,"p":{},"v":"上述的优化，都是对读的优化，这会让写变得更困难。类似B-tree的就地更新的操作，对压缩列是不可能的。"},{"t":"list_item","d":6,"p":{},"v":"一个方案是类似LSM-tree。先写入内存的排序数据结构，然后在一定的时候把内存的数据顺序的倒入磁盘，接着进行有可能的文件合并。这样查询的时候需要检查内存中的数据，和磁盘中的数据。这对于查询方是透明的。"}]},{"t":"heading","d":4,"p":{},"v":"聚合：数据立方体和物化视图","c":[{"t":"list_item","d":6,"p":{},"v":"数据仓库不是一定要用列存储的。但是列存储因为查询分析更快，所以正在迅速普及。数据仓库另一个方面是物化聚合，就是把常用的查询物理存储化，缓存一些查询结果。"},{"t":"list_item","d":6,"p":{},"v":"实现：物化视图。 物化视图的常见特例称为数据立方体或OLAP立方。它是按不同维度分组的聚合网格。以沿着每行或每列应用相同的汇总，并获得一个维度减少的汇总（按产品的销售额，无论日期，还是按日期销售，无论产品如何）。"},{"t":"list_item","d":6,"p":{},"v":"缺点是数据立方体不具有查询原始数据的灵活性。因此，大多数数据仓库试图保留尽可能多的原始数据，并将聚合数据（如数据立方体）仅用作某些查询的性能提升。"}]}]}]},{"t":"heading","d":2,"p":{},"v":"第9章 一致性与共识","c":[{"t":"blockquote","d":3,"p":{},"v":"","c":[{"t":"paragraph","d":4,"p":{},"v":"分布式最庸的抽象之一就是共识： 所有的节点就某一项提议达成一致."}]},{"t":"heading","d":3,"p":{},"v":"可线性化","c":[{"t":"blockquote","d":4,"p":{},"v":"","c":[{"t":"paragraph","d":5,"p":{},"v":"也称为原子一致性， 强一致性。"},{"t":"paragraph","d":5,"p":{},"v":"其基本的想法是让一个系统看起来好像只有一个数据副本， 且所有的操作都是原子的。有了这个保证， 应用程序就不需要关心系统内部的多个副本。"}]},{"t":"heading","d":4,"p":{},"v":"如何达到线性化？","c":[{"t":"blockquote","d":5,"p":{},"v":"","c":[{"t":"paragraph","d":6,"p":{},"v":"可线性化背后的基本思想很简单：使系统看起来好像只有一个数据副本。"}]},{"t":"blockquote","d":5,"p":{},"v":"","c":[{"t":"paragraph","d":6,"p":{},"v":"<strong>可线性化与可串行化</strong>"},{"t":"bullet_list","d":6,"p":{},"v":"","c":[{"t":"list_item","d":7,"p":{},"v":"可串行化"}]},{"t":"paragraph","d":6,"p":{},"v":"可串行化是事务的隔离属性， 其中每个事务可以读写多个对象（行， 文档， 记录等。它用来确保事务执行的结果<font color='red'>与串行执行（即每次执行一个事务）的结果完全相同</font>， 即使串行执行的顺序可能与事务实际执行顺序不同 。"},{"t":"bullet_list","d":6,"p":{},"v":"","c":[{"t":"list_item","d":7,"p":{},"v":"可线性化"}]},{"t":"paragraph","d":6,"p":{},"v":"可线性化是<font color='red'>读写寄存器（单个对象）的最新值保证</font>。它并不要求将操作组合到事务中， 因此无法避免写倾针等问题 除非采取其他额外措施。"}]}]},{"t":"heading","d":4,"p":{},"v":"线性化的依赖条件","c":[{"t":"list_item","d":6,"p":{},"v":"加锁与主节点选取"},{"t":"list_item","d":6,"p":{},"v":"约束与唯一性保证"},{"t":"list_item","d":6,"p":{},"v":"跨通道的时间依赖"}]},{"t":"heading","d":4,"p":{},"v":"实现线性化系统","c":[{"t":"bullet_list","d":5,"p":{},"v":"","c":[{"t":"list_item","d":6,"p":{},"v":"主从复制（部分支持可线性化）"},{"t":"list_item","d":6,"p":{},"v":"共识算法（可线性化）"},{"t":"list_item","d":6,"p":{},"v":"多主复制（不可线性化）"},{"t":"list_item","d":6,"p":{},"v":"无主复制（可能不可线性化）"}]},{"t":"heading","d":5,"p":{},"v":"线性化与 quorum"}]},{"t":"heading","d":4,"p":{},"v":"线性化的代价","c":[{"t":"heading","d":5,"p":{},"v":"CAP 理论"}]}]}]}]})</script>
</body>
</html>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/09/10/notepad/algorithm/limter/README/</url>
    <content><![CDATA[<hr>
<h2 id="limter"><a href="#limter" class="headerlink" title="limter"></a>limter</h2><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p><img src="assert/rate-limit1.png" alt="image"></p>
<p>生动形象，容易理解， 往桶里加水的速度大于漏水的速度就超速了， 桶大小表示最大速度大小</p>
<p>缺点： 只能匀速处理， 不能并发处理， 虽然可以一下往桶里加水， 但速度取决于漏水速度</p>
<h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><blockquote>
<ul>
<li>每秒会有 r 个令牌放入桶中，或者说，每过 1/r 秒桶中增加一个令牌</li>
<li>桶中最多存放 b 个令牌，如果桶满了，新放入的令牌会被丢弃</li>
<li>当一个 n 字节的数据包到达时，消耗 n 个令牌，然后发送该数据包</li>
<li>如果桶中可用令牌小于 n，则该数据包将被缓存或丢弃</li>
</ul>
</blockquote>
<p>缺点： 可能出现某一个时间段出现超频！（停止一段时间后突然拿掉桶里的所有token， 后面还会慢慢拿， 因此这里超速了）</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>在窗口内有固定的请求数， 可以处理并发。</p>
<p>缺点：<strong>速度最大时</strong> 不能处理高并发时的匀速请求， 都是像分批一样分发token的，有点像 tcp 一下分发出去很多包，这样对于不是临界的值不公平， 运行 <a class="link"   href="https://github.com/Fierygit/cxxstudy/blob/master/algorithm/limter/token_limter.cc" >code<i class="fas fa-external-link-alt"></i></a> 查看</p>
<h3 id="结合实现（-令牌桶-滑动窗口-）"><a href="#结合实现（-令牌桶-滑动窗口-）" class="headerlink" title="结合实现（ 令牌桶 + 滑动窗口 ）"></a>结合实现（ 令牌桶 + 滑动窗口 ）</h3><p>既可以处理并发， 又可以让任意一个时间段不超速！</p>
<p><a class="link"   href="https://github.com/Fierygit/cxxstudy/blob/master/algorithm/limter/rate_limter.cc" >code<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/09/10/notepad/cxx/grammar/class/README/</url>
    <content><![CDATA[<p>problems:</p>
<h3 id="1、-含有继承的类的初始化顺序是什么？"><a href="#1、-含有继承的类的初始化顺序是什么？" class="headerlink" title="1、 含有继承的类的初始化顺序是什么？"></a>1、 含有继承的类的初始化顺序是什么？</h3><h3 id="2、-一个类的构建过程，-详细说？"><a href="#2、-一个类的构建过程，-详细说？" class="headerlink" title="2、 一个类的构建过程， 详细说？"></a>2、 一个类的构建过程， 详细说？</h3><h3 id="3、-为什么构造函数不能写成虚函数？"><a href="#3、-为什么构造函数不能写成虚函数？" class="headerlink" title="3、 为什么构造函数不能写成虚函数？"></a>3、 为什么构造函数不能写成虚函数？</h3><h3 id="4、-为什么析构函数要写成虚函数？"><a href="#4、-为什么析构函数要写成虚函数？" class="headerlink" title="4、 为什么析构函数要写成虚函数？"></a>4、 为什么析构函数要写成虚函数？</h3><h3 id="5、-早期绑定和后期绑定（java-中-静态分派（dispatch）和动态分配）"><a href="#5、-早期绑定和后期绑定（java-中-静态分派（dispatch）和动态分配）" class="headerlink" title="5、 早期绑定和后期绑定（java 中 静态分派（dispatch）和动态分配）"></a>5、 早期绑定和后期绑定（java 中 静态分派（dispatch）和动态分配）</h3><h3 id="6、-虚函数原理是什么，-为什么需要虚函数"><a href="#6、-虚函数原理是什么，-为什么需要虚函数" class="headerlink" title="6、 虚函数原理是什么， 为什么需要虚函数"></a>6、 虚函数原理是什么， 为什么需要虚函数</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/06/notepad/read/network/%E6%A0%91/</url>
    <content><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h5 id="面试题-04-06-后继者"><a href="#面试题-04-06-后继者" class="headerlink" title="面试题 04.06. 后继者"></a>面试题 04.06. 后继者</h5><blockquote>
<p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">    TreeNode * ans =<span class="literal">nullptr</span>;     </span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= p-&gt;val) root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span>  ans = root,root = root-&gt;left; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a>173. 二叉搜索树迭代器</h5><blockquote>
<p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p>
<p>调用 <code>next()</code> 将返回二叉搜索树中的下一个最小的数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        ldfs(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ldfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        st.emplace(root);</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode* root = st.top(); st.pop();</span><br><span class="line">    ldfs(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题就是前序和中序遍历二叉树的非递归版本的差分版。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/06/notepad/read/network/%E8%AE%A1%E7%BD%91%E6%9D%82%E5%BD%95/</url>
    <content><![CDATA[<h3 id="tcp学习笔记"><a href="#tcp学习笔记" class="headerlink" title="tcp学习笔记"></a>tcp学习笔记</h3><p>TCP 连续发 10 个包， 客户端会收到什么消息？</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/tcptest.png"></p>
<h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/fuck.png" alt="image-20200405105204612"></p>
<p>3.1 环回地址必须是1 2 7 . 0 . 0 . 1吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不，任何网络 I D 为1 2 7 的A类地址都是可行的，尽管大多数系统使用了1 2 7 . 0 . 0 . 1。</span><br></pre></td></tr></table></figure>

<p>3.2 在图3 - 6中指出有两个网络接口的路由器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k p n o有5个接口：3个点对点链路和2 个以太网接口。R 1 0有4个以太网接口。</span><br><span class="line">g a t e w a y有3个接口： 2个点对点链路和1 个以太网接口。</span><br><span class="line">最后， n e t b有1个以太网接口和2个点对点链路。</span><br></pre></td></tr></table></figure>

<p>3.3 子网号为16 bit的A类地址与子网号为8 bit 的B类地址的子网掩码有什么不同？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">没有区别：作为一个没有再区分子网的C类地址，它们都有一个2 5 5 . 2 5 5 . 2 5 5 . 0的子网掩</span><br><span class="line">码。</span><br></pre></td></tr></table></figure>

<p>3.4 阅读RFC 1219 [Tsuchiya 1991]，学习分配子网号和主机号的有关推荐技术。</p>
<p>3.5 子网掩码2 5 5 . 2 5 5 . 0 . 2 5 5是否对A类地址有效？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">它是合法的，被称为非连续的子网掩码，因为其用于子网掩码的1 6位是不连续的。但是</span><br><span class="line">R F C建议反对使用非连续的子网掩码。</span><br></pre></td></tr></table></figure>

<p>3.6 你认为为什么3 . 9小节中打印出来的环回接口的M T U要设置为1 5 3 6？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个历史遗留问题。值是1 0 2 4＋5 1 2，但是打印的M T U值包含了所有需要的首部字</span><br><span class="line">节数。Solaris 2.2将回环接口的M T U设置为8 2 3 2（8 1 9 2＋4 0），其中包含了8 1 9 2字节的用</span><br><span class="line">户数据加上2 0字节的I P首部和2 0字节的T C P首部。</span><br></pre></td></tr></table></figure>

<p>3.7 T C P / I P协议族是基于一种数据报的网络技术，即I P层，其他的协议族则基于面向连接的<br>网络技术。阅读文献[Clark 1988]，找出数据报网络层提供的三个优点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一，数据报降低了路由器中对于连接状态的需求。第二，数据报提供了基本的构件，</span><br><span class="line">在它的上面可以构造不可靠的（ U D P）和可靠的（ T C P）的运输层。第三，数据报代表</span><br><span class="line">网络总数了最小的网络层假定，使得可以使用很大范围的数据链路层服务。</span><br></pre></td></tr></table></figure>







<p>17.1 我们已经介绍了以下几种分组格式： I P、I C M P、I G M P、U D P和T C P。每一种格式的首<br>部中均包含一个检验和。对每种分组，说明检验和包括I P数据报中的哪些部分，以及该<br>检验和是强制的还是可选的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">除了U D P的检验和，其他都是必需的。I P检验和只覆盖了I P首部，而其他字段都紧接着</span><br><span class="line">I P首部开始。</span><br></pre></td></tr></table></figure>

<p>17.2 为什么我们已经讨论的所有I n t e r n e t协议（I P, ICMP, IGMP, UDP, TCP）收到有检验和错<br>的分组都仅作丢弃处理？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">源I P地址、源端口号或者协议字段可能被破坏了。</span><br></pre></td></tr></table></figure>

<p>17.3 T C P提供了一种字节流服务，而收发双方都不保持记录的边界。应用程序如何提供它们<br>自己的记录标识？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">很多I n t e r n e t应用使用一个回车和换行来标记每个应用记录的结束。这是NVT ASCII采</span><br><span class="line">用的编码。另外一种技术是在每个记录之前加上一个记录的字节计数， D N S</span><br><span class="line">（习题1 4 . 4）和Sun RPC（2 9 . 2节）采用了这种技术。</span><br></pre></td></tr></table></figure>

<p>17.4 为什么在T C P首部的开始便是源和目的的端口号？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 就像我们在6 . 5节所看到的，一个 ICMP 差错报文必须至少返回引起差错的I P数据报中除了</span><br><span class="line">I P首部的前8 个字节。当T C P收到一个I C M P差错报文时，它需要检查两个端口号以决定差</span><br><span class="line">错对应于哪个连接。因此，端口号必须包含在T C P首部的前8个字节里。</span><br></pre></td></tr></table></figure>

<p>17.5 为什么T C P首部有一个首部长度字段而U D P首部（图11 - 2）中却没有？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP首部的最后有一些选项，但U D P首部中没有选项。</span><br></pre></td></tr></table></figure>



<h3 id="TCP连接的建立与终止"><a href="#TCP连接的建立与终止" class="headerlink" title="TCP连接的建立与终止"></a>TCP连接的建立与终止</h3>]]></content>
  </entry>
  <entry>
    <title>ssh配置公钥</title>
    <url>/2019/10/27/notepad/read/others/ssh%E9%85%8D%E7%BD%AE%E5%85%AC%E9%92%A5/</url>
    <content><![CDATA[<h1 id="ssh的使用"><a href="#ssh的使用" class="headerlink" title="ssh的使用"></a>ssh的使用</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ssh连接服务器是经常要操作的步骤，可当每次都要手动输入 <code>ssh user@ip </code> ，然后加上密码连接可谓是及其地麻烦，虽然有xs的记录密码，但当要将服务器分享给他人时，为了方便别人，可以配置公钥，配好后对方直接使用ssh username，就可以直接连上，密码都不用输入。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><a id="more"></a>
<p>。。。 不会，</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="pc端"><a href="#pc端" class="headerlink" title="pc端"></a>pc端</h3><p>要使用vps的pc端，cmd输入    <code> ssh-keygen -t rsa</code>，如果已经创建过就不用了，直接下两步，不然之前配的秘钥就换了，比如git配置的ssh密码。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh1.jpg"></p>
<p>这里我就不创建了，创建好按照提示进入创建的目录,一般默认就行，在用户目录下。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh2.jpg"></p>
<p>新建一个 config文件</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh3.jpg"></p>
<p>注意是没有后缀的</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh4.jpg"></p>
<p>其中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host 为服务器别名,取一个方便记的</span><br><span class="line">HostName 为服务器域名(ip)</span><br><span class="line">User 为登录的账号</span><br></pre></td></tr></table></figure>

<p>pc端操作完毕！</p>
<h3 id="vps"><a href="#vps" class="headerlink" title="vps"></a>vps</h3><p>终端输入    <code> ssh-keygen -t rsa</code>   , 回车回车回车。。。。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/sshshiyong.jpg"></p>
<p><code>ls -a</code> 可以查看到有一个 .ssh文件夹</p>
<p>进入,将刚才pc端创建的  id_ras.pub 放到 到 authorized_keys文件里面。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh5.jpg"></p>
<p>搞定！！！ </p>
<p>之后直接在cmd里输入 <code>ssh Host (为服务器别名,取一个方便记的)</code>就可以直接连上，不用输入密码。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh6.jpg"></p>
<p>配合vscode的ssh连接，简直不能再方便了！！！！</p>
<p>只要需要三步，就可以直接键代码跑到服务器，像操作自己的电脑一样，真的真的真的太太太太太方便了，谁用谁会爱上它！！！！！（当然vscode要下插件）</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh7.jpg"></p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>windows的脚本命令一件部署后端服务</title>
    <url>/2019/09/11/notepad/read/others/windows%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%90%8E%E7%AB%AF/</url>
    <content><![CDATA[<h4 id="windows的脚本命令一件部署后端服务"><a href="#windows的脚本命令一件部署后端服务" class="headerlink" title="windows的脚本命令一件部署后端服务"></a>windows的脚本命令一件部署后端服务</h4><p> 实习一个月了，其中有许多有意思的东西希望能记住一些小技巧，今天想记录的是，花了一个下午才研究通透的一个windows脚本命令。</p>
<h2 id="一，BAT命令简要说明"><a href="#一，BAT命令简要说明" class="headerlink" title="一，BAT命令简要说明"></a>一，BAT命令简要说明</h2><p>  这个是windows的批处理文件，在这里可以这接写dos命令，一些恶意小程序就是可以在这里写，和linux的sh不同是，不用给文件赋予权限，bat只需要，把后缀改为bat就行了，其实windwos部署服务很少，习惯了linux，突然用dos感觉好不习惯。</p>
<ul>
<li><p>首先是注释  ：：  两个冒号代表注释一行，为了防止写着脚本自己写到哪里了都不知道，注释还是有作用的。<br><img src="https://img-blog.csdnimg.cn/20190808105234421.png" alt="在这里插入图片描述"></p>
</li>
<li><p>  goto  :next</p>
<pre><code>`echo &#39;pull sucess!&#39;
`echo &#39;pull sucess!&#39;
:next

  上面的goto语句是跳过中间的两个命令， 简洁明了</code></pre>
</li>
<li><p>echo off<br>  如果不想要每次都显示路径这个就可以只显示执行的情况。所以一般开头加一句</p>
</li>
<li><p> call  </p>
<pre><code>  这个命令值得注意下，如果在bat命令中调用了其它的bat，其它bat里面运行完一般会有退出命令，所以，如果不想在调用了其它命令后退出，就call 这个命令。比如说mvn命令，这个调用了之后运行完会直接退出，所以加个call</code></pre>
</li>
</ul>
<h2 id="二，流程"><a href="#二，流程" class="headerlink" title="二，流程"></a>二，流程</h2><ol>
<li><p> ::先随便到一个目录，把该目录下的jcSrc  保存<br>cd  E:\jc<br>::Q表示不显示文件名C错误也复制E所有子目录Y不提示覆盖<br>xcopy  E:\jc\jcSrc  E:\jc\jcSrcHistory/E/C/Y/Q<br>解释：此命令只是把先前的src复制一遍存起来</p>
</li>
<li><p>cd jcSrc<br>git pull origin master<br>echo ‘pull sucess!’<br>解释：上面的三条脚本在bash测试成功后放到这里，Git拉取src，git还要配置环境变量</p>
</li>
<li><p>::mvn打包<br>cd   E:\jc\jcSrc\common<br>call mvn clean compile<br>call mvn clean package<br>echo ‘mvn package success’<br>这个也要配置环境变量</p>
</li>
<li><p>::删除原来的包,注意改名jar<br>cd  E:\jc\jcJar<br>rd/s/q    common-0.0.1-SNAPSHOT.jar<br>echo ‘delete success！’<br>写到这里想起差点把我的一个大文件给删了。 注意注意注意</p>
</li>
<li><p>::将打包好的jar包复制到jcJar中<br>xcopy  E:\jc\jcSrc\common\target\common-0.0.1-SNAPSHOT.jar  E:\jc\jcJar/E/C/Y/Q<br>echo ‘copy jar success’</p>
</li>
<li><p>set port=8092<br>for /f “tokens=1-5” %%i in (‘netstat -ano^|findstr “:%port%”‘) do taskkill /F /pid %%m<br>echo ‘delete port success’<br>解释：这一步很重要，先要删除端口，很高兴在网上找到了删除端口对应程序的代码，在2008里面既然不能用，后来发现，是这个脚本命令不能换行。不然换行写多舒服！</p>
</li>
<li><p>::运行<br>cd  E:\jc\jcJar<br>java -jar common-0.0.1-SNAPSHOT.jar –server.port=8092<br>echo ‘如果你在运行的时候看到我,就说明启动失败啦!!!,上面的某一条命令没有执行成功’<br>echo ‘success!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!’<br>pause<br>解释：</p>
<pre><code>     1.因为java -jar  运行后端服务是持续的，所以后面的echo是要等到java运行完才打印的，如果没有启动成功，才会打印，=
     2.还是因为这是2008的上古神机windows版本，所以用了java命令，如果是window10，可以直接用javaw， 命令，这个命令可以让jar在后台执行。</code></pre>
</li>
</ol>
<p>最后来一个全的</p>
<pre><code>::先随便到一个目录，把该目录下的jcSrc  保存
cd  E:\jc
::Q表示不显示文件名C错误也复制E所有子目录Y不提示覆盖
xcopy  E:\jc\jcSrc  E:\jc\jcSrcHistory/E/C/Y/Q

echo &#39;copy sucess!&#39;

cd jcSrc
git pull origin master
echo &#39;pull sucess!&#39;


::mvn 打包
cd   E:\jc\jcSrc\common
call mvn clean compile
call mvn clean package
echo &#39;mvn package success&#39;


::删除原来的包,注意改名jar
cd  E:\jc\jcJar
rd/s/q    common-0.0.1-SNAPSHOT.jar
echo ‘delete success！’

::将打包好的jar包复制到jcJar中

xcopy  E:\jc\jcSrc\common\target\common-0.0.1-SNAPSHOT.jar  E:\jc\jcJar/E/C/Y/Q
echo &#39;copy jar success&#39;


set port=8092
for /f &quot;tokens=1-5&quot; %%i in (&#39;netstat -ano^|findstr &quot;:%port%&quot;&#39;) do taskkill /F /pid %%m

echo &#39;delete port success&#39;

::运行
cd  E:\jc\jcJar
java -jar common-0.0.1-SNAPSHOT.jar --server.port=8092
echo &#39;如果你在运行的时候看到我,就说明启动失败啦!!!,上面的某一条命令没有执行成功&#39;
echo &#39;success!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&#39;

pause</code></pre>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器自动拉取git脚本</title>
    <url>/2019/10/01/notepad/read/others/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96Git%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="linux-自动运行脚本代码"><a href="#linux-自动运行脚本代码" class="headerlink" title="linux 自动运行脚本代码"></a>linux 自动运行脚本代码</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Blog每次提交到git的时候，都要上服务器拉取一下，而且每次执行相同的操作，这种机械的操作机器是最擅长的，于是乎，上网查了，git可以使用hooks，在push了代码后，自动先向务器发出post请求，然后让服务器更新代码，尝试了一下，php文件不是很会，于是另寻它径。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>既然php程序不会写，那就直接写sh， 然后让crontab定时器，每分钟更新一遍代码！！！</p>
<p>首先写一个sh文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo off</span><br><span class="line">cd &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;firefly&#x2F;</span><br><span class="line">echo &#39;opened&#39;</span><br><span class="line"></span><br><span class="line">git pull # 拉取代码</span><br><span class="line"></span><br><span class="line">echo &#39;success&#39;</span><br></pre></td></tr></table></figure>

<p>然后使用定时器，每分钟执行一遍代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; crontab -e   # 进入编辑模式</span><br><span class="line">输入：</span><br><span class="line"> *&#x2F;1 * * *  &#x2F;root&#x2F;deploy.sh   # 这里是要执行的脚本</span><br></pre></td></tr></table></figure>


<p>执行<code>cd /var/log/</code>查看执行的指令</p>
<p><code>tail -n 3 /var/log/cron</code>这个可以看到一点输出</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派入坑之旅</title>
    <url>/2019/10/17/notepad/read/others/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="树莓派使用"><a href="#树莓派使用" class="headerlink" title="树莓派使用"></a>树莓派使用</h1><h2 id="树莓派的安装"><a href="#树莓派的安装" class="headerlink" title="树莓派的安装"></a>树莓派的安装</h2><p>1、安装Win32DiskImager-0.9.5-install.exe到电脑上。</p>
<p>解压2019-06-20-raspbian-buster-full.zip，打开此软件，选择官方系统img，选择SD卡的盘符，这里不能选错，否则会被格式化，如下图配置。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/shumeipai1.jpg"></p>
<p>2、选择Write进行烧录，等待烧录完成，拔掉SD卡，插入树莓派上电，系统会自动安装完成。</p>
<p>3、注意烧录完成后，win系统可能会因为无法识别Linux分区格式而提示用户格式化，此时不要点格式化！不要点格式化！不要点格式化！直接点取消就可以了。如果点了格式化，树莓派会因为丢失系统文件而无法开机，需要重新烧录IMG镜像文件。</p>
<p>4、安装完后添加显示器的配置文件，树莓派的小册子里有</p>
<p>开机搞定！！！！</p>
<h2 id="frp实现内网穿透"><a href="#frp实现内网穿透" class="headerlink" title="frp实现内网穿透"></a>frp实现内网穿透</h2><p>使用frp内网穿透控制家里的树莓派，这样即便在外面也可以随时控制树莓派，也可以让其他人操控树莓派。</p>
<p>需要用到的工具：</p>
<ul>
<li>树莓派</li>
<li>一台vps</li>
<li>树莓派摄像头</li>
<li>手</li>
</ul>
<p>首先，你需要分别在vps、树莓派上下载frp</p>
<p>你也可以自行前往GitHub下载<br><a class="link"   href="https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_386.tar.gz" >https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_386.tar.gz<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><p>首先是在vps上进行操作，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.29.0&#x2F;frp_0.29.0_linux_386.tar.gz</span><br><span class="line">tar zxvf frp_0.29.0_linux_386.tar.gz</span><br><span class="line">cd frp_0.29.0_linux_386</span><br><span class="line">vim frps.ini</span><br></pre></td></tr></table></figure>

<hr>
<p>在vps中修改解压出来的frps.ini文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"># 用于连接的端口bind_port &#x3D; 7000</span><br><span class="line"># 控制板端口dashboard_port &#x3D; 7500</span><br><span class="line"># 控制板登陆账号dashboard_user &#x3D; dashboard_user_name</span><br><span class="line"># 控制板登陆密码dashboard_pwd &#x3D; dashboard_pwd_value</span><br></pre></td></tr></table></figure>

<p>配置完成后，使用以下命令启动服务端的frp。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frps -c .&#x2F;frps.ini</span><br></pre></td></tr></table></figure>

<p>推荐设置开机自启动，方法：在 /etc/rc.local 添加上述命令行</p>
<p>然后即可访问 vps的ip:您设置的端口</p>
<hr>
<h3 id="树莓派"><a href="#树莓派" class="headerlink" title="树莓派"></a>树莓派</h3><p>接着就是树莓派上的设置，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.29.0&#x2F;frp_0.29.0_linux_arm.tar.gz</span><br><span class="line">tar zxvf frp_0.29.0_linux_arm.tar.gz</span><br><span class="line">cd frp_0.29.0_linux_arm</span><br><span class="line">vim frpc.ini</span><br></pre></td></tr></table></figure>

<hr>
<p>进行如下修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"># 你的服务器的IP、frps端口server_addr &#x3D; 你的vps的IP地址server_port &#x3D; 7000</span><br><span class="line">[ssh]</span><br><span class="line"># 需要被穿透的服务、本地ip、本地端口</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line"># 使用服务器的哪个端口进行穿透访问，记得打开防火墙</span><br><span class="line">remote_port &#x3D; 10023</span><br></pre></td></tr></table></figure>

<hr>
<p>启动frp客户端服务(建议添加到 /etc/rc.local 实现开机自启动)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure>

<p>测试一下是否成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -pi@ip -p 10023</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/shumeipai2.png"></p>
<p>成功啦！！！！</p>
<h2 id="rmtp推流到"><a href="#rmtp推流到" class="headerlink" title="rmtp推流到"></a>rmtp推流到</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>树莓派连在局域网，因此需要一台公网的服务器，pi使用ffmpeg推流到服务器，服务器监听这个流传播出去，然后推给虎牙，在虎牙上面查看流。</p>
<p>所以大致分为三步：</p>
<h4 id="1、服务器"><a href="#1、服务器" class="headerlink" title="1、服务器"></a>1、服务器</h4><p>​    这一步是最麻烦的，大致思路如下，首先你得安装nginx， 然后还有rmtp模块。</p>
<p><a class="link"   href="https://cloud.tencent.com/developer/article/1145657" >https://cloud.tencent.com/developer/article/1145657<i class="fas fa-external-link-alt"></i></a></p>
<p> <a class="link"   href="https://blog.csdn.net/sz76211822/article/details/79225716" >https://blog.csdn.net/sz76211822/article/details/79225716<i class="fas fa-external-link-alt"></i></a> </p>
<p>网上有很多很多的教程，也有直接配rmtp的教程，然并卵，要么这个有问题，要么那个有问题，但是没关系，先安装<strong>要用到的模块</strong>，慢慢试，一个一个试，总有一个是可以 nginx 运行成功的！！！</p>
<p> 接着就是配置文件的设置，这一步最关键，一个教程有一个方法，真的是服了，还好DMFer，找到了rmtp模块里头的README， README多言简意赅， 先读我！！！</p>
<p><a class="link"   href="https://github.com/arut/nginx-rtmp-module/blob/master/README.md?tdsourcetag=s_pctim_aiomsg" >README<i class="fas fa-external-link-alt"></i></a></p>
<p>按照里面给的例子，配置， and then cuccess！！！</p>
<p><strong>有些坑不踩过，是跳不过的。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtmp:&#x2F;&#x2F;119.3.239.133:1935&#x2F;hls ^_^</span><br></pre></td></tr></table></figure>



<h4 id="2、-pi"><a href="#2、-pi" class="headerlink" title="2、 pi"></a>2、 pi</h4><p>pi其实没有什么好设置的，只需要打开摄像头（百度），然后就是ffmpeg推流到服务器设置好的那个端口上就行！所以还得百度ffmpeg安装。</p>
<p>最简单的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i &#x2F;dev&#x2F;video0 -b:v 800k  -f flv rtmp:&#x2F;&#x2F;119.3.239.133:1935&#x2F;hls</span><br></pre></td></tr></table></figure>

<p>带点参数的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &#x2F;dev&#x2F;video0 -c:v libx264 -preset ultrafast  -acodec libmp3lame -ar 44100 -ac 1  -f flv rtmp:&#x2F;&#x2F;119.3.239.133:1935&#x2F;hls</span><br></pre></td></tr></table></figure>

<p>每条指令参数什么意思呢？搜索本站 ffmpeg，然后对应搜索每一个参数！</p>
<h4 id="3、-获取"><a href="#3、-获取" class="headerlink" title="3、 获取"></a>3、 获取</h4><p>这一步在服务器上操作，把rmtp转换为html的界面！</p>
<p><a class="link"   href="http://shumeipai.nxez.com/2017/11/01/build-rtmp-stream-live-server-with-raspberry-pi.html?tdsourcetag=s_pctim_aiomsg" >教程<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="mipg-streaming"><a href="#mipg-streaming" class="headerlink" title="mipg-streaming"></a>mipg-streaming</h2><p><a class="link"   href="http://shumeipai.nxez.com/2017/05/14/raspberry-pi-mjpg-streamer-installation.html" >http://shumeipai.nxez.com/2017/05/14/raspberry-pi-mjpg-streamer-installation.html<i class="fas fa-external-link-alt"></i></a></p>
<p>先放一下教程，听同学说很卡，不打算尝试</p>
<h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><h3 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h3><p>要用它来拍摄照片的话，可以从命令行运行raspistill：</p>
<p><code> raspistill -o keychain.jpg -t 2000</code> </p>
<p>这句命令将在 2000ms 后拍摄一张照片，然后保存为 keychain.jpg。</p>
<p>raspiyuv 工具用法差不多，只不过拍摄得到的是一张未处理过的raw图像。</p>
<h3 id="摄像"><a href="#摄像" class="headerlink" title="摄像"></a>摄像</h3><p>想要用摄像头模块拍一段视频的话，可以从命令行运行 raspivid 工具。下面这句命令会按照默认配置(长度5秒，分辨率1920x1080，比特率 17Mbps)拍摄一段视频。</p>
<p><code>$ raspivid -o mykeychain.h264</code></p>
<p>如果你想改变拍摄时长，只要通过 “-t” 选项来设置你想要的长度就行了（单位是毫秒）。</p>
<p><code>$ raspivid -o mykeychain.h264 -t 10000</code></p>
<p>使用 “-w” 和 “-h” 选项将分辨率降为 1280x720…</p>
<p><code>$ raspivid -o mykeychain.h264 -t 10000 -w 1280 -h 720</code></p>
<p>raspivid 的输出是一段未压缩的 H.264 视频流，而且这段视频不含声音。为了能被通常的视频播放器所播放，这个 raw 的 H.264 视频还需要转换。可以使用 gpac 包中所带有的 MP4Box 应用。</p>
<p>在 Raspbian 上安装 gpac，输入命令：</p>
<p><code>$ sudo apt-get install -y gpac</code> </p>
<p>然后将这段 raw 的 H.264 格式的视频流转换为每秒30帧的 .mp4 格式视频：</p>
<p><code>$ MP4Box -fps 30 -add keychain.h264 keychain.mp4</code> </p>
<h2 id="防火墙的使用"><a href="#防火墙的使用" class="headerlink" title="防火墙的使用"></a>防火墙的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 启动防火墙</span><br><span class="line">systemctl start firewalld </span><br><span class="line"></span><br><span class="line">2. 禁用防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">3. 设置开机启动</span><br><span class="line">systemctl enable firewalld</span><br><span class="line"></span><br><span class="line">4. 停止并禁用开机启动</span><br><span class="line">sytemctl disable firewalld</span><br><span class="line"></span><br><span class="line">5. 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">6.查看指定区域所有打开的端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --list-ports</span><br><span class="line"></span><br><span class="line">7.在指定区域打开端口（记得重启防火墙）</span><br><span class="line">firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;80&#x2F;tcp</span><br><span class="line">or </span><br><span class="line">firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;80&#x2F;udp</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="端口占用及解除"><a href="#端口占用及解除" class="headerlink" title="端口占用及解除"></a>端口占用及解除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看端口占用：</span><br><span class="line"></span><br><span class="line">(1) netstat -an|grep 8080  &#x2F;&#x2F; </span><br><span class="line">   netstat -tln | grep 8000</span><br><span class="line">(2) lsof -i:8080</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">1.netstat无权限控制，lsof有权限控制，只能看到本用户</span><br><span class="line">2.losf能看到pid和用户，可以找到哪个进程占用了这个端口</span><br><span class="line"></span><br><span class="line">关闭进程：</span><br><span class="line"></span><br><span class="line">1: kill 进程号  会给进程发送一个SIGTERM信号，使进程先释放自己资源，然后停止，但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应，</span><br><span class="line"></span><br><span class="line">2:kill -9 进程号  会给进程发送一个SIGKILL信号，使该进程执行exit，不会被阻塞，所以可以有效的杀掉进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数码</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>不备案建站</title>
    <url>/2019/09/05/notepad/read/others/%E7%BB%95%E8%BF%87%E7%BD%91%E7%AB%99%E5%A4%87%E6%A1%88%E5%BB%BA%E7%AB%99/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p> 这个Blog建好的时候， 每次打开查看我写的都要输入一串数字ip，浏览器有记录还好，要是没有记录，真的是太麻烦了，鬼才能记住这么一长串数字，终于感受到为什么要发明域名这种东西了</p>
<p> 于是，毅然在阿里买下了一个域名， 10rmb一年，没想到这么挺便宜，解析到我的这个BLog的的服务器，这个服务器是我一个大学同学的，没有备案，弄了一个小时，终于可以访问， 吼吼吼，真的舒服，浏览器输入 fireflying.top 就可以访问，不用看到一串数字，一串记不住的数字</p>
<p> <strong>结果是</strong> ——&gt;   第二天，域名就被， 腾讯，拦截了， 还有一个链接到腾讯， 刚开始想， 丢，还以为阿里的域名，腾讯拦截干什么！?（黑人问号）， 后来仔细想了一下，原来服务器是腾讯的， 有域名解析到腾讯的服务器上，所以腾旭就给拦截了。现在为难我了，这个服务器是我一个大学同学的，要他备案可能有点不好，该怎么办呢？</p>
<h2 id="折腾"><a href="#折腾" class="headerlink" title="折腾"></a>折腾</h2><p> 查了一下,如果<strong>国内</strong>网站要域名绑定的话，就必须备案，防止什么什么。。。但是国外可以不用。当我看到这条的时候感觉完了，域名可能白买了，但是过了几个小时发呆的时候灵光一现，想到两个合起来不就行了？</p>
<p>简单来书说就是，把域名绑定在我另一个国外服务器上（<strong>合法</strong>），通过访问这个国外服务器，帮我转到这个国内的服务器（<strong>没毛病</strong>）</p>
<p> 再一想，直接用Git不就行了，他是外国人的，平时访问这么慢，ping 一下Github的地址 在东京，git也用到了代理，但是Git提供了一个域名的绑定方案，通过CNAME连接到Git，再转发， 终于最后搞定。</p>
<p> 但是存在的一个问题是，访问域名的时候，显示的是ip。</p>
<p> 使用 document.title=”强行改标题”</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg</title>
    <url>/2019/10/22/notepad/read/others/%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6ffmpeg/</url>
    <content><![CDATA[<h1 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h1><p>转载</p>
<p>ffmpeg的使用方式：<br>ffmpeg [options] [[infile options] -i infile]… {[outfile options] outfile}…</p>
<p><strong>常用参数说明：</strong><br>主要参数：<br>-i 设定输入流<br>-f 设定输出格式<br>-ss 开始时间</p>
<a id="more"></a>
<p><strong>视频参数：</strong><br>-b 设定视频流量，默认为200Kbit/s<br>-r 设定帧速率，默认为25<br>-s 设定画面的宽与高<br>-aspect 设定画面的比例<br>-vn 不处理视频<br>-vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器</p>
<p><strong>音频参数：</strong><br>-ar 设定采样率<br>-ac 设定声音的Channel数<br>-acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器<br>-an 不处理音频</p>
<h3 id="1-视频格式转换"><a href="#1-视频格式转换" class="headerlink" title="1.视频格式转换"></a>1.视频格式转换</h3><p>（其实格式转换说法不太准确，但大家都这么叫，准确的说，应该是视频容器转换）<br>比如一个avi文件，想转为mp4，或者一个mp4想转为ts。<br>ffmpeg -i input.avi output.mp4<br>ffmpeg -i input.mp4 output.ts<br>我目测这个已经能满足很多人的需求了。</p>
<h3 id="2-提取音频"><a href="#2-提取音频" class="headerlink" title="2.提取音频"></a>2.提取音频</h3><p>比如我有一个“晓松奇谈”，可是我不想看到他的脸，我只想听声音， 地铁上可以听，咋办？<br>ffmpeg -i 晓松奇谈.mp4 -acodec copy -vn output.aac<br>上面的命令，默认mp4的audio codec是aac，如果不是会出错，咱可以暴力一点，不管什么音频，都转为最常见的aac。<br>ffmpeg -i 晓松奇谈.mp4 -acodec aac -vn output.aac</p>
<h3 id="3-提取视频"><a href="#3-提取视频" class="headerlink" title="3.提取视频"></a>3.提取视频</h3><p>我目测有些IT员工，特别是做嵌入式的，比如机顶盒，想debug一下，没有音频的情况下，播放一个视频几天几夜会不会crash，这时候你需要一个纯视频文件，可以这么干。<br>ffmpeg -i input.mp4 -vcodec copy -an output.mp4</p>
<h3 id="4-视频剪切"><a href="#4-视频剪切" class="headerlink" title="4.视频剪切"></a>4.视频剪切</h3><p>经常要测试视频，但是只需要测几秒钟，可是视频却有几个G，咋办？切啊！<br>下面的命令，就可以从时间为00:00:15开始，截取5秒钟的视频。<br>ffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4<br>-ss表示开始切割的时间，-t表示要切多少。上面就是从开始，切5秒钟出来。</p>
<h3 id="5-码率控制"><a href="#5-码率控制" class="headerlink" title="5.码率控制"></a>5.码率控制</h3><p>码率控制对于在线视频比较重要。因为在线视频需要考虑其能提供的带宽。</p>
<p>那么，什么是码率？很简单：<br>bitrate = file size / duration<br>比如一个文件20.8M，时长1分钟，那么，码率就是：<br>biterate = 20.8M bit/60s = 20.8<em>1024\</em>1024*8 bit/60s= 2831Kbps<br>一般音频的码率只有固定几种，比如是128Kbps，<br>那么，video的就是<br>video biterate = 2831Kbps -128Kbps = 2703Kbps。</p>
<p>说完背景了。好了，来说ffmpeg如何控制码率。<br>ffmpg控制码率有3种选择，-minrate -b:v -maxrate<br>-b:v主要是控制平均码率。<br>比如一个视频源的码率太高了，有10Mbps，文件太大，想把文件弄小一点，但是又不破坏分辨率。<br>ffmpeg -i input.mp4 -b:v 2000k output.mp4<br>上面把码率从原码率转成2Mbps码率，这样其实也间接让文件变小了。目测接近一半。<br>不过，ffmpeg官方wiki比较建议，设置b:v时，同时加上 -bufsize<br>-bufsize 用于设置码率控制缓冲器的大小，设置的好处是，让整体的码率更趋近于希望的值，减少波动。（简单来说，比如1 2的平均值是1.5， 1.49 1.51 也是1.5, 当然是第二种比较好）<br>ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4</p>
<p>-minrate -maxrate就简单了，在线视频有时候，希望码率波动，不要超过一个阈值，可以设置maxrate。<br>ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4</p>
<h3 id="6-视频编码格式转换"><a href="#6-视频编码格式转换" class="headerlink" title="6.视频编码格式转换"></a>6.视频编码格式转换</h3><p>比如一个视频的编码是MPEG4，想用H264编码，咋办？<br>ffmpeg -i input.mp4 -vcodec h264 output.mp4<br>相反也一样<br>ffmpeg -i input.mp4 -vcodec mpeg4 output.mp4</p>
<p>当然了，如果ffmpeg当时编译时，添加了外部的x265或者X264，那也可以用外部的编码器来编码。（不知道什么是X265，可以Google一下，简单的说，就是她不包含在ffmpeg的源码里，是独立的一个开源代码，用于编码HEVC，ffmpeg编码时可以调用它。当然了，ffmpeg自己也有编码器）<br>ffmpeg -i input.mp4 -c:v libx265 output.mp4<br>ffmpeg -i input.mp4 -c:v libx264 output.mp4</p>
<h3 id="7-只提取视频ES数据"><a href="#7-只提取视频ES数据" class="headerlink" title="7.只提取视频ES数据"></a>7.只提取视频ES数据</h3><p>这个可能做开发的人会用到，顺便提一下吧。<br>ffmpeg –i input.mp4 –vcodec copy –an –f m4v output.h264</p>
<h3 id="8-过滤器的使用"><a href="#8-过滤器的使用" class="headerlink" title="8.过滤器的使用"></a>8.过滤器的使用</h3><p>这个我在另一篇博客提到了，这里贴一下吧。</p>
<h4 id="8-1-将输入的1920x1080缩小到960x540输出"><a href="#8-1-将输入的1920x1080缩小到960x540输出" class="headerlink" title="8.1 将输入的1920x1080缩小到960x540输出:"></a>8.1 将输入的1920x1080缩小到960x540输出:</h4><p>ffmpeg -i input.mp4 -vf scale=960:540 output.mp4<br>//ps: 如果540不写，写成-1，即scale=960:-1, 那也是可以的，ffmpeg会通知缩放滤镜在输出时保持原始的宽高比。</p>
<h4 id="8-2-为视频添加logo"><a href="#8-2-为视频添加logo" class="headerlink" title="8.2 为视频添加logo"></a>8.2 为视频添加logo</h4><p>比如，我有这么一个图片</p>
<p>想要贴到一个视频上，那可以用如下命令：<br>./ffmpeg -i input.mp4 -i iQIYI_logo.png -filter_complex overlay output.mp4<br>结果如下所示：</p>
<p>要贴到其他地方？看下面：<br>右上角：<br>./ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4<br>左下角：<br>./ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4<br>右下角：<br>./ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4</p>
<h4 id="8-3-去掉视频的logo"><a href="#8-3-去掉视频的logo" class="headerlink" title="8.3 去掉视频的logo"></a>8.3 去掉视频的logo</h4><p>有时候，下载了某个网站的视频，但是有logo很烦，咋办？有办法，用ffmpeg的delogo过滤器。<br>语法：-vf delogo=x:y:w:h[:t[:show]]<br>x:y 离左上角的坐标<br>w:h logo的宽和高<br>t: 矩形边缘的厚度默认值4<br>show：若设置为1有一个绿色的矩形，默认值0。</p>
<p>ffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4<br>结果如下所示：</p>
<h3 id="9-抓取视频的一些帧，存为jpeg图片"><a href="#9-抓取视频的一些帧，存为jpeg图片" class="headerlink" title="9.抓取视频的一些帧，存为jpeg图片"></a>9.抓取视频的一些帧，存为jpeg图片</h3><p>比如，一个视频，我想提取一些帧，存为图片，咋办？<br>ffmpeg -i input.mp4 -r 1 -q:v 2 -f image2 pic-%03d.jpeg<br>-r 表示每一秒几帧<br>-q:v表示存储jpeg的图像质量，一般2是高质量。<br>如此，ffmpeg会把input.mp4，每隔一秒，存一张图片下来。假设有60s，那会有60张。</p>
<p>60张？什么？这么多？不要不要。。。。。不要咋办？？<br>可以设置开始的时间，和你想要截取的时间呀。<br>ffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg<br>-ss 表示开始时间<br>-t表示共要多少时间。<br>如此，ffmpeg会从input.mp4的第20s时间开始，往下10s，即20~30s这10秒钟之间，每隔1s就抓一帧，总共会抓10帧。</p>
<p>怎么样，好用吧。^^</p>
<h3 id="其他小众的用法"><a href="#其他小众的用法" class="headerlink" title="其他小众的用法"></a><strong>其他小众的用法</strong></h3><p>1.输出YUV420原始数据<br>对于一下做底层编解码的人来说，有时候常要提取视频的YUV原始数据。<br>怎么坐？很简答：<br>ffmpeg -i input.mp4 output.yuv<br>怎么样，是不是太简单啦？！！！哈哈</p>
<p>如果你想问yuv的数据，如何播放，我不会告诉你，RawPlayer挺好用的！！</p>
<p>那如果我只想要抽取某一帧YUV呢？<br>简单，你先用上面的方法，先抽出jpeg图片，然后把jpeg转为YUV。<br>比如：<br>你先抽取10帧图片。<br>ffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg<br>结果：</p>
<p><code>-rw-rw-r-- 1 chenxf chenxf    296254  7月 20 16:08 pic-001.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    300975  7月 20 16:08 pic-002.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    310130  7月 20 16:08 pic-003.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    268694  7月 20 16:08 pic-004.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    301056  7月 20 16:08 pic-005.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    293927  7月 20 16:08 pic-006.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    340295  7月 20 16:08 pic-007.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    430787  7月 20 16:08 pic-008.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    404552  7月 20 16:08 pic-009.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    412691  7月 20 16:08 pic-010.jpeg</code></p>
<p>然后，你就随便挑一张，转为YUV:<br>ffmpeg -i pic-001.jpeg -s 1440x1440 -pix_fmt yuv420p xxx3.yuv<br>如果-s参数不写，则输出大小与输入一样。</p>
<p>当然了，YUV还有yuv422p啥的，你在-pix_fmt 换成yuv422p就行啦！</p>
<ol start="2">
<li>H264编码profile &amp; level控制<br>背景知识<br>先科普一下profile&amp;level吧，知道的请飘过。（这里讨论最常用的H264）<br>H.264有四种画质级别,分别是baseline, extended, main, high：<br>　　1、Baseline Profile：基本画质。支持I/P 帧，只支持无交错（Progressive）和CAVLC；<br>　　2、Extended profile：进阶画质。支持I/P/B/SP/SI 帧，只支持无交错（Progressive）和CAVLC；(用的少)<br>　　3、Main profile：主流画质。提供I/P/B 帧，支持无交错（Progressive）和交错（Interlaced），<br>　　　 也支持CAVLC 和CABAC 的支持；<br>　　4、High profile：高级画质。在main Profile 的基础上增加了8x8内部预测、自定义量化、 无损视频编码和更多的YUV 格式；<br>H.264 Baseline profile、Extended profile和Main profile都是针对8位样本数据、4:2:0格式(YUV)的视频序列。在相同配置情况下，High profile（HP）可以比Main profile（MP）降低10%的码率。<br>根据应用领域的不同，Baseline profile多应用于实时通信领域，Main profile多应用于流媒体领域，High profile则多应用于广电和存储领域。</li>
</ol>
<p>下图清楚的给出不同的profile&amp;level的性能区别。<br>profile</p>
<p>level</p>
<p>2.1 ffmpeg如何控制profile&amp;level<br>举3个例子吧<br>ffmpeg -i input.mp4 -profile:v baseline -level 3.0 output.mp4</p>
<p>ffmpeg -i input.mp4 -profile:v main -level 4.2 output.mp4</p>
<p>ffmpeg -i input.mp4 -profile:v high -level 5.1 output.mp4</p>
<p>如果ffmpeg编译时加了external的libx264，那就这么写：<br>ffmpeg -i input.mp4 -c:v libx264 -x264-params “profile=high:level=3.0” output.mp4</p>
<p>从压缩比例来说，baseline&lt; main &lt; high，对于带宽比较局限的在线视频，可能会选择high，但有些时候，做个小视频，希望所有的设备基本都能解码（有些低端设备或早期的设备只能解码baseline），那就牺牲文件大小吧，用baseline。自己取舍吧！</p>
<p>苹果的设备对不同profile的支持。</p>
<p>2.2. 编码效率和视频质量的取舍(preset, crf)<br>除了上面提到的，强行配置biterate，或者强行配置profile/level，还有2个参数可以控制编码效率。<br>一个是preset，一个是crf。<br>preset也挺粗暴，基本原则就是，如果你觉得编码太快或太慢了，想改改，可以用profile。<br>preset有如下参数可用：</p>
<p>ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow and placebo.<br>编码加快，意味着信息丢失越严重，输出图像质量越差。</p>
<p>CRF(Constant Rate Factor): 范围 0-51: 0是编码毫无丢失信息, 23 is 默认, 51 是最差的情况。相对合理的区间是18-28.<br>值越大，压缩效率越高，但也意味着信息丢失越严重，输出图像质量越差。</p>
<p>举个例子吧。<br>ffmpeg -i input -c:v libx264 -profile:v main -preset:v fast -level 3.1 -x264opts crf=18<br>(参考自：<a class="link"   href="https://trac.ffmpeg.org/wiki/Encode/H.264" >https://trac.ffmpeg.org/wiki/Encode/H.264<i class="fas fa-external-link-alt"></i></a>)</p>
<p>2.3. H265 (HEVC)编码tile&amp;level控制<br>背景知识<br>和H264的profile&amp;level一样，为了应对不同应用的需求，HEVC制定了“层级”(tier) 和“等级”(level)。<br>tier只有main和high。<br>level有13级，如下所示：</p>
<p>不多说，直接给出怎么用。（supposed你用libx265编码）<br>ffmpeg -i input.mp4 -c:v libx265 -x265-params “profile=high:level=3.0” output.mp4</p>
<p>原文链接：<a class="link"   href="https://blog.csdn.net/newchenxf/article/details/51384360" >https://blog.csdn.net/newchenxf/article/details/51384360<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/06/notepad/read/tools/conda/</url>
    <content><![CDATA[<!--
 * @Author: Firefly
 * @Date: 2019-12-17 22:50:48
 * @Descripttion: 
 * @LastEditTime : 2019-12-23 20:17:16
 -->


<p>更换清华源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --append channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/fastai/</span><br><span class="line">conda config --append channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config --append channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索时显示通道地址</span></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate py37</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activate &#x2F;&#x2F; 切换到base环境</span><br><span class="line">activate name &#x2F;&#x2F; 切换到name环境</span><br><span class="line">conda create -n learn python&#x3D;3 &#x2F;&#x2F; 创建一个名为learn的环境并指定python版本为3(的最新版本)</span><br><span class="line">conda env list &#x2F;&#x2F; 列出conda管理的所有环境</span><br><span class="line">conda list &#x2F;&#x2F; 列出当前环境的所有包</span><br><span class="line">conda install requests 安装requests包</span><br><span class="line">conda remove requests 卸载requets包</span><br><span class="line">conda remove -n learn --all &#x2F;&#x2F; 删除learn环境及下属所有包</span><br><span class="line">conda update requests 更新requests包</span><br><span class="line">conda env export &gt; environment.yaml &#x2F;&#x2F; 导出当前环境的包信息</span><br><span class="line">conda env create -f environment.yaml &#x2F;&#x2F; 用配置文件创建新的虚拟环境</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/06/notepad/read/tools/docker/</url>
    <content><![CDATA[<p>docker的使用步骤：</p>
<ol>
<li>安装 Docker</li>
<li>去Docker仓库找到这个软件对应的镜像</li>
<li>使用Docker运行这个镜像，这个镜像就会生成一个Docker容器</li>
<li>对容器的启动停止就对软件启动和重启</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>内核版本： 3.10 以上</p>
<p><code>uname -r</code></p>
<p>安装Docker：</p>
<p>安装： <code>yum install docker</code></p>
<p>启动：<code>systemctl start docker</code> </p>
<p>查看版本：<code>docker -v</code></p>
<p>开机自启：<code>systemctl enable docker</code></p>
<p>停止：<code>systemctl stop docker</code></p>
<p>查找： <code>docker search name</code></p>
<p>下载：<code>docker pull mysql</code></p>
<p>查看所有镜像：  <code>docker images</code></p>
<p>删除：<code>docker rmi ID</code></p>
<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><p>软件镜像（QQ）&gt;&gt; 运行镜像 &gt;&gt; 产生一个容器（运行的QQ）</p>
<p>运行  <code>docker --name myname -d name(-d 后台)</code></p>
<p>查看已经运行  <code>docker ps</code></p>
<p>停止容器： <code>docker stop ID</code></p>
<p>启动容器： <code>docker start ID</code></p>
<p>映射端口：<code>docker run -d -p port:port   name</code></p>
<p>查看日志： <code>docker logs name</code></p>
<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p><code>docker pull mysql</code></p>
<p><code>docker run -p port:port --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql </code> </p>
]]></content>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2019/09/28/notepad/read/tools/git/</url>
    <content><![CDATA[<p>Git常用操作，一文打尽<br><img src="./../images/git_all_01.png"></p>
<h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><ul>
<li>git clone url 克隆远程版本库</li>
<li>git init 初始化本地版本库</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li>git config –global user.name ‘chengcp’ 配置global级别的用户名</li>
<li>git config –global user.email ‘1326895569@qq.com’ 配置global级别的邮箱</li>
<li>git config –global -l 查看global级别的配置列表</li>
<li>git config –global –unset user.name 删除用户名</li>
<li>git config –global alias.last ‘log -1 HEAD’ 配置last别名，使用git last将显示最近的一次提交记录</li>
</ul>
<h3 id="添加和删除文件"><a href="#添加和删除文件" class="headerlink" title="添加和删除文件"></a>添加和删除文件</h3><ul>
<li>git add file1 file2 添加指定文件到暂存区</li>
<li>git add dir 添加指定目录到暂存区</li>
<li>git add . 添加当前目录的所有文件到暂存区</li>
<li>git mv oldname newname 对一个已经追踪过的文件进行改名，同时加入暂存区</li>
<li>git rm file1 file2 删除工作区文件，同时将这次删除放入暂存区</li>
<li>git rm –cached file 停止追踪指定文件，但该文件会保留在工作区；tracked变成untracked</li>
</ul>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><ul>
<li>git commit file1 file 2 -m message 提交暂存区指定文件到本地仓库</li>
<li>git commit -m message 提交暂存区所有文件到本地仓库</li>
<li>git commit -a -m message 自动暂存所有已经追踪过的文件，且提交到本地仓库<br>git commit –amend -m message 使用一次新的提交，替代上次提交 </li>
</ul>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul>
<li>git branch 查看所有本地分支</li>
<li>git branch –r 查看所有远程分支</li>
<li>git branch –a 查看所有远程和本地分支</li>
<li>git branch –v 查看本地所有分支最新一次提交信息</li>
<li>git branch [branch] 新建分支</li>
<li>git checkout –b [branch] 新建一个分支，并且切换过去</li>
<li>git branch [branch] [commit] 基于某次提交，建立一个分支</li>
<li>git branch –track [branch] [remote-branch] 建立一个分支，并且与远程分支建立追踪关系</li>
<li>git branch –set-upstream [branch] [remote-branch] 在现有的本地分支和远程分支之间建立追踪关系</li>
<li>git branch –m [old-branch] [new-branch] 重命名分支</li>
<li>git merge [branch] 把指定分支合并到当前分支</li>
<li>git chery-pick [commit] [commit] 选择提交，合并进当前分支</li>
<li>git branch –d [branch] 删除本地分支</li>
<li>git push origin –d [branch] 删除远程分支</li>
<li>git checkout [branch] 切换分支</li>
<li>git checkout - 切换到上一个最近使用过的分支</li>
</ul>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul>
<li>git tag 列出所有标签</li>
<li>git show [tag] 查看指定标签信息</li>
<li>git tag [tag] 给最近一次提交打一个标签</li>
<li>git tag [tag] [commit] 在某次提交上打一个标签</li>
<li>git tag –d [tag] 删除本地指定标签</li>
<li>git push origin –d tag [tag] 删除远程的标签</li>
<li>git push origin [tag] 推送指定标签</li>
<li>git push origin –tags 推送所有标签</li>
</ul>
<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><ul>
<li>git status 查看文件状态</li>
<li>git help [command] 获取帮助文档</li>
<li>git [command] –help 获取帮助文档</li>
<li>git log 查看当前分支的提交记录</li>
<li>git log –all 查看所有分支的提交记录</li>
<li>git log -5 –oneline –graph 查看最近5次提交记录，以单行、树状图形式显示</li>
<li>git reflog 查看本地所有变更记录</li>
<li>git diff 查看工作区和暂存区的差异</li>
<li>git diff – file 某个文件在工作区和暂存区的差异</li>
<li>git diff HEAD 工作区和最新一次提交的差异</li>
<li>git diff –cached 暂存区和HEAD的差异</li>
<li>git diff branch_a branch_b – file 某文件在两个分支间的差异</li>
</ul>
<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><ul>
<li>git remote -v 查看所有远程仓库</li>
<li>git ls-remote origin 查看远程仓库引用列表</li>
<li>git remote show origin 查看远程仓库信息</li>
<li>git fetch origin 拉取远程仓库最新提交</li>
<li>git pull origin master 拉取远程master，并且合并到本地当前分支</li>
<li>git remote add upstream url 添加一个新的远程仓库，命名为upstream</li>
<li>git push origin master 推送到远程origin的master分支</li>
<li>git push origin –all 推送所有分支到远程仓库</li>
<li>git remote prune origin 删除远程仓库中不存在的分支</li>
</ul>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul>
<li>git reset –soft HEAD 回滚到指定版本，保留工作区和暂存区</li>
<li>git reset –mixed HEAD 回滚到指定版本，保留工作区，清空暂存区；–mixed是默认参数，即等同于git reset HEAD</li>
<li>git reset –hard HEAD 回滚到指定版本，清空工作区和暂存区</li>
<li>git reset HEAD – file 清空暂存区中某个文件的修改</li>
<li>git checkout – file 检出暂存区的文件到工作目录</li>
<li>git checkout . 检出暂存区的所有文件到工作目录</li>
<li>git revert HEAD~ 2 回滚到2个祖先提交的版本，同时产生新的提交记录</li>
<li>git revert –continue 冲突解决，且把修改提交到暂存区后执行回滚，生成一个新的提交</li>
<li>git revert –abort 取消回滚，回到之前的状态</li>
</ul>
<h3 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h3><ul>
<li>git stash 将工作区和暂存区的变更保存到储藏堆栈中，同时工作区和暂存区恢复到HEAD一样</li>
<li>git stash list 查看储藏列表</li>
<li>git stash pop 应用最近的一次储藏，并且从储藏栈中移除该条记录</li>
<li>git stash apply stash@{0} 应用最近的一次储藏，不移除记录；等同于 git stash apply</li>
<li>git stash pop –index 应用最近一次储藏，–index表示暂存区的变更也会更新，否则只更新工作区变更</li>
<li>git stash drop stash@{0} 移除储藏记录</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/06/notepad/read/tools/maven/</url>
    <content><![CDATA[<h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><p>以下的命令会按顺序执行，后面命令会调用前面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure>

<p>把编译好的类清除掉， 因为每个开发环境不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure>

<p>编译主要的类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure>

<p>编译测试的类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure>

<p>把工程打包成jar 包</p>
<p>编译测试类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>

<p>执行上面的所有命令， 并且放入本地仓库中</p>
<p>maven工程可以直接使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tomcat:run </span><br></pre></td></tr></table></figure>

<p>直接使用tomcat 运行项目</p>
<p>windows安装：</p>
<p>首先， 下载可执行文件：<a class="link"   href="http://maven.apache.org/download.cgi" >http://maven.apache.org/download.cgi<i class="fas fa-external-link-alt"></i></a></p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209203336.png"></p>
<p> 下载后解压记住路径， 然后添加系统变量和环境变量。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209203517.png"></p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209203615.png"></p>
<p>最后测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn -version</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209203655.png"></p>
<p><strong>本地仓库</strong>:  使用时先在本地找依赖， 如果没有就去网络找！网络找到后会放在这里</p>
<p>默认在： users / {username}  / .m2</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209204252.png"></p>
<p>在目录下更改 <strong>本地仓库</strong> 的位置: <code>&#123;M2_HOME&#125;\conf\setting.xml</code>, 搜索 LocalResposity，把注释取消掉</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209204658.png"></p>
<p>maven 在本地的找不到依赖就去网络找。</p>
<ul>
<li>首先,去自定义的远程仓库找,  在 pom.xml 定义自己公司的仓库：</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;mirrors&gt;</span></span><br><span class="line">    <span class="attr">&lt;mirror&gt;</span></span><br><span class="line">        <span class="attr">&lt;id&gt;nexus-aliyun&lt;/id&gt;</span></span><br><span class="line">        <span class="attr">&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span></span><br><span class="line">        <span class="meta">&lt;name&gt;Nexus</span> <span class="string">aliyun&lt;/name&gt;</span></span><br><span class="line">        <span class="meta">&lt;url&gt;</span> <span class="string">｛url｝&lt;/url&gt;</span></span><br><span class="line">    <span class="meta">&lt;/mirror&gt;</span> <span class="string"></span></span><br><span class="line">  <span class="attr">&lt;/mirrors&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>然后，自定义的远程仓库没有，最后maven 会在中心远程仓库找，仓库在国外， 更换阿里的！<code>.\conf\setting.xml</code></li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;mirrors&gt;</span></span><br><span class="line">    <span class="attr">&lt;mirror&gt;</span></span><br><span class="line">        <span class="attr">&lt;id&gt;nexus-aliyun&lt;/id&gt;</span></span><br><span class="line">        <span class="attr">&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span></span><br><span class="line">        <span class="meta">&lt;name&gt;Nexus</span> <span class="string">aliyun&lt;/name&gt;</span></span><br><span class="line">        <span class="meta">&lt;url&gt;http</span>:<span class="string">//maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line">    <span class="meta">&lt;/mirror&gt;</span> <span class="string"></span></span><br><span class="line">  <span class="attr">&lt;/mirrors&gt;</span></span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>x86 汇编器编程</title>
    <url>/2020/12/06/notepad/read/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/x86%20%E6%B1%87%E7%BC%96%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="x86-汇编器编程"><a href="#x86-汇编器编程" class="headerlink" title="x86 汇编器编程"></a>x86 汇编器编程</h2><p>基于x86 实现编译器首先得了解x86 平台的指令调度， 以下是一些我在实现编译器过程中用到的基础知识！</p>
<p>大部分内容参考了 青木的自制编译器，</p>
<h3 id="基于GNU汇编器"><a href="#基于GNU汇编器" class="headerlink" title="基于GNU汇编器"></a>基于GNU汇编器</h3><p>c语言使用gcc 编译， 而gcc 编译器将c代码转化为汇编之后， 也是用的GNU as 的汇编器将汇编语言 .s 转化为.o，然后再连接， 因此如果自制编译器， 也是做到汇编这一步， 所以又得学x86 汇编器的使用方法！</p>
<p>gcc 用的 GNU， 那我就直接使用gcc！</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">as hello.s &#x2F;&#x2F;默认生成 a.out</span><br></pre></td></tr></table></figure>

<p>也可以指定名字：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">as -o hello.o hello.s</span><br></pre></td></tr></table></figure>

<p>生成目标文件后还要连接才可以执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>

<p>最后就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure>



<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>指令包括  <strong>助记符</strong> 和 <strong>操作数</strong> 组成，比如 <code>movl %esp， %ebp</code> , movl 助记符， 后面两个为操作数， 操作数可以为多个！逗号分隔。</p>
<p>这个是由cpu直接执行的指令</p>
<h4 id="汇编伪操作"><a href="#汇编伪操作" class="headerlink" title="汇编伪操作"></a>汇编伪操作</h4><p>以点 “.” 开头的， 末尾没有冒号 “：” 的 <strong>行</strong> 都是汇编伪操作行。</p>
<p>由汇编器执行，记录元数据和设定指令的属性。</p>
<p>汇编的首行缩进是没有影响的</p>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>以冒号“：” 结尾的 <strong>行</strong> 都是标签行</p>
<p>冒号是语法， 标签名为冒号前面的值。</p>
<p>一般命名加上 . ，避免和代码里面的名字重复。</p>
<h4 id="助记符后缀"><a href="#助记符后缀" class="headerlink" title="助记符后缀"></a>助记符后缀</h4><table>
<thead>
<tr>
<th align="center">后缀</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">b</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">32</td>
</tr>
</tbody></table>
<h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><h5 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h5><p>使用$num 来标识， $1 表示 1</p>
<h5 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h5><p>可以直接当做立即数， 使用 % 作为前缀， %eax = %EAX</p>
<h5 id="直接内存引用"><a href="#直接内存引用" class="headerlink" title="直接内存引用"></a>直接内存引用</h5><p>直接访问固定内存</p>
<h5 id="间接内存访问"><a href="#间接内存访问" class="headerlink" title="间接内存访问"></a>间接内存访问</h5><p>相当于使用c语言的数组</p>
<p>例子：</p>
<p><code>movl %ecx, %eax</code><br>最后，将ecx 寄存器中的数据作为地址访问内存，并将内存上的数据加载到eax 寄存器中<br>的写法如下所示。</p>
<p><code>movl (%ecx), %eax</code><br>不习惯汇编的话会觉得%ecx 和(%ecx) 的区别难以理解，可以把它当作C 语言的指针。<br>指针变量ptr 自身的值等同于%ecx 的话，那么对指针的取值操作*ptr 就相当于(%ecx)。<br>另外，%ecx 是访问寄存器，而(%ecx) 则是利用寄存器访问内存。</p>
<p>//todo important</p>
<h3 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h3><h4 id="传输指令："><a href="#传输指令：" class="headerlink" title="传输指令："></a>传输指令：</h4><h5 id="movl"><a href="#movl" class="headerlink" title="movl"></a>movl</h5><p>mov 是在寄存器或内存之间传输数据，或者将立即数加载到寄存器或<br>内存的指令。mov 也是汇编语言中最常用的指令之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov 立即数，寄存器</span><br><span class="line">mov 寄存器， 寄存器</span><br><span class="line">mov 内存，寄存器</span><br><span class="line">mov 立即数，内存</span><br><span class="line">mov 寄存器，内存</span><br><span class="line">mov 内存，内存</span><br></pre></td></tr></table></figure>



<h5 id="pop-and-push"><a href="#pop-and-push" class="headerlink" title="pop and push"></a>pop and push</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 立即数</span><br><span class="line">push 寄存器</span><br></pre></td></tr></table></figure>

<p>push 指令将数据压栈。具体来说，<strong>将esp 寄存器减去压栈的数据的大小</strong>(注意会自己减去)，再将数据存储到<br>esp 寄存器所指向的地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop 寄存器</span><br></pre></td></tr></table></figure>

<p>pop 指令将数据出栈并写入寄存器。具体来说，将数据从esp 寄存器所指向的地址加载到<br>寄存器，再将esp 寄存器加上出栈的数据的大小。</p>
<h5 id="leal"><a href="#leal" class="headerlink" title="leal"></a>leal</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea 内存，寄存器</span><br></pre></td></tr></table></figure>

<p>lea 指令将地址加载到寄存器。lea 是Load Effective Address（实效地址加载）的简称。<br>“lea 内存, 寄存器”将内存对应的地址加载到寄存器。</p>
<p><strong>note:</strong></p>
<p>mov 指令表示将ebx 寄存器加4 后的值作为内存地址进行访问，并将数据加载到eax 寄存器中。<br><code>movl 4(%ebx), %eax</code></p>
<p>另一方面，将上述语句中的mov 指令替换为lea 指令，如下所示。该语句表示将ebx 寄存<br>器加上4 后的值保存到eax。</p>
<p><code>leal 4(%ebx), %eax</code><br>同样是间接内存引用的语句，mov 指令取得的是内存地址所指向的内存上的数据，而lea<br>指令取得的是内存地址本身。</p>
<p>//! important</p>
<h4 id="运算指令："><a href="#运算指令：" class="headerlink" title="运算指令："></a>运算指令：</h4><h5 id="addl"><a href="#addl" class="headerlink" title="addl"></a>addl</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add 立即数， 寄存器</span><br><span class="line">add 寄存器， 寄存器</span><br><span class="line">add 内存， 寄存器</span><br><span class="line">add 立即数， 内存</span><br><span class="line">add 寄存器， 内存</span><br></pre></td></tr></table></figure>

<p>add 指令将第1 操作数和第2 操作数相加，并将结果写入第2 操作数。<br>请注意“将运算结果写入第2 操作数”这一点。</p>
<p>例如add$1, %eax 表示将eax 寄存器的数据加1，并将结果保存到eax 寄存器。类似于C 语言中的+= 运算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addl $<span class="number">1</span>, %eax # 将eax 寄存器加<span class="number">1</span></span><br><span class="line">addl %ecx, %eax <span class="meta"># eax 寄存器和ecx 寄存器的数据相加后存放到eax 寄存器</span></span><br><span class="line">addl $<span class="number">4</span>, (%ebx) # 将ebx 寄存器所指向的内存中的数据加<span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>加减乘除差不多！！</p>
<h3 id="流程控制指令："><a href="#流程控制指令：" class="headerlink" title="流程控制指令："></a><strong>流程控制指令：</strong></h3><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>jmp</td>
<td>无条件跳转</td>
</tr>
<tr>
<td>jz、jnz、je、jne</td>
<td>条件跳转</td>
</tr>
<tr>
<td>cmp</td>
<td>数据的比较</td>
</tr>
<tr>
<td>test</td>
<td>数据的非0 检查</td>
</tr>
<tr>
<td>sete、setne、setg、setge、setl、setle</td>
<td>获取eflags 寄存器中的各个标志位</td>
</tr>
<tr>
<td>call</td>
<td>函数调用</td>
</tr>
<tr>
<td>ret</td>
<td>从子程序返回</td>
</tr>
</tbody></table>
<p>其它指令类似！</p>
<h3 id="汇编的功能"><a href="#汇编的功能" class="headerlink" title="汇编的功能"></a>汇编的功能</h3><table>
<thead>
<tr>
<th>代码段</th>
<th>功能</th>
<th>对应汇编格式</th>
</tr>
</thead>
<tbody><tr>
<td>bss段</td>
<td>BSS段通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文BlockStartedby Symbol的简称。BSS段属于静态内存分配。</td>
<td>.bss</td>
</tr>
<tr>
<td>data段</td>
<td>数据段通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</td>
<td>.comm</td>
</tr>
<tr>
<td>text段</td>
<td>代码段通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</td>
<td>.text</td>
</tr>
<tr>
<td>rodata段</td>
<td>存放C中的字符串和#define定义的常量</td>
<td>.rodata</td>
</tr>
<tr>
<td>stack栈</td>
<td>用户存放程序临时创建的局部变量</td>
<td>push和pop使用</td>
</tr>
</tbody></table>
<h3 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a>函数调用：</h3><p>经过我无数次直接从gcc 生成汇编观察出， 调用函数， 首先是参数压栈处理然后， ebp 的值压栈， 接下来返回地址压栈， 用一个图表示：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200130211927.png"></p>
<p>当调用函数时， 先扩大栈空间， 把参数压栈， 然后在被调用函数里面使用参数记得是 ebp 加上 8， 中间有返回地址和旧ebp的值！</p>
<h3 id="赋值语句实现："><a href="#赋值语句实现：" class="headerlink" title="赋值语句实现："></a>赋值语句实现：</h3><p>x86所有的寄存器是通用的， 想用那个就用哪个！</p>
<p>截取自ecc</p>
<pre><code># asign
movl    8(%esp),%esi
leal    12(%esp),%edi
movl    %esi,(%edi)</code></pre>
<p>其它类似。。。我用gcc 生成汇编，一步一步摸索出来的。。。</p>
]]></content>
  </entry>
  <entry>
    <title>matlab基础语法</title>
    <url>/2019/08/22/notepad/read/%E8%AF%AD%E8%A8%80/matlab%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="matlab基础语法"><a href="#matlab基础语法" class="headerlink" title="matlab基础语法"></a>matlab基础语法</h2><p>disp显示结果<br>clc用来清除命令窗口的显示内容<br>clear用来清除工作空间里的数据内容<br>Who、whos命令用来在命令窗口中显示工作空间的变量信息<br>warning off用来去除出现的警告<br>dir用来显示当前工作目录的文件和子目录清单<br>-cd用来显示或设置当前工作目录<br>type用来显示指定m文件的内容<br>quit或exit用来关闭/推出MATALB<br>disp(X)：用于显示变量X的值，并且不显示变量名称X<br>num2str(A)：用于将数字A转换为字符串，根据这个函数的构造很容易看出它的意思“number to string”，是不是很有意思<br>input()：用于用户对程序内输入数据，具体用法为x = input(prompt)或者str = input(prompt,’s’)，前者表示输入一个数值，后者表示输入一个字符串。当程序运行到这个地方时，在命令窗口内，需要用户输入一个数据，以回车键结束，那么这个数据会存储到x(如果使用的是字符型输入，则存储到str)，其中，prompt表示提示语，一般是一个字符串，而且这个字符串必须有（可以为空字符串””）。</p>
<h2 id="1-创建一维矩阵"><a href="#1-创建一维矩阵" class="headerlink" title="1. 创建一维矩阵"></a>1. 创建一维矩阵</h2><p>首先，介绍如何创建行矩阵。</p>
<p>方法一：使用方括号“[ ]”操作符<br>例如，创建一个一维矩阵a</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;[1 3 pi 3+5*i]  %or a&#x3D;[1, 3, pi, 3+5*i] </span><br><span class="line">a&#x3D; 1.0000      3.0000      3.1416       3.0000 + 5.0000i</span><br></pre></td></tr></table></figure>

<p>方法二：使用冒号“:”操作符<br>利用冒号“:”操作符创建行向量的基本语法格式：<br>x=Start : Increment : End</p>
<ol>
<li>Start表示新向量x的第一个元素；</li>
<li>新向量x的最后一个元素不能大于End ；</li>
<li>Increment可正可负，若负，则必须Start&gt;End；若正，则必须Start End，否则创建的为空向量；</li>
<li>若Increment=1,则可简写为x=Start:End。<br>例如，创建以1~10顺序排列整数为元素的行向量b<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#x3D;1 : 1 : 10</span><br><span class="line"> b&#x3D;1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure>
方法三：利用函数linspace<br>函数linspace的基本语法为：<br>x= linspace(x1, x2, n)</li>
<li>该函数生成一个由n个元素组成的行向量；</li>
<li>x1为其第一个元素；</li>
<li>x2为其最后一个元素；</li>
<li>x1、x2之间元素的间隔=(x2-x1)/(n-1)；</li>
<li>如果忽略参数n，则系统默认生成100个元素的行向量。<br>例如，键入并执行x= linspace(1,2,5)，结果为：<br>x=1.0000 1.2500 1.5000 1.7500 2.0000</li>
</ol>
<p>其次，介绍如何创建列矩阵</p>
<p>使用方括号“[ ]”操作符，使用分号“;”分割行。<br>例如：键入并执行x= [1; 2; 3]，结果如下：<br>   X=1<br>     2<br>     3</p>
<h2 id="2-创建二维矩阵"><a href="#2-创建二维矩阵" class="headerlink" title="2. 创建二维矩阵"></a>2. 创建二维矩阵</h2><p>方法一：使用方括号“[ ]”操作符<br>使用规则如下：</p>
<ol>
<li>数组元素必须在“[ ]”内键入；</li>
<li>行与行之间须用分号“;” 间隔，也可以在分行处用回车键间隔；</li>
<li>行内元素用空格或逗号“,”间隔。<br>例如，键入并执行a2=[1 2 3;4 5 6;7 8 9]，或者a2=[1:3;4:6;7:9]，结果都是：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a2&#x3D;</span><br><span class="line">    1  2  3</span><br><span class="line">    4  5  6</span><br><span class="line">    7  8  9</span><br></pre></td></tr></table></figure>
当然，由向量构成二维数组，例如（结果自行验证）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;a&#x3D;[1 2 3]; b&#x3D;[2 3 4]; </span><br><span class="line">&gt;&gt;c&#x3D;[a;b];</span><br><span class="line">&gt;&gt;c1&#x3D;[a b];</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line">方法二：函数方法</span><br><span class="line"></span><br><span class="line">函数ones(生成全1矩阵)、zeros (生成全0矩阵) 、reshape都可以创建初始矩阵。在命令窗口键入help elmat获得基本的矩阵生成和操作函数列表，这里仅展示全1矩阵ones的用法。</span><br></pre></td></tr></table></figure>
<p>例如，创建全1的3x3矩阵。</p>
<blockquote>
<blockquote>
<p>ones(3)<br>而创建全1的1x3的矩阵则是：<br>ones(1,3)<br>又例如，创建全1的3x4矩阵。<br>ones(3,4)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 矩阵元素的相关操作</span><br><span class="line">对于一个给定的矩阵，里面有很多元素，那么如何取出这些元素、如何更改这些元素呢？对于一个给定的矩阵，要想取出它的某个元素，可以使用括号()来实现。</span><br><span class="line"></span><br><span class="line">例如，现有一个3x4的二维矩阵A，想要取出第2行第3列的数据给b，可以表示如下：</span><br><span class="line">b&#x3D;A(2,3);</span><br><span class="line"></span><br><span class="line">想要将第1行第2列元素设置为10，表示如下：</span><br><span class="line">A(1,2)&#x3D;10;</span><br><span class="line"></span><br><span class="line">同样，对于一个拥有10个元素的一维矩阵B，取出它的第3个元素给c的操作为：</span><br><span class="line">c&#x3D;B(3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">您可以使用 save 命令将工作区中的变量保存到称为 MAT 文件的 MATLAB 特定格式文件中。</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>save foo x<br>以上命令将名为 x 的变量保存到名为 foo.mat 的 MAT 文件中。<br>您可以使用 load 命令从 MAT 文件加载变量。<br>load foo</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">您可以使用 MATLAB 关键字 end，作为行或列索引来引用最后一个元素。</span><br><span class="line"></span><br><span class="line">用作索引时，冒号运算符 (:) 可指代该维度中的所有元素。以下语法</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>x = A(2,:)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">会创建一个包含 A 中第 2 行上所有元素的行向量。</span><br><span class="line"></span><br><span class="line">#### .*   是按照元素相乘</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>doc fcnName<br>以获取任何 MATLAB 函数的相关信息。</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plot 函数接受一个附加参数，该参数让您能够在单引号中使用各种符号来指定颜色、线型和标记样式。</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>plot(x,y,’r–o’)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以上命令将会绘制一条红色 (r) 虚线 (--)，并使用圆圈 (o) 作为标记。您可以在线条设定的文档中了解有关可用符号的详细信息。</span><br><span class="line"></span><br><span class="line">您会注意到，最开始创建的绘图消失了。要在一张图上先后绘制两条线，请使用 hold on 命令保留之前的绘图，然后添加另一条线。</span><br><span class="line"></span><br><span class="line">close all  关闭所有的窗口</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 plot 函数时，您可在绘图参数和线条设定符之后添加属性名称-属性值对组。</p>
<blockquote>
<blockquote>
<p>plot(x,y,’ro-‘,’LineWidth’,5)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">使用 numel 函数返回数组中的元素数目。</span><br><span class="line"></span><br><span class="line">您可以使用逻辑数组作为数组索引，在这种情况下，MATLAB 会提取索引为 true 的数组元素。以下示例将会提取 v1 中大于 6 的所有元素。</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>v = v1(v1 &gt; 6)<br>v =<br>    6.6678<br>    9.0698</p>
</blockquote>
</blockquote>
<pre><code>
#### 用 vpa 显示小数。</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/06/notepad/read/%E8%AF%AD%E8%A8%80/%E5%8A%A8%E6%80%81%E6%80%A7%E3%80%81%E9%9D%99%E6%80%81%E6%80%A7%E3%80%81%E5%BC%BA%E7%B1%BB%E5%9E%8B%E3%80%81%E5%BC%B1%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a><center>语言特性</center></h2><p>关于语言特性的定义总是弄混，写篇博客记录一下！  彻底理清！</p>
<h3 id="强类型与弱类型"><a href="#强类型与弱类型" class="headerlink" title="强类型与弱类型"></a>强类型与弱类型</h3><ul>
<li>强类型：</li>
</ul>
<p>每个变量和对象都必须声明类型，在编译时确定好类型了，执行时不能更改。</p>
<p>偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double。</p>
<ul>
<li>弱类型：</li>
</ul>
<p>编译时不确定类型，执行时根据语义确定是哪种类型。通俗地说，弱类型偏向于容忍<strong>隐式转换</strong>，把不同类型的变量放在一起运算。</p>
<h3 id="动态性与静态性"><a href="#动态性与静态性" class="headerlink" title="动态性与静态性"></a>动态性与静态性</h3><ul>
<li>静态类型：</li>
</ul>
<p>编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。（编译不过）</p>
<ul>
<li>动态类型：</li>
</ul>
<p>编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。</p>
<p>一些编程语言的总结：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/f.png"></p>
<p>刚好每种类型的语言都有了解过！</p>
<ul>
<li>c / c ++  (弱类型和静态)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">1.0</span>; <span class="comment">//(可以自动向下转型， 1.0 -&gt; 1)  弱类型</span></span><br><span class="line">a = <span class="number">1.0</span>         <span class="comment">//自动转型，a已经是int型的了， 已经确定了类型，上一句已经显示声明了</span></span><br><span class="line"><span class="comment">// 再来看看20世纪的c语言 -- go</span></span><br><span class="line">a := <span class="number">10</span>			<span class="comment">//隐式声明， 声明为int型的变量， 不能变成其它类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>java（强类型和静态）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">1.0</span> <span class="comment">// error！！！  java 是强类型，不支持自动隐式转型</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="keyword">int</span>(<span class="number">1.0</span>); <span class="comment">// 强类型， 不愿意自动转换， 强行给你转了</span></span><br><span class="line">a = <span class="keyword">float</span>(<span class="number">1</span>) <span class="comment">//error 静态的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>python（强类型和动态）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1.0</span> + <span class="number">1</span>		</span><br><span class="line">a = <span class="number">1</span>   + <span class="number">1.0</span>    <span class="comment"># 这两种python都把a当做  float， 这不是弱类型吗？？？</span></span><br><span class="line">a = <span class="string">&quot;1&quot;</span> + <span class="number">1.0</span>    <span class="comment"># 这可就不行了， 类型相差太大， 从图中也可以看出， python 放到了接近中线的地方</span></span><br><span class="line">a = <span class="number">1</span>            <span class="comment"># a 又可以换类型， 换成int型的了！！！   动态性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>js（弱类型和动态）</li>
</ul>
<p><strong>js是世界上最强大的语言！</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1.01123</span> + <span class="number">1</span>   		</span><br><span class="line">a  = <span class="number">1.0</span> + <span class="string">&quot;1&quot;</span>			<span class="comment">// 1.0 由于弱类型转成string， 然后a有动态性 number类型转成string了	</span></span><br></pre></td></tr></table></figure>



<p>总结： java是最垃圾的语言！</p>
<p>当然静态语言也有优势， 类型的检查由程序员来检查， 而不是运行时由解释器检查， 这样加快了运行的速度！ 上面我说谁最强谁最弱是针对语言特性来说的，静态语言还有一个好处就是更加地安全，当项目庞大的时候， 可能就不知道这个变量是哪来的，用来干什么的了， 容易混用。</p>
<p>强类型不容易混乱数据， 比如当式子复杂的时候，有可能隐式转换类型失败，类型不对，在c++ 会经常遇到！</p>
<p>又得必有失！</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/06/notepad/read/%E8%AF%AD%E8%A8%80/%E5%8A%A8%E6%80%81%E6%80%A7%E4%B8%8E%E9%9D%99%E6%80%81%E6%80%A7%E3%80%81%E5%BC%BA%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%B1%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a><center>语言特性</center></h2><p>关于语言特性的定义总是弄混，写篇博客记录一下！  彻底理清！</p>
<h3 id="强类型与弱类型"><a href="#强类型与弱类型" class="headerlink" title="强类型与弱类型"></a>强类型与弱类型</h3><ul>
<li>强类型：</li>
</ul>
<p>每个变量和对象都必须声明类型，在编译时确定好类型了，执行时不能更改。</p>
<p>偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double。</p>
<ul>
<li>弱类型：</li>
</ul>
<p>编译时不确定类型，执行时根据语义确定是哪种类型。通俗地说，弱类型偏向于容忍<strong>隐式转换</strong>，把不同类型的变量放在一起运算。</p>
<h3 id="动态性与静态性"><a href="#动态性与静态性" class="headerlink" title="动态性与静态性"></a>动态性与静态性</h3><ul>
<li>静态类型：</li>
</ul>
<p>编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。（编译不过）</p>
<ul>
<li>动态类型：</li>
</ul>
<p>编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。</p>
<p>一些编程语言的总结：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/f.png"></p>
<p>刚好每种类型的语言都有了解过！</p>
<ul>
<li>c / c ++  (弱类型和静态)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">1.0</span>; <span class="comment">//(可以自动向下转型， 1.0 -&gt; 1)  弱类型</span></span><br><span class="line">a = <span class="number">1.0</span>         <span class="comment">//自动转型，a已经是int型的了， 已经确定了类型，上一句已经显示声明了</span></span><br><span class="line"><span class="comment">// 再来看看20世纪的c语言 -- go</span></span><br><span class="line">a := <span class="number">10</span>			<span class="comment">//隐式声明， 声明为int型的变量， 不能变成其它类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>java（强类型和静态）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">1.0</span> <span class="comment">// error！！！  java 是强类型，不支持自动隐式转型</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="keyword">int</span>(<span class="number">1.0</span>); <span class="comment">// 强类型， 不愿意自动转换， 强行给你转了</span></span><br><span class="line">a = <span class="keyword">float</span>(<span class="number">1</span>) <span class="comment">//error 静态的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>python（强类型和动态）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1.0</span> + <span class="number">1</span>		</span><br><span class="line">a = <span class="number">1</span>   + <span class="number">1.0</span>    <span class="comment"># 这两种python都把a当做  float， 这不是弱类型吗？？？</span></span><br><span class="line">a = <span class="string">&quot;1&quot;</span> + <span class="number">1.0</span>    <span class="comment"># 这可就不行了， 类型相差太大， 从图中也可以看出， python 放到了接近中线的地方</span></span><br><span class="line">a = <span class="number">1</span>            <span class="comment"># a 又可以换类型， 换成int型的了！！！   动态性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>js（弱类型和动态）</li>
</ul>
<p><strong>js是世界上最强大的语言！</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1.01123</span> + <span class="number">1</span>   		</span><br><span class="line">a  = <span class="number">1.0</span> + <span class="string">&quot;1&quot;</span>			<span class="comment">// 1.0 由于弱类型转成string， 然后a有动态性 number类型转成string了	</span></span><br></pre></td></tr></table></figure>



<p>总结： java是最垃圾的语言！</p>
<p>当然静态语言也有优势， 类型的检查由程序员来检查， 而不是运行时由解释器检查， 这样加快了运行的速度！ 上面我说谁最强谁最弱是针对语言特性来说的，静态语言还有一个好处就是更加地安全，当项目庞大的时候， 可能就不知道这个变量是哪来的，用来干什么的了， 容易混用。</p>
<p>强类型不容易混乱数据， 比如当式子复杂的时候，有可能隐式转换类型失败，类型不对，在c++ 会经常遇到！</p>
<p>又得必有失！</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/06/notepad/read/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/dubbo/</url>
    <content><![CDATA[<h1 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h1><p>[toc]</p>
<h2 id="RPC-基础概念"><a href="#RPC-基础概念" class="headerlink" title="RPC 基础概念"></a>RPC 基础概念</h2><h3 id="基础概念："><a href="#基础概念：" class="headerlink" title="基础概念："></a>基础概念：</h3><h5 id="响应时间-RT"><a href="#响应时间-RT" class="headerlink" title="响应时间(RT)"></a>响应时间(RT)</h5><p>响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。</p>
<p>对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个<strong>游戏软件来说，响应时间小于100毫秒应该是不错的</strong>，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。　</p>
<h5 id="吞吐量-Throughput"><a href="#吞吐量-Throughput" class="headerlink" title="吞吐量(Throughput)"></a>吞吐量(Throughput)</h5><p>​    吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。</p>
<p>​    对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。</p>
<h5 id="QPS每秒查询率-Query-Per-Second"><a href="#QPS每秒查询率-Query-Per-Second" class="headerlink" title="QPS每秒查询率(Query Per Second)"></a>QPS每秒查询率(Query Per Second)</h5><p>　每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）</p>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><h4 id="动态均衡算法："><a href="#动态均衡算法：" class="headerlink" title="动态均衡算法："></a>动态均衡算法：</h4><p>1、<strong>轮询法</strong></p>
<p>将请求按<strong>顺序轮流地分配到每个节点上</strong>，不关心每个节点实际的连接数和当前的系统负载。</p>
<p>优点：简单高效，易于水平扩展，每个节点满足字面意义上的均衡；</p>
<p>缺点：没有考虑机器的性能问题，根据木桶最短木板理论，集群性能瓶颈更多的会受性能差的服务器影响。</p>
<p> <strong>2、随机法</strong></p>
<p>将请求随机分配到各个节点。由概率统计理论得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配，也就是轮询的结果。</p>
<p>优缺点和轮询相似。</p>
<p><strong>3、源地址哈希法</strong></p>
<p>   源地址哈希的思想是根据<strong>客户端的IP地址</strong>，通过<strong>哈希函数</strong>计算得到一个数值，用该数值对服务器节点数进行取模，得到的结果便是要访问节点序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会落到到同一台服务器进行访问。</p>
<p>优点：相同的IP每次落在同一个节点，可以人为干预客户端请求方向，例如灰度发布；</p>
<p>缺点：如果某个节点出现故障，会导致这个节点上的客户端无法使用，<strong>无法保证高可用。</strong>当某一用户成为热点用户，那么会有巨大的流量涌向这个节点，导致冷热分布不均衡，无法有效利用起集群的性能。<strong>所以当热点事件出现时，一般会将源地址哈希法切换成轮询法。</strong></p>
<p><strong>4、加权轮询法</strong></p>
<p>   不同的后端服务器可能机器的配置和当前系统的<strong>负载并不相同，因此它们的抗压能力也不相同</strong>。<strong>给配置高、负载低的机器配置更高的权重</strong>，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
<p>加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。</p>
<p>优点：可以将不同机器的性能问题纳入到考量范围，集群性能最优最大化；</p>
<p>缺点：生产环境复杂多变，服务器抗压能力也无法精确估算，静态算法导致无法实时动态调整节点权重，只能粗糙优化。</p>
<p><strong>5、加权随机法</strong></p>
<p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
<p><strong>6、键值范围法</strong></p>
<p>根据键的范围进行负债，<strong>比如0到10万的用户请求走第一个节点服务器</strong>，10万到20万的用户请求走第二个节点服务器……以此类推。</p>
<p>优点：容易水平扩展，随着用户量增加，可以增加节点而不影响旧数据；</p>
<p>缺点：容易负债不均衡，比如新注册的用户活跃度高，旧用户活跃度低，那么压力就全在新增的服务节点上，旧服务节点性能浪费。而且也容易单点故障，无法满足高可用。</p>
<h4 id="动态均衡算法：-1"><a href="#动态均衡算法：-1" class="headerlink" title="动态均衡算法："></a>动态均衡算法：</h4><p><strong>1、最小连接数法</strong></p>
<p>根据每个节点当前的连接情况，动态地选取其中<strong>当前积压连接数最少的一个节点处理当前请求</strong>，尽可能地提高后端服务的利用效率，将请求合理地分流到每一台服务器。俗称闲的人不能闲着，大家一起动起来。</p>
<p>优点：动态，根据节点状况实时变化；</p>
<p>缺点：提高了复杂度，每次连接断开需要进行计数；</p>
<p>实现：将连接数的倒数当权重值。</p>
<p><strong>2、最快响应速度法</strong></p>
<p>根据请求的响应时间，来动态调整每个节点的权重，将<strong>响应速度快的服务节点分配更多的请求</strong>，响应速度慢的服务节点分配更少的请求，俗称能者多劳，扶贫救弱。</p>
<p>优点：动态，实时变化，控制的粒度更细，跟灵敏；</p>
<p>缺点：复杂度更高，每次需要计算请求的响应速度；</p>
<p>实现：可以根据响应时间进行打分，计算权重。</p>
<p><strong>3、观察模式法</strong></p>
<p>观察者模式是综合了<strong>最小连接数和最快响应度</strong>，同时考量这两个指标数，进行一个权重的分配。</p>
]]></content>
  </entry>
  <entry>
    <title>tinhttpd</title>
    <url>/2020/12/06/notepad/read/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/tinhttpd/</url>
    <content><![CDATA[<h1 id="tinhttpd"><a href="#tinhttpd" class="headerlink" title="tinhttpd"></a>tinhttpd</h1><p><a class="link"   href="https://www.cnblogs.com/nengm1988/p/7816618.html" >https://www.cnblogs.com/nengm1988/p/7816618.html<i class="fas fa-external-link-alt"></i></a></p>
<p>不断创建线程接受连接， 并解析http，解析完了之后，创建多个进程处理，每个子进程处理然后发送给父进程， 这里把处理和回复解耦， 处理的子进程可以调用其它的服务器，然后接受数据通过管道发给父进程， 父进程再返回给浏览器</p>
<p><img src="C:%5CUsers%5CFirefly%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426210029601.png" alt="image-20200426210029601"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/06/notepad/read/network/%E8%AE%A1%E7%BD%91%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<h1 id="计网总结"><a href="#计网总结" class="headerlink" title="计网总结"></a>计网总结</h1><p>javaguide 上的总结的很好，直接拿来充博客用！ 来自： <a class="link"   href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" >https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络<i class="fas fa-external-link-alt"></i></a></p>
<p>[toc]</p>
<h2 id="一-OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#一-OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="一 OSI与TCP/IP各层的结构与功能,都有哪些协议?"></a>一 OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="五层体系结构"></p>
<p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p>
<h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>
<p><strong>域名系统</strong></p>
<blockquote>
<p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a class="link"   href="http://www.ibm.com、oracle/" >www.ibm.com、Oracle<i class="fas fa-external-link-alt"></i></a> 公司的域名是 <a class="link"   href="http://www.oracle.com、cisco公司的域名是/" >www.oracle.com、Cisco公司的域名是<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="http://www.cisco.com/" >www.cisco.com<i class="fas fa-external-link-alt"></i></a> 等。</p>
</blockquote>
<p><strong>HTTP协议</strong></p>
<blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p>
</blockquote>
<h3 id="1-2-运输层"><a href="#1-2-运输层" class="headerlink" title="1.2 运输层"></a>1.2 运输层</h3><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p><strong>运输层主要使用以下两种协议:</strong></p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>
</ol>
<p><strong>TCP 与 UDP 的对比见问题三。</strong></p>
<h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>
<p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p>
<h3 id="1-4-数据链路层"><a href="#1-4-数据链路层" class="headerlink" title="1.4 数据链路层"></a>1.4 数据链路层</h3><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。<br>控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h3 id="1-5-物理层"><a href="#1-5-物理层" class="headerlink" title="1.5 物理层"></a>1.5 物理层</h3><p>在物理层上所传送的数据单位是比特。<br> <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p>
<h3 id="1-6-总结一下"><a href="#1-6-总结一下" class="headerlink" title="1.6 总结一下"></a>1.6 总结一下</h3><p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：<a class="link"   href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" >https://blog.csdn.net/yaopeng_2005/article/details/7064869<i class="fas fa-external-link-alt"></i></a></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="七层体系结构图"></p>
<h2 id="二-TCP-三次握手和四次挥手-面试常客"><a href="#二-TCP-三次握手和四次挥手-面试常客" class="headerlink" title="二 TCP 三次握手和四次挥手(面试常客)"></a>二 TCP 三次握手和四次挥手(面试常客)</h2><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<h3 id="2-1-TCP-三次握手漫画图解"><a href="#2-1-TCP-三次握手漫画图解" class="headerlink" title="2.1 TCP 三次握手漫画图解"></a>2.1 TCP 三次握手漫画图解</h3><p>如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)。<br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p>
<p><strong>简单示意图：</strong><br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="TCP三次握手"></p>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<h3 id="2-2-为什么要三次握手"><a href="#2-2-为什么要三次握手" class="headerlink" title="2.2 为什么要三次握手"></a>2.2 为什么要三次握手</h3><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h3 id="2-3-为什么要传回-SYN"><a href="#2-3-为什么要传回-SYN" class="headerlink" title="2.3 为什么要传回 SYN"></a>2.3 为什么要传回 SYN</h3><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="2-4-传了-SYN-为啥还要传-ACK"><a href="#2-4-传了-SYN-为啥还要传-ACK" class="headerlink" title="2.4 传了 SYN,为啥还要传 ACK"></a>2.4 传了 SYN,为啥还要传 ACK</h3><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP四次挥手"></p>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h3 id="2-5-为什么要四次挥手"><a href="#2-5-为什么要四次挥手" class="headerlink" title="2.5 为什么要四次挥手"></a>2.5 为什么要四次挥手</h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a class="link"   href="https://blog.csdn.net/qzcsu/article/details/72861891" >https://blog.csdn.net/qzcsu/article/details/72861891<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="三-TCP-UDP-协议的区别"><a href="#三-TCP-UDP-协议的区别" class="headerlink" title="三 TCP,UDP 协议的区别"></a>三 TCP,UDP 协议的区别</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h2 id="四-TCP-协议如何保证可靠传输"><a href="#四-TCP-协议如何保证可靠传输" class="headerlink" title="四 TCP 协议如何保证可靠传输"></a>四 TCP 协议如何保证可靠传输</h2><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。 </li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </li>
<li>TCP 的接收端会丢弃重复的数据。 </li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </li>
</ol>
<h3 id="4-1-ARQ协议"><a href="#4-1-ARQ协议" class="headerlink" title="4.1 ARQ协议"></a>4.1 ARQ协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h4 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h4><ul>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>
</ul>
<p><strong>优点：</strong> 简单</p>
<p><strong>缺点：</strong> 信道利用率低，等待时间长</p>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
<h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h3 id="4-2-滑动窗口和流量控制"><a href="#4-2-滑动窗口和流量控制" class="headerlink" title="4.2 滑动窗口和流量控制"></a>4.2 滑动窗口和流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="4-3-拥塞控制"><a href="#4-3-拥塞控制" class="headerlink" title="4.3 拥塞控制"></a>4.3 拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>
<li><strong>快重传与快恢复：</strong><br> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h2 id="五-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客"><a href="#五-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客" class="headerlink" title="五  在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)"></a>五  在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</h2><p>百度好像最喜欢问这个问题。</p>
<blockquote>
<p>打开一个网页，整个过程会使用哪些协议</p>
</blockquote>
<p>图解（图片来源：《图解HTTP》）：</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url输入到展示出来的过程.jpg" style="zoom:50%;" />

<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这篇文章：</p>
<ul>
<li><a class="link"   href="https://segmentfault.com/a/1190000006879700" >https://segmentfault.com/a/1190000006879700<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="六-状态码"><a href="#六-状态码" class="headerlink" title="六 状态码"></a>六 状态码</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="状态码"></p>
<h2 id="七-各种协议与HTTP协议之间的关系"><a href="#七-各种协议与HTTP协议之间的关系" class="headerlink" title="七 各种协议与HTTP协议之间的关系"></a>七 各种协议与HTTP协议之间的关系</h2><p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>
<p>图片来源：《图解HTTP》</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种协议与HTTP协议之间的关系"></p>
<h2 id="八-HTTP长连接-短连接"><a href="#八-HTTP长连接-短连接" class="headerlink" title="八  HTTP长连接,短连接"></a>八  HTTP长连接,短连接</h2><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong> </p>
<p>—— <a class="link"   href="https://www.cnblogs.com/gotodsp/p/6366163.html" >《HTTP长连接、短连接究竟是什么？》<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="九-HTTP是不保存状态的协议-如何保存用户状态"><a href="#九-HTTP是不保存状态的协议-如何保存用户状态" class="headerlink" title="九 HTTP是不保存状态的协议,如何保存用户状态?"></a>九 HTTP是不保存状态的协议,如何保存用户状态?</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP  协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HTTP%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84.png" alt="HTTP是无状态协议"></p>
<h2 id="十-Cookie的作用是什么-和Session有什么区别？"><a href="#十-Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="十 Cookie的作用是什么?和Session有什么区别？"></a>十 Cookie的作用是什么?和Session有什么区别？</h2><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p> <strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="十一-HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#十一-HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="十一 HTTP 1.0和HTTP 1.1的主要区别是什么?"></a>十一 HTTP 1.0和HTTP 1.1的主要区别是什么?</h2><blockquote>
<p>这部分回答引用这篇文章 <a class="link"   href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A" >https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?<i class="fas fa-external-link-alt"></i></a> 的一些内容。</p>
</blockquote>
<p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<ol>
<li><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<h2 id="十二-URI和URL的区别是什么"><a href="#十二-URI和URL的区别是什么" class="headerlink" title="十二 URI和URL的区别是什么?"></a>十二 URI和URL的区别是什么?</h2><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="十三-HTTP-和-HTTPS-的区别？"><a href="#十三-HTTP-和-HTTPS-的区别？" class="headerlink" title="十三 HTTP 和 HTTPS 的区别？"></a>十三 HTTP 和 HTTPS 的区别？</h2><ol>
<li><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>
<li><strong>安全性和资源消耗：</strong> HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
</li>
</ol>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>非常推荐大家看一下 《图解HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a class="link"   href="https://blog.csdn.net/qq_16209077/article/details/52718250" >https://blog.csdn.net/qq_16209077/article/details/52718250<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/zixiaomuwu/article/details/60965466" >https://blog.csdn.net/zixiaomuwu/article/details/60965466<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/turn__back/article/details/73743641" >https://blog.csdn.net/turn__back/article/details/73743641<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A" >https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/03/notepad/read/os/os/</url>
    <content><![CDATA[<h1 id="操作系统复习指南"><a href="#操作系统复习指南" class="headerlink" title="操作系统复习指南"></a><center>操作系统复习指南</center></h1><h2 id="1-CPU-调度算法"><a href="#1-CPU-调度算法" class="headerlink" title="1.CPU 调度算法"></a>1.CPU 调度算法</h2><blockquote>
<p>了解CPU 调度算法，如先到先服务、最短作业优先、轮转、多级反馈队列等调度算法，<br>以及掌握多处理器调度的特殊性。</p>
</blockquote>
<p>T<del>周转时间</del>  =  T<del>完成时间</del>  -  T <del>到达时间</del></p>
<p>FIFO：     平均周转时间很大</p>
<p>SJF：         当一个长时间的任务先到达时，平均周转时间也会很大， 因为不能停止执行。</p>
<p>STCF：     放宽假设条件， 进程可以上下切断， 周转时间很好。</p>
<p>T<del>响应时间</del>  =  T<del>首次运行</del>  -  T <del>到达时间</del></p>
<p>STCF 的响应时间不好 ， 引入RR。</p>
<p>RR：根据时间片切换进程，均摊上下文切换成本，RR响应时间好， 但周转时间不好， 陷入死循环。。。</p>
<p>于是引入MLFQ， 综合解决两个问题。</p>
<p>MLFQ：</p>
<ul>
<li><p>相同优先级的进程按RR调度</p>
</li>
<li><p>如果 优先级  A &gt; B ， 先运行A</p>
</li>
<li><p>初始工作时，放到最高优先级队列中</p>
</li>
<li><ul>
<li>工作用完优先级后，降低优先级</li>
<li>如果在工作在时间片内主动释放cpu， 优先级不变</li>
</ul>
</li>
<li><p>经过一段时间，重新把所有的的进程放到最高优先级</p>
</li>
</ul>
<p>进程可能恶意每次都在快运行完的时候主动释放cpu， 因此，更改第四条如下</p>
<ul>
<li>如果进程用完了，一个优先级上的时间片段， 则降低优先级，无论是否主动释放cpu</li>
</ul>
<p>确保每一个工作获得一定的比例的cpu时间， 而不是优化cpu的周转时间和响应时间， 引入比例份额调度。</p>
<p>彩票调度： 按彩票的数量多少来运行程序， 彩票多概率大运行多，当任务短的时候，有随机性， 引入步长调度</p>
<p>步长调度： 步伐短运行地多，无论怎样都是按比例，缺点是需要<strong>全局状态</strong>， 当一个新的进程加入时， 要更新全部进程的当前步长， 彩票调度只需要一个<strong>全局变量</strong>，总的彩票数。</p>
<p>多处理器调度： 处理缓存一致性问题， 硬件上，cpu监听总线更改缓存，软件上：</p>
<p>单队列调度（SQMS）： 简单，但是缓存不亲和</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200107152722.png"></p>
<p>多队列调度（MQMS）：天生缓存亲和， 但负载不均衡！（工作窃取）</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200107164327.png"></p>
<p>上图可以看出， A进程独占cpu， 工作窃取，就是定时查看其他cpu的工作负载。</p>
<h2 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2.进程和线程"></a>2.进程和线程</h2><blockquote>
<p>掌握进程和线程的概念，熟练使用进程和线程相关编程接口，如fork，exec，wait，<br>pthread_create，pthread_join等。</p>
</blockquote>
<h3 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h3><p>进程就是运行中的程序， 一个进程可以创建多个线程。</p>
<p>进程之间不共用内存， 线程之间可以共用内存， 但每一个线程都有自己的堆栈。</p>
<ul>
<li>fork()</li>
</ul>
<p>子进程改变全局变量不会改变父进程的值， 子进程有自己的程序运行空间， copy自父进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#inclucde <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world(pid: %d)\n&quot;</span>,(<span class="keyword">int</span>)getpid);</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc &lt; <span class="number">0</span>) &#123;<span class="comment">// 创建失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>+ <span class="built_in">stderr</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;<span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am child (pid: %d)&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//!!!!!!!! 注意父进程的 rc 值是 子进程的 pid</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am parent of %d (pid: %d)&quot;</span>, rc, (<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>waidpid（）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#inclucde <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world(pid: %d)\n&quot;</span>,(<span class="keyword">int</span>)getpid);</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc &lt; <span class="number">0</span>) &#123;  <span class="comment">// 创建失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>+ <span class="built_in">stderr</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;<span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am child (pid: %d)&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//!!!!!!!! 注意父进程的 rc 值是 子进程的 pid</span></span><br><span class="line">    	<span class="keyword">int</span> wc == wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am parent of %d (wc: %d) (pid: %d)&quot;</span>, rc, wc, (<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rc = wc </p>
<p>fork 用作相同程序的拷贝作用，执行不同的程序时， 可以用</p>
<ul>
<li>exec()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argc[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span> + <span class="built_in">stderr</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;</span><br><span class="line">        close(STDOUT_FILENO);<span class="comment">// 关闭标准输入与输出</span></span><br><span class="line">        open(<span class="string">&quot;./p4,output&quot;</span>,O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);  </span><br><span class="line">        <span class="keyword">char</span> * myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>; <span class="comment">// 可运行的程序</span></span><br><span class="line">        myargs[<span class="number">1</span>] = <span class="string">&quot;file.c&quot;</span>;</span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        execvp(myargs[<span class="number">0</span>],myargs);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);<span class="comment">// this will be not ecec</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>// todo</p>
<h3 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">( <span class="keyword">pthread_t</span> * thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> * attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> * (*start_routine)(<span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> * arg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、第一个是指向 pthread_t 的指针， 用于交互</span></span><br><span class="line"><span class="comment">2、第二个是设置新的线程的，栈大小等等信息</span></span><br><span class="line"><span class="comment">3、执行的函数</span></span><br><span class="line"><span class="comment">4、参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> * thread,<span class="keyword">void</span> ** value_ptr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//第一个参数为创建的时候，保留的指针， 第二个为返回值</span></span></span><br></pre></td></tr></table></figure>









<h2 id="3-并发同步"><a href="#3-并发同步" class="headerlink" title="3.并发同步"></a>3.并发同步</h2><blockquote>
<p>掌握进程并发同步相关概念，如死锁、活锁等概念，真实应用中存在的不同类型的同步<br>问题，熟练使用pthread库中的相关同步函数进行编程。</p>
</blockquote>
<p>题目说，进程并发同步的相关概念， 让我对进程和线程的理解再次产生怀疑，首先再次总结一下：</p>
<p>进程是为运行中的程序提供的一个抽象，线程是为单个运行的进程提供的抽象，多线程程序有多个执行点， 每个线程类似于进程， 唯一的区别是： 线程之间共享地址空间，能够访问相同的数据（在堆上的数据或者全局变量， 不是局部变量）。</p>
<p>非死锁：</p>
<ul>
<li>违反原子性</li>
<li>违反顺序缺陷</li>
</ul>
<h3 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h3><p>产生原因：</p>
<ul>
<li><p>组件之间会有复杂的依赖</p>
</li>
<li><p>模块化会封装细节</p>
</li>
</ul>
<p>解决方案：</p>
<p>所有的线程获取锁的顺序如果是相同的就不会产生死锁</p>
<p>产生条件：</p>
<ul>
<li>互斥</li>
</ul>
<p>使用硬件支持， 使用不用锁的数据结构！</p>
<ul>
<li>持有并等待</li>
</ul>
<p>或取多个锁时： 可以用一个把大的锁锁住， 即使防止获取锁的过程中，上下文切换！</p>
<ul>
<li>非抢占</li>
</ul>
<p>获取第一个锁后，查看第二个锁是否被占有， 如果占有直接放弃第一个锁，再次获取第一个锁， 这样存在一个问题， 两个锁一直重复这个问题， 倒置<strong>活锁</strong></p>
<ul>
<li>循环等待</li>
</ul>
<p>锁的获取按照一定的顺序获取等待</p>
<h2 id="4-地址空间"><a href="#4-地址空间" class="headerlink" title="4.地址空间"></a>4.地址空间</h2><blockquote>
<p>掌握地址空间的概念，以及用户态堆内存的管理。</p>
</blockquote>
<p>一个进程的地址空间应该包含运行的程序的所有内存状态，操作系统给程序的抽象， 包括代码块， 堆，栈，真实的<strong>物理空间</strong>可能在任意的地方，地址空间是连续的0KB -&gt; 16KB 。如下图：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104151718.png"></p>
<p>所谓堆内存（属于地址空间）， 申请和释放都是又程序猿自己自己自己完成（注意这里操作的是地址空间，虚拟的）。java不用</p>
<h3 id="分配："><a href="#分配：" class="headerlink" title="分配："></a>分配：</h3><p> void malloc（size_t size） , size大小一般为宏来设定， 比如 sizeof(double),  注意 void 的返回类型 是返回地址的指针，可以强转， 如下：</p>
<p>int *x = malloc(sizeof(int));</p>
<h3 id="释放："><a href="#释放：" class="headerlink" title="释放："></a>释放：</h3><p> free(x)   , 分配的大小不会被用户传入， 必须由<strong>内存分配库</strong>本身记录追踪。</p>
<h3 id="常见错误："><a href="#常见错误：" class="headerlink" title="常见错误："></a>常见错误：</h3><ul>
<li><p>忘记分配内存（这个常犯， 常犯， 给一个指针赋值！！！！指针是存放在栈中的， 4个字节的）</p>
</li>
<li><p>没有分配足够的内存</p>
</li>
<li><p>忘记初始化分配的内存， NULL 一般输出为 0， 但0 不等于 NULL ，默认都是0</p>
</li>
<li><p>忘记释放内存（这个我一般都不是释放 ^ _ ^，web、操作系统等长时间运行的程序一定需要！！）</p>
</li>
<li><p>反复释放内存（内存都不释放， 这个绝对不会发生的）</p>
</li>
<li><p>用完之前释放内存</p>
</li>
<li><p>错误调用free（）， 参数传入错误的值。</p>
</li>
</ul>
<h2 id="5-同步原语"><a href="#5-同步原语" class="headerlink" title="5.同步原语"></a>5.同步原语</h2><p>掌握锁、条件变量、信号量三种同步机制（熟练使用pthread库中的函数），并使用这些<br>机制解决实际应用问题，如生产者消费者问题。</p>
<h3 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h3><p>锁就是一个<strong>变量</strong>， 锁为程序员提供了最小程度的调度控制，线程是操作系统的cpu调度的最小单位。</p>
<h4 id="实现锁"><a href="#实现锁" class="headerlink" title="实现锁"></a>实现锁</h4><h5 id="控制中断"><a href="#控制中断" class="headerlink" title="控制中断"></a>控制中断</h5><p>通过控制中断， 让代码原子执行</p>
<p>缺点很多， 不支持多cpu， 出现系统问题，操作系统需要控制中断来获取控制权。。。</p>
<h5 id="TestAndSet"><a href="#TestAndSet" class="headerlink" title="TestAndSet"></a>TestAndSet</h5><p>这条指令基于硬件的支持，等价于下面代码是<strong>原子执行</strong>的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *old_ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *old = old_ptr;</span><br><span class="line">	*old_ptr = <span class="keyword">new</span>;</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自旋锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line"> 	<span class="keyword">int</span> flag;</span><br><span class="line"> &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line"> 	lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//上面会一直自旋，浪费cpu资源， 也可能一直自旋永远得不到执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> * lock)</span></span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FetchAndAdd"><a href="#FetchAndAdd" class="headerlink" title="FetchAndAdd"></a>FetchAndAdd</h5><p>这也是一个硬件支持的原语，这一条指令等价于下面原子执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FetchAndAdd(<span class="keyword">int</span> *ptr)&#123;</span><br><span class="line">	<span class="keyword">int</span> old = *ptr;</span><br><span class="line">	*ptr = old + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个公平的自旋锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line"> 	<span class="keyword">int</span> ticket;</span><br><span class="line"> 	<span class="keyword">int</span> turn;</span><br><span class="line"> &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line"> 	lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="comment">// 这里每一一次测试都会增加， 让每一个线程都能得到执行！</span></span><br><span class="line">    <span class="keyword">while</span>(lock-&gt;trun != myturn);</span><br><span class="line">    <span class="comment">//这里还是会自旋</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面硬件原语的支持虽然实现了简单的公平锁， 但是它会自旋，下面实现不自旋的公平锁</p>
<h4 id="实现公平不自旋锁"><a href="#实现公平不自旋锁" class="headerlink" title="实现公平不自旋锁"></a>实现公平不自旋锁</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> flag;</span><br><span class="line"> 	<span class="keyword">int</span> guard;</span><br><span class="line">	<span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"> 	m-&gt;flag = <span class="number">0</span>;</span><br><span class="line"> 	m-&gt;guard = <span class="number">0</span>;</span><br><span class="line"> 	queue_init(m-&gt;q);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 这里虽然也会自旋， 但是这个guard，在一个线程获取锁后（后面的else），guard也设置成了0，</span></span><br><span class="line">     <span class="comment">//也就是说，即使已经有线程获取了锁， 这条指令还是有可能通过的， 不会一直在这里自旋，只会自旋几个周期</span></span><br><span class="line">	<span class="comment">// guard的作用是保证后面的flag的设置是原子进行的</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 这里保证的原子的执行了， 因为其它指令的gurad为1，进不来这里， 不会有两个线程同时进入这里</span></span><br><span class="line"> 	<span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;<span class="comment">// 如果能获取到锁</span></span><br><span class="line"> 		m-&gt;flag = <span class="number">1</span>; </span><br><span class="line"> 		m-&gt;guard = <span class="number">0</span>;<span class="comment">// 重置为0</span></span><br><span class="line"> 	&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果没有获取到锁</span></span><br><span class="line"> 		queue_add(m-&gt;q, gettid());<span class="comment">// 加入队列，休眠队列</span></span><br><span class="line"> 		m-&gt;guard = <span class="number">0</span>;<span class="comment">// guard这里也重置为0</span></span><br><span class="line"> 		park();</span><br><span class="line">        <span class="comment">//这个是操作系统提供给程序员的函数， 休眠自己，在c语言中， 每种操作系统可以提供不同的</span></span><br><span class="line">        <span class="comment">//函数库供程序猿调度，在 java统一为yeild（）， linux中使用c也为 yeild（）</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">//通过自旋获取guard</span></span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">		 m-&gt;flag = <span class="number">0</span>; <span class="comment">// 空的话flag直接设置0</span></span><br><span class="line"> 	<span class="keyword">else</span></span><br><span class="line">		 unpark(queue_remove(m-&gt;q)); </span><br><span class="line"> 		<span class="comment">// 这里并没有将 flag设置0， 因为要保证公平性， 按照队列的线程来进行唤醒，这样</span></span><br><span class="line">    <span class="comment">// 队列里的每一个线程都能够得到执行，直接将flag的1 使用权传给了队列的第一个线程</span></span><br><span class="line"> 	m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码还有一个很微妙的竞态条件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">queue_add(m-&gt;q, gettid());</span><br><span class="line">m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">park();</span><br></pre></td></tr></table></figure>

<p>假设这段代码执行完前两句语句， 此时guard 变成了0，  释放锁的线程可以运行了， 而这个线程已经在休眠队列里面，但是它却还没有休眠， 这是如果唤醒了它，相当于白唤醒， 之后它执行park又再次休眠，而没加入队列里面了。结果就是永久休眠。 所以linux的实现有一个再次确认的代码！！！ </p>
<p>linux 也是使用这种思想， 但是提供的原语不同。</p>
<p>锁的实现已经完成了，但是还有一种情况，当父进程等待子进程结束的时候，就要用到下面的同步原语：</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cond_wait(<span class="keyword">pthread_cond_t</span> *c, <span class="keyword">pthread_mutex_t</span> *m);</span><br><span class="line">pthread_cond_signal(<span class="keyword">pthread_cond_t</span> *c);</span><br></pre></td></tr></table></figure>

<p>实现子进程等带父进程：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;m);</span><br><span class="line"> 	done = <span class="number">1</span>;</span><br><span class="line"> 	Pthread_cond_signal(&amp;c);</span><br><span class="line">    <span class="comment">//唤醒因为条件c而休眠你的线程</span></span><br><span class="line"> 	Pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line"> 	thr_exit();</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;m);</span><br><span class="line">    <span class="comment">//为什么要锁呢？ 因为下面wait函数有释放锁！！！！！！！！！！！</span></span><br><span class="line"> 	<span class="keyword">while</span> (done == <span class="number">0</span>)			</span><br><span class="line"> 	Pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    1、 这里要使用一个done来标记时候是否完成， 如果不用， 子进程先于父进程完成的时候，就会卡主</span></span><br><span class="line"><span class="comment"> 	因为子进程已经过了唤醒父进程，而父进程又重新休眠，这样没有线程唤醒父进程</span></span><br><span class="line"><span class="comment"> 	2、当调用了这条命令之后， 线程首先会将** 锁释放 **，然后调用线程休眠自己，（原子操作）</span></span><br><span class="line"><span class="comment">	3、要用while， 而不能用if，在这里使用if正确， 但是有多个信号的时候， 可能会出现1 的情况</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line"> 	Pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line"> 	<span class="keyword">pthread_t</span> p;</span><br><span class="line"> 	Pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);<span class="comment">//创建新的线程</span></span><br><span class="line"> 	thr_join();		<span class="comment">//等待子线程完成</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书上没有给出条件变量的实现方法，但是通过其功能描述结合锁的实现应该也略知一二！</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是dijkstra提出的，可以用作为锁和条件变量， 让同步原语更加通用。</p>
<p>信号量是一个<strong>整形数值</strong>的对象, 下面是POSIX库的使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">sem_s s;</span><br><span class="line">sem_init(&amp;s,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">sem_wait(sem_s *s);</span><br><span class="line">sem_post(sem_s *s);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一共有三个参数：</span></span><br><span class="line"><span class="comment">1、 s是传入一个信号量</span></span><br><span class="line"><span class="comment">2、0表示同一进程多个线程共享， 当为其它的时候， 可以在不同的进程中通知</span></span><br><span class="line"><span class="comment">3、初始化信号量的值为 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="实现信号量"><a href="#实现信号量" class="headerlink" title="实现信号量"></a>实现信号量</h4><p>基于锁和信号量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Zem_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">	<span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; Zem_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_init</span><span class="params">(Zem_t *s, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	s-&gt;value = value;</span><br><span class="line">	Cond_init(&amp;s-&gt;cond);</span><br><span class="line">	Mutex_init(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_wait</span><span class="params">(Zem_t *s)</span> </span>&#123;</span><br><span class="line"> 	Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line"> 	<span class="keyword">while</span> (s-&gt;value &lt;= <span class="number">0</span>)<span class="comment">//当初始化的value小于等于0 的时候等待当前的线程</span></span><br><span class="line"> 		Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);</span><br><span class="line"> 	s-&gt;value--;			<span class="comment">// value 减去1不能放到上面，原因在下面</span></span><br><span class="line"> 	Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Zem_post</span><span class="params">(Zem_t *s)</span> </span>&#123;</span><br><span class="line">	Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line"> 	s-&gt;value++;  		<span class="comment">//唤醒一个等待着的线程，对应的value 加上1</span></span><br><span class="line"> 	Cond_signal(&amp;s-&gt;cond);</span><br><span class="line"> 	Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>看了实现之后， 很容易就能用一个信号量实现一个锁</p>
<h4 id="信号量实现条件变量"><a href="#信号量实现条件变量" class="headerlink" title="信号量实现条件变量"></a>信号量实现条件变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">	sem_post(&amp;s); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	sem_init(&amp;s, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 这里初始化为0，</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> c;</span><br><span class="line">	Pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">	sem_wait(&amp;s); </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    有两种情况考虑：</span></span><br><span class="line"><span class="comment">    1、 当父进程线运行时， 信号量的值为0，休眠自己，此时不会减去1</span></span><br><span class="line"><span class="comment">    	子进程运行post的时候，唤醒了父进程，value加上了1，变成1</span></span><br><span class="line"><span class="comment">    	********* 父进程继续运行，减去1 ， 信号量重新变为0， 这就是value - 1 不能放上面的原因！！</span></span><br><span class="line"><span class="comment">    2、 当子进程先运行的时候， value加上了1， 等于1</span></span><br><span class="line"><span class="comment">    	当父进程运行的时候， value为1， 不用等了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二值信号量（锁）"><a href="#二值信号量（锁）" class="headerlink" title="二值信号量（锁）"></a>二值信号量（锁）</h4><p>初始化信号量的值为1，这就实现了一个锁！！！</p>
<p>当有一个进程获取锁之后， value 就变成了0， 其它线程要进入必须等待被唤醒。</p>
<p>当有多个线程在休眠时， 多个线程同时被唤醒， 多个线程会抢占锁，谁先抢到谁先起来， 这里应该是存在不公平现象的， 有可能有些线程一直得不到执行！？？？？？？？应该只有一个线程会被唤醒！！！？？？</p>
<p>上面理解错误！！！！不会有多个被唤醒的情况， 条件变量目前只有一个在等待</p>
<p>应该是按照fifo来的</p>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><h4 id="基于条件变量和锁"><a href="#基于条件变量和锁" class="headerlink" title="基于条件变量和锁"></a>基于条件变量和锁</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buffer[MAX];</span><br><span class="line"><span class="keyword">int</span> fill_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> use_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	buffer[fill_ptr] = value;</span><br><span class="line"> 	fill_ptr = (fill_ptr + <span class="number">1</span>) % MAX;</span><br><span class="line"> 	count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> tmp = buffer[use_ptr];</span><br><span class="line"> 	use_ptr = (use_ptr + <span class="number">1</span>) % MAX;</span><br><span class="line"> 	count--;</span><br><span class="line"> 	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">cond_t</span> empty, fill;</span><br><span class="line"> <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里要使用两个条件变量， 如果只使用一个， 而条件变量的唤醒不是按照队列来的，这时</span></span><br><span class="line"><span class="comment">假设有两个消费者因为没有count休眠</span></span><br><span class="line"><span class="comment">而生产者生产满了之后， 就去休眠了， 等待唤醒</span></span><br><span class="line"><span class="comment">此时一个消费者先被唤醒，消费完count后， 唤醒了另一个消费者，发现count已经没了，也去休眠，</span></span><br><span class="line"><span class="comment">此时没人唤醒生产者了。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"> 		Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1</span></span><br><span class="line">        <span class="keyword">while</span> (count == MAX) <span class="comment">// p2</span></span><br><span class="line">            Pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">// p3</span></span><br><span class="line">        put(i); <span class="comment">// p4</span></span><br><span class="line">        Pthread_cond_signal(&amp;fill); <span class="comment">// p5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6</span></span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// c2</span></span><br><span class="line">         	Pthread_cond_wait(&amp;fill, &amp;mutex); <span class="comment">// c3</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里使用while，而不是if， 原因：</span></span><br><span class="line"><span class="comment">        当有多个消费者时， 其中一个消费者先运行，发现count = 0，休眠， 接下来生产者生产一个</span></span><br><span class="line"><span class="comment">        count = 1， 这时另一个消费者运行， 把数据取走， 此时count = 0； 假设接下来是</span></span><br><span class="line"><span class="comment">        刚才那个休眠的消费者继续运行，此时count已经是0了， 而如果使用if， if只会判断一次， </span></span><br><span class="line"><span class="comment">        刚才休眠的时候已经判断过了，所以这个消费者会继续运行， count -= 1； = -1！！！</span></span><br><span class="line"><span class="comment">        所以要使用while ， while 会重新回来判断！！</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> tmp = get(); <span class="comment">// c4</span></span><br><span class="line">        Pthread_cond_signal(&amp;empty); <span class="comment">// c5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="基于信号量"><a href="#基于信号量" class="headerlink" title="基于信号量"></a>基于信号量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"> 		sem_wait(&amp;mutex); <span class="comment">// Line P0 (NEW LINE)</span></span><br><span class="line">        sem_wait(&amp;empty); <span class="comment">// Line P1</span></span><br><span class="line">        put(i); <span class="comment">// Line P2</span></span><br><span class="line">        sem_post(&amp;full); <span class="comment">// Line P3</span></span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// Line P4 (NEW LINE)</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">         sem_wait(&amp;mutex); <span class="comment">// Line C0 (NEW LINE)</span></span><br><span class="line">         sem_wait(&amp;full); <span class="comment">// Line C1</span></span><br><span class="line">         <span class="keyword">int</span> tmp = get(); <span class="comment">// Line C2</span></span><br><span class="line">         sem_post(&amp;empty); <span class="comment">// Line C3</span></span><br><span class="line">         sem_post(&amp;mutex); <span class="comment">// Line C4 (NEW LINE)</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="6-分段与分页"><a href="#6-分段与分页" class="headerlink" title="6.分段与分页"></a>6.分段与分页</h2><blockquote>
<p>掌握虚拟内存管理中的分段与分页机制的原理，以及比较其优缺点。</p>
</blockquote>
<h3 id="动态重定位："><a href="#动态重定位：" class="headerlink" title="动态重定位："></a><strong>动态重定位</strong>：</h3><p>基于硬件的动态重定位，使用内存管理单元（MMU）给<strong>地址空间</strong>分配内存，效率低下， 造成很多内部碎片（图中allocated but not use）。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20200104152143704.png"></p>
<h3 id="分段："><a href="#分段：" class="headerlink" title="分段："></a>分段：</h3><p>因此引入分段解决内部碎片问题：MMU给<strong>地址空间</strong>内的每一个逻辑段都分配内存。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20200104152706215.png"></p>
<p>段的引用： 显示方式</p>
<img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104153148.png" style="zoom:80%;" />

<p>于是乎， 在内存上产生很多<strong>外部碎片</strong>， 解决方法，基于空闲列表 和 各种管理算法：</p>
<p>这里我觉得不会考，但列一列：</p>
<ul>
<li><p>最优匹配</p>
</li>
<li><p>最差匹配</p>
</li>
<li><p>首次匹配</p>
</li>
<li><p>下次匹配</p>
</li>
<li><p>分离空闲列表：经常申请的内存空间，给它一个独立的列表</p>
</li>
<li><p>伙伴系统： 二分分配， 合并和分配的时候很方便， 二进制与二叉树的巧合</p>
</li>
</ul>
<p>可以看出分段会产生外部碎片， 这是一个很根本的问题，不通用， 即使有管理内存算法！</p>
<p>以上不会考的，应该考二级页表！</p>
<h3 id="分页："><a href="#分页：" class="headerlink" title="分页："></a>分页：</h3><p>分页不是将一个<strong>地址空间</strong>按逻辑段分， 而是分割成固定大小的单元，称为 <strong>页帧</strong>。</p>
<p>页表： 记录每一个地址空间的每一个<strong>虚拟页</strong>（<strong>页帧</strong>）在物理内存中的位置，==页表是每一个进程数据结构==。</p>
<p>物理帧号（PFN）或称 物理页号（PPN physical page number）： 真实的物理 <strong>页帧</strong> 地址。</p>
<ul>
<li>地址空间划分：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104162855.png"></p>
<ul>
<li>物理地址划分</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104162939.png"></p>
<p>页表项（PTE page table entry）： 记录 PFN </p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104160826.png"></p>
<p>上图中中间的地址转换（address translation）就通过页表来存储！！</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p><strong>地址空间</strong> 地址 21  -&gt; 010101  <img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104160907.png"></p>
<p>从物理地址 （vpn 01 推出 ）中拿出PTE，取出 PFN 得到地址空间的真实的物理地址， 偏移量不变， 因为页帧一样大。</p>
<p>如何拿出vpn对应的PTE：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT             <span class="comment">//取出VPN</span></span><br><span class="line">PTEAddr = PageTableBaseRegister + (VPN * <span class="keyword">sizeof</span>(PTE))  <span class="comment">// 算出物理地址， 拿到PTE的物理地址</span></span><br></pre></td></tr></table></figure>

<p>于是呢， 有两次的内存访问， ==慢==！</p>
<p>页表存放：</p>
<p>简单的存放线性页表， 32 位的地址空间， 4KB（2^ 12）的页大小（大部分os，windows，linux），PTE个数：2^32 / 2^12 = 2^20,  PTE大小（假设）4B， 线性页表大小 4B * 2^20 = 4MB, 所以一个进程就 4MB内存， 10个就==。。。==</p>
<p>以上就是页表的两个缺点！</p>
<p>先比较优缺点：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分段</td>
<td align="center">很好支持稀疏地址空间，很快，算法简单，适合硬件完成，地址转换的开销极小， 代码共享（如果代码独立的段中，可以被多个运行程序共享）。</td>
<td align="center">不支持<strong>一般化</strong>的稀疏地址，产生外部碎片问题很根本，难以避免，随时间推移，管理难，分配也困难。</td>
</tr>
<tr>
<td align="center">分页</td>
<td align="center">不会导致外部碎片， 很灵活，支持稀疏的地址空间</td>
<td align="center">速度较慢，要两次访问内存，<strong>有可能</strong>产生内存浪费</td>
</tr>
</tbody></table>
<h2 id="7-TLB，-多级页表"><a href="#7-TLB，-多级页表" class="headerlink" title="7.TLB， 多级页表"></a>7.TLB， 多级页表</h2><blockquote>
<p>掌握TLB 与多级页表，掌握多级页表相关的计算，比如根据地址位、页面大小、PTE 大<br>小等条件，进行虚拟地址到物理地址的转换；掌握多级页表的访问过程。</p>
</blockquote>
<p>第6点的页表的两个问题需要解决！</p>
<h3 id="解决问题1：-慢"><a href="#解决问题1：-慢" class="headerlink" title="解决问题1： 慢"></a>解决问题1： 慢</h3><h4 id="TLB："><a href="#TLB：" class="headerlink" title="TLB："></a>TLB：</h4><p>TLB（地址转换旁路缓冲储存器）也叫 地址转换缓存， 频繁发生虚拟到物理地址的硬件缓存。</p>
<h5 id="原理（注意加粗，-）："><a href="#原理（注意加粗，-）：" class="headerlink" title="原理（注意加粗， ** **）："></a>原理（注意加粗， ** **）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line"> (Success, TlbEntry) = TLB_Lookup(VPN)  <span class="comment">// TLB里面找VPN对应的物理地址</span></span><br><span class="line"> <span class="keyword">if</span> (Success == True) <span class="comment">// TLB Hit</span></span><br><span class="line">	 <span class="keyword">if</span> (CanAccess(TlbEntry.ProtectBits) == True)</span><br><span class="line">		Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line"> 		PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span><br><span class="line"> 		Register = AccessMemory(PhysAddr)  <span class="comment">// 直接从** 缓存地址**中拿到实际的物理地址</span></span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">		 RaiseException(PROTECTION_FAULT)</span><br><span class="line"> <span class="keyword">else</span> 			<span class="comment">// TLB Miss</span></span><br><span class="line">	 PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br><span class="line">	 PTE = AccessMemory(PTEAddr)    <span class="comment">//没有找到就多了一次PTE ** 内存 **的寻址， 多了一次一次就一次</span></span><br><span class="line">  	<span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">	 	RaiseException(SEGMENTATION_FAULT)</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">		RaiseException(PROTECTION_FAULT)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)</span><br><span class="line">		RetryInstruction()</span><br></pre></td></tr></table></figure>

<h4 id="缓存："><a href="#缓存：" class="headerlink" title="缓存："></a>缓存：</h4><p>计算机中有很多缓存，有指令、数据、地址转换， 上面是地址转换的缓存TLB，缓存要小，越小越快（物理限制），有时间和空间局部性。cpu的数据缓存也分为多级。</p>
<p>曾看到一道题， TLB 和 cache 有什么不同？？？？  </p>
<h4 id="问题里面的问题："><a href="#问题里面的问题：" class="headerlink" title="问题里面的问题："></a>问题里面的问题：</h4><p>当TLB中有两条相同的VPN索引两个不同的物理地址， 可以通过ASID标记（进程号）来标记， 这样就不用覆盖掉之前的VPN了， 当两个进程交互运行时， 相同的VPN可以存在于TLB中，还是上一张图。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104165558.png"></p>
<h5 id="TLB覆盖问题："><a href="#TLB覆盖问题：" class="headerlink" title="TLB覆盖问题："></a>TLB覆盖问题：</h5><p> 如果程序短时间内访问的页数超过了 TLB中的页数， 会产生大量未命中，因为要重写，因此要支持更大的页， 才不会访问很多页！！</p>
<h5 id="TLB的替换策略：LRU"><a href="#TLB的替换策略：LRU" class="headerlink" title="TLB的替换策略：LRU"></a>TLB的替换策略：LRU</h5><p>难道是问题8的？ 不是的，问题8是页的替换， 这里是TLB的替换，思路应该一样的！！</p>
<p>听说腾讯的面试有要求写一个LRU算法！ 基于哈希，哈希每次访问的地址，用一个链表存储哈希后的地址数值，有新的访问就把他放到链表的头结点（包括在链表中的），满了删队尾。（脑子里想起链表的操作删除，插入操作）</p>
<h3 id="解决问题2：-页表很大！"><a href="#解决问题2：-页表很大！" class="headerlink" title="解决问题2： 页表很大！"></a>解决问题2： 页表很大！</h3><h4 id="更大的页"><a href="#更大的页" class="headerlink" title="更大的页"></a>更大的页</h4><p>页变大， 页表条目减少， 页表也就小了， 但是页变大有内部碎片产生！因为每一页都用不完积累就多</p>
<h4 id="分段-分页"><a href="#分段-分页" class="headerlink" title="分段+分页"></a>分段+分页</h4><p>分段与分页相结合，外部碎片再次产生， 页表就是为了解决外部碎片的！！！分段产生外部碎片的根源，无可避免！！</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>于是乎，只有引入多级页表：</p>
<p>问题所在： 页表中存在很多无效区域。</p>
<p>基本思想：将<strong>页表</strong>分成<strong>页</strong>大小的单元，如果整页的PTE无效，就完全不分配该页的页表（很重要！）于是引入:</p>
<p>PDE(页目录)： 记录页表的页是否有效， 包含有效位和页帧号。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104215751.png"></p>
<p>详细深入具体仔细的一个书上的例子： 完美非无可增，乃不可减，老师说必考。</p>
<p>首先题目： 地址空间 16KB（2^14)，地址位数14位， 页大小 64B（2^6),   偏移位数6 位，VPN位数： 14 - 4 = 8 位，页表项条数为 2^8条 , PTE的大小为 4B（假设），如果是线性页表大小为： 4 * 256B = 1KB，如果分配到PDE中， 每页存 64B/4B = <font color="red">16</font> 条PTE，一共要256/16 = ==16==页来存储PTE，于是页目录的索引要 4位（来自黄色的数字），如下图：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104221733.png"></p>
<p>计算PTE的PFN算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PDEAddr = PageDirBase + (PDIndex(<span class="number">4</span>位就可以找到！) - <span class="keyword">sizeof</span>(PDE))</span><br></pre></td></tr></table></figure>

<p>于是找到了PTE所在的物理页帧PFN！（第一步）</p>
<p>因为VPN一共8位， 找PTE所在的页用了4位， 还有4位就索引属于该页所有的PTE的那一条（来自红色的数字）！</p>
<p>通过下面的这条式子找到， 实际物理地址的PFN！(第二步)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PTEAddr = (PDE.PFN &lt;&lt; SHIFT) + (PTIndex * <span class="keyword">sizeof</span>(PTE))</span><br></pre></td></tr></table></figure>

<p>最后,计算实际的物理地址！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PhysAddr &#x3D; (PTE.PFN &lt;&lt; SHIFT) + offset</span><br></pre></td></tr></table></figure>

<p>总结，二级页表的访问内存数目达到了两次，访问速度慢， 但是解决了页表大的问题， 是一个时空的折中。</p>
<h2 id="8-页面置换算法"><a href="#8-页面置换算法" class="headerlink" title="8.页面置换算法"></a>8.页面置换算法</h2><p>掌握页面置换算法，比如FIFO，LRU等，要求能根据给定的页面访问序列，给出特定算<br>法的计算过程；掌握CLOCK算法。</p>
<p>这一块课，没有去听，^ _ ^</p>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>这个好实现， 先进先出，用一个队列就行！</p>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>这个在TLB的替换页面中写了。</p>
<p>LRU 也有问题， 当内存大的时候， LRU的实现代价很大，比如存储LRU的数据结构，因此引入一个近似LRU：</p>
<h3 id="近似LRU"><a href="#近似LRU" class="headerlink" title="近似LRU"></a>近似LRU</h3><p>近似LRU 要硬件的帮助， 给页增加一个使用位， 如果为1， 则认为当前页正在被使用。</p>
<h4 id="clock算法"><a href="#clock算法" class="headerlink" title="clock算法"></a>clock算法</h4><p>算法思路： 当要进行页替换的时候，检查当前的页的使用位，如果为1， 则意味着当前页在被使用，不适合替换，然后将这个位设置为0， 接着检查下一个页的使用位。 如果为0， 则直接替换。 算法的最坏情况是所有的页都是在被使用的， 把所有的1 都换为 0， 此时再来一遍循环选第一个替换， 实际上这种情况很少出现！</p>
<h4 id="ARC算法"><a href="#ARC算法" class="headerlink" title="ARC算法"></a>ARC算法</h4><p>书上没有介绍！</p>
<p>//todo</p>
<h2 id="9-磁盘驱动器"><a href="#9-磁盘驱动器" class="headerlink" title="9.磁盘驱动器"></a>9.磁盘驱动器</h2><blockquote>
<p>掌握磁盘寻道、旋转、传输时间的概念及计算过程。</p>
</blockquote>
<p>寻道： 就是寻道，一般有偏斜</p>
<p>旋转：就是旋转</p>
<p>T <del>I/O</del> = T <del>寻道</del> + T <del>旋转</del> + T <del>传输</del></p>
<p>R<del>I/O</del>（传输速度） = 文件大小 / T <del>I/O</del></p>
<h2 id="10-磁盘调度算法"><a href="#10-磁盘调度算法" class="headerlink" title="10.磁盘调度算法"></a>10.磁盘调度算法</h2><blockquote>
<p>了解各种磁盘调度算法的原理。</p>
</blockquote>
<h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p>最短任务优先， 计算 I/O的时间，选择最短的！</p>
<h3 id="SSTF"><a href="#SSTF" class="headerlink" title="SSTF"></a>SSTF</h3><p>最短寻道时间优先， 可能产生饥饿，一直在同一道内请求</p>
<h3 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h3><p>到一层的时候， 将请求加入队列， 处理完再寻道，这样避免饥饿</p>
<h3 id="SPTF"><a href="#SPTF" class="headerlink" title="SPTF"></a>SPTF</h3><p>最短定位时间</p>
<h2 id="11-RAID"><a href="#11-RAID" class="headerlink" title="11.RAID"></a>11.RAID</h2><blockquote>
<p> 掌握磁盘阵列RAID-0，RAID-1，RAID-4，RAID-5的原理，并分析各种RAID在容量、可<br>靠性、吞吐量三个层面的特性。熟练使用RAID的这些特性进行设计。</p>
</blockquote>
<p>RAID:  廉价冗余磁盘阵列</p>
<p>用于使用多个磁盘构建更大、更快、更可靠的磁盘系统</p>
<h3 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h3><p>条带化</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174035.png"></p>
<p>计算公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Disk = A % number_of_disks</span><br><span class="line">Offset = A / number_of_disks</span><br></pre></td></tr></table></figure>

<p>容量最好， 性能优， 不可靠！</p>
<h3 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h3><p>一半用作镜像</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174309.png"></p>
<p>容量减半， 速度也减半， 因为并发io，少了一半，可靠！</p>
<h3 id="RAID4"><a href="#RAID4" class="headerlink" title="RAID4"></a>RAID4</h3><p>专门用一个磁盘用来奇偶校验</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174532.png"></p>
<p>可靠， 速度（n-1）S， 容量大</p>
<p>当一校验盘同时有两个块需要校验时， 速度会减慢， 因此引入：</p>
<h3 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h3><p>旋转奇偶校验</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174917.png"></p>
<p>可靠， 速度（n-1）S，容量大</p>
<h3 id="性能比较："><a href="#性能比较：" class="headerlink" title="性能比较："></a>性能比较：</h3><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174957.png"></p>
<h2 id="12-文件系统接口"><a href="#12-文件系统接口" class="headerlink" title="12.文件系统接口"></a>12.文件系统接口</h2><blockquote>
<p> 了解文件系统接口，如open，read，write，在实现时对元数据和文件内容的读写过程。</p>
</blockquote>
<p>都说不考喽！！！</p>
<h2 id="13-操作系统历史"><a href="#13-操作系统历史" class="headerlink" title="13.操作系统历史"></a>13.操作系统历史</h2><blockquote>
<p>了解课堂上讲到的跟操作系统发展史相关的重要人物，并能介绍其主要贡献。</p>
</blockquote>
<ul>
<li>图灵</li>
</ul>
<p>计算机之父</p>
<ul>
<li>冯·诺伊曼</li>
</ul>
<p>提出了“存储程序”的概念和二进制原理</p>
<ul>
<li>linus</li>
</ul>
<p>编写第一个linux</p>
<ul>
<li>阿兰·马西森·图灵（1912-1917年6月23日）</li>
</ul>
<p>他在计算机科学的发展，提供概念的形式化“算法”和“计算”的图灵机，可以考虑通用计算机的模型。</p>
<p>图灵被广泛认为是理论计算机之父！</p>
<ul>
<li>Dijkstra</li>
</ul>
<p>同步进程通信的信号量</p>
<ul>
<li>Thompson</li>
</ul>
<p>用B语言写了第一个UNIX操作系统</p>
<h2 id="14-其它"><a href="#14-其它" class="headerlink" title="14.其它"></a>14.其它</h2><blockquote>
<p>作业中的难点问题需要掌握其解题方法。</p>
</blockquote>
<p>都包含在上面了。</p>
]]></content>
  </entry>
  <entry>
    <title>Java设计模式</title>
    <url>/2019/10/01/notepad/read/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/design_pattern/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><center>设计模式</center></h1><p>笔记说明： 这是一节专业选修课，上课没怎么听， 弥补一下错过的东西， 给大部分的设计模式写了一个demo， 很多细节都在里面，代码地址： github/fierygit,  一共有23 个设计模式， 5 个 创建型， 7 个 结构型， 11 个行为型！</p>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p><strong>(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</strong></p>
<a id="more"></a>


<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p><strong>(Open-Closed Principle, OCP)：软件实体应当对扩展开放，对修改关闭</strong></p>
<h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p><strong>(Liskov Substitution Principle, LSP)：所有引用基类的地方必须能透明地使用其子类的对象</strong></p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p><strong>(Dependency Inversion Principle, DIP)：高层模块不应该依赖底层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象</strong></p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p><strong>(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口</strong></p>
<h3 id="复用原则"><a href="#复用原则" class="headerlink" title="复用原则"></a>复用原则</h3><p><strong>(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的</strong></p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p><strong>(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用</strong></p>
<hr>
<hr>
<h2 id="六个创建型模式"><a href="#六个创建型模式" class="headerlink" title="六个创建型模式"></a>六个创建型模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/SimpleFactory.png"></p>
<p>● Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</p>
<p>● Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p>
<p>● ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>参考工程 SimpleFactory（代码在github，study_note）</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</p>
<p><strong>主要优点：</strong></p>
<p>(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</p>
<p>(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</p>
<p>(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</p>
<p>(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</p>
<p>(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p>
<p>(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p>
<hr>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p> 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p>
<h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/FactoryMethod.png"></p>
<p>● Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</p>
<p>● ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</p>
<p>● Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</p>
<p>● ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>参考工程 FactoryMethod</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类；</p>
<p><strong>主要优点：</strong></p>
<p>(1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p>
<p>(2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</p>
<p>(3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p>
<p>(2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
<hr>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p> 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例 </p>
<h4 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h4><p> ● Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。 </p>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>参考工程 SIngleton</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p> <strong>饿汉式单例与懒汉式单例</strong> </p>
<p>  饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。可见，无论是饿汉式单例还是懒汉式单例都存在这样那样的问题。</p>
<p> <strong>Initialization Demand Holder (IoDH)</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton &#123;  </span><br><span class="line">    private Singleton() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    private static class HolderClass &#123;  </span><br><span class="line">       private final static Singleton instance &#x3D; new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        return HolderClass.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void main(String args[]) &#123;  </span><br><span class="line">        Singleton s1, s2;   </span><br><span class="line">            s1 &#x3D; Singleton.getInstance();  </span><br><span class="line">        s2 &#x3D; Singleton.getInstance();  </span><br><span class="line">        System.out.println(s1&#x3D;&#x3D;s2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过一个静态的方法初始化一个静态的类！</p>
<hr>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p> 使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种<strong>对象</strong>创建型模式。 </p>
<h4 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h4><p>●Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</p>
<p>● ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</p>
<p>● Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便</p>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p>参考工程：PrototypePattern</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>一般而言，Java语言中的clone()方法满足：</p>
<ul>
<li><p>(1) 对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；</p>
</li>
<li><p>(2) 对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；</p>
</li>
<li><p>(3) <font color ="red">如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</font></p>
</li>
</ul>
<p>为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：</p>
<ul>
<li><p>(1) 在派生类中覆盖基类的clone()方法，并声明为public；</p>
</li>
<li><p>(2) 在派生类的clone()方法中，调用super.clone()；</p>
</li>
<li><p>(3)派生类需实现Cloneable接口。</p>
</li>
</ul>
<h5 id="浅克隆-ShallowClone-和深克隆-DeepClone"><a href="#浅克隆-ShallowClone-和深克隆-DeepClone" class="headerlink" title="浅克隆(ShallowClone)和深克隆(DeepClone)"></a><strong>浅克隆(ShallowClone)和深克隆(DeepClone)</strong></h5><p>​     Java语言中，数据类型分为值类型（基本数据类型）和引用类型.</p>
<ul>
<li><p><strong>值类型</strong>包括int、double、byte、boolean、char等简单数据类型，</p>
</li>
<li><p><strong>引用类型</strong>包括类、接口、数组等复杂类型。</p>
</li>
</ul>
<p>浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制，下面将对两者进行详细介绍。 </p>
<p><strong>浅克隆</strong></p>
<p>  在浅克隆中，如果原型对象的成员变量是<strong>值类型</strong>，将复制一份给克隆对象；如果原型对象的成员变量是<strong>引用类</strong>型，则将<strong>引用对象的地址</strong>复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p>
<p><strong>深克隆</strong></p>
<p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p>
<p><strong>主要优点：</strong></p>
<p>(1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</p>
<p>(2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</p>
<p>(3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</p>
<p>(4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p>
<p>(2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</p>
<hr>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种<strong>对象</strong>创建型模式。 </p>
<h4 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/Builder.png"></p>
<p>● Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</p>
<p>●ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</p>
<p>●Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</p>
<p>● Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的==构造函数==或者==Setter==方法将该对象传入指挥者类中。</p>
<h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><p>参考工程：BuilderPattern</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>(1) 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p>
<p>(2) 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”</p>
<p>(3) 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。</p>
<p>(2) 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。</p>
<hr>
<hr>
<h2 id="结构形模式"><a href="#结构形模式" class="headerlink" title="结构形模式"></a>结构形模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p> 适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 </p>
<h4 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/patternAdapter.jpg"></p>
<p>● Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</p>
<p>● Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p>
<p>● Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</p>
<h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><p> AdapterPattern</p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>无论是对象适配器模式还是类适配器模式都具有如下优点：</p>
<p>(1) 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</p>
<p>(2) 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</p>
<p>(3) 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p>
<p>具体来说，类适配器模式还有如下优点：</p>
<p>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p>
<p>对象适配器模式还有如下优点：</p>
<p>(1) 一个对象适配器可以把多个不同的适配者适配到同一个目标；</p>
<p>(2) 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；</p>
<p>(2) 适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；</p>
<p>(3) 在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</p>
<p>对象适配器模式的缺点如下：</p>
<p>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p>
<hr>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p> 桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。 </p>
<h4 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/bridgepattern.jpg"></p>
<p>●Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</p>
<p>●RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。</p>
<p>●Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。</p>
<p>●ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。</p>
<h4 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h4><p>BridgePattern</p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>主题的维度是抽象的， 另一个维度接口，在抽象的主题里面调用另一个维度</p>
<p><strong>主要优点：</strong></p>
<p>(1)分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。</p>
<p>(2)在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。</p>
<p>(3)桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。</p>
<p><strong>主要缺点：</strong></p>
<p>(1)桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</p>
<p>(2)桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p> 组合多个对象形成<strong>树形结构</strong>以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。 </p>
<h4 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h4><p>● Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。</p>
<p>● Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。</p>
<p>● Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</p>
<h4 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h4><p>参考工程： CompositePattern </p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>(1) 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</p>
<p>(2) 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</p>
<p>(3) 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</p>
<p>(4) 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。                        </p>
<p><strong>主要缺点：</strong></p>
<p>在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。</p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><p> 动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。 </p>
<h4 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h4><p>● Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</p>
<p>● ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</p>
<p>● Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</p>
<p>● ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</p>
<h4 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h4><p>参考工程： DecoratorPattern </p>
<h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>(1) 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</p>
<p>(2) 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。</p>
<p>(3) 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。</p>
<p>(4) 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</p>
<p>(2) 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h4><p> 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 </p>
<h4 id="结构-9"><a href="#结构-9" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20191113203800361.png"></p>
<p>Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</p>
<p> SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p>
<h4 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h4><p> FacadePattern</p>
<h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>(1) 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。</p>
<p>(2) 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。</p>
<p>(3) 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活 性。</p>
<p>(2) 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h4><h4 id="结构-10"><a href="#结构-10" class="headerlink" title="结构"></a>结构</h4><h4 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h4><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p><strong>主要缺点：</strong></p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h4><h4 id="结构-11"><a href="#结构-11" class="headerlink" title="结构"></a>结构</h4><h4 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h4><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p><strong>主要缺点：</strong></p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><h4 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h4><h4 id="结构-12"><a href="#结构-12" class="headerlink" title="结构"></a>结构</h4><h4 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h4><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p><strong>主要缺点：</strong></p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h4><p> 将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。 </p>
<h4 id="结构-13"><a href="#结构-13" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20191115171949964.png"></p>
<p>● Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行<br>请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。<br>● ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类<br>中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方<br>法时，将调用接收者对象的相关操作(Action)。<br>● Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不<br>需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以<br>将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求<br>接收者的相关操作。<br>● Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。</p>
<h4 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h4><p>CommandPattern</p>
<p>自定义功能键的实现</p>
<p>可以将命令用一个数组来存储， 这样可以实现批处理</p>
<p>此外还可以是实现一个撤销的功能， 类似于备忘录模式， 两个可以实现撤销操作的模式</p>
<h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>(1) 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间<br>实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的<br>请求者使用，两者之间具有良好的独立性。<br>(2) 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此<br>增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的<br>要求。<br>(3) 可以比较容易地设计一个命令队列或宏命令（组合命令）。<br>(4) 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。</p>
<p><strong>主要缺点：</strong></p>
<p>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调<br>用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这<br>将影响命令模式的使用。</p>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>以不同的方式操作复杂对象结构</p>
<h4 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h4><p>访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以<br>在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型。<br>模式。</p>
<h4 id="结构-14"><a href="#结构-14" class="headerlink" title="结构"></a>结构</h4><p>●Vistor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一<br>个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体<br>访问者需要实现这些操作方法，定义对这些元素的访问操作。<br>●ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操<br>作用于访问对象结构中一种类型的元素。<br>●Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法<br>通常以一个抽象访问者作为参数。【稍后将介绍为什么要这样设计。】<br>●ConcreteElement（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者<br>的访问方法以便完成对一个元素的操作。<br>● ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提<br>供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，<br>如一个List对象或一个Set对象。</p>
<h4 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h4><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p><strong>主要缺点：</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/09/10/notepad/java/JavaStudy/src/main/resources/application/</url>
    <content><![CDATA[null]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/09/10/notepad/java/JavaStudy/src/main/java/Basic/Collection/README/</url>
    <content><![CDATA[<h2 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h2><blockquote>
<p>copy from zengsiyan</p>
</blockquote>
<p>Java对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储<font color=red>（内存上的存储）</font>。</p>
<p>然而使用数组存储对象存在一些弊端，因此，Java引入集合框架，实现<font color=red><strong>动态</strong></font>的存储对象的容器。</p>
<ul>
<li>首先，了解<font color=red>数组</font>的<strong>特点</strong>与<strong>局限性</strong>：</li>
</ul>
<blockquote>
<ul>
<li>数组在内存存储方面的特点：<ul>
<li>数组初始化以后，<strong>长度就确定了</strong>。</li>
<li>数组声明的类型就决定了元素初始化的<strong>类型</strong>。</li>
</ul>
</li>
<li>数组在存储数据方面的弊端：<ul>
<li>数组初始化以后长度不可改变，<strong>无法扩展</strong>。</li>
<li>数组提供的属性和方法相对较少，不便于增、删（或<strong>效率不高</strong>）</li>
<li>数组存储数据有序可重复（或<strong>存储数据的特点单一</strong>）</li>
</ul>
</li>
</ul>
</blockquote>
<p>而数组的弊端在Java集合上都得到了解决。</p>
<ul>
<li>Java集合分为<font color=red><strong>Collection接口</strong></font>和<font color=red><strong>Map接口</strong></font>两大块：</li>
</ul>
<p>$$<br>x \begin{cases}Collection：单列数据，定义了存取一组对象的方法的集合\\Map：双列数据，保存具有映射关系“key-value对”的集合\end{cases}<br>$$</p>
<p>​<br>​                        </p>
<p><img src="assert/collection" alt="clooetion"></p>
<p><img src="assert/005PzEdegy1g5iw4w2ksuj30f6083gls.jpg" alt="map"></p>
<h2 id="1-List接口"><a href="#1-List接口" class="headerlink" title="1. List接口"></a>1. List接口</h2><h3 id="1-1-ArrayList源码分析"><a href="#1-1-ArrayList源码分析" class="headerlink" title="1.1 ArrayList源码分析"></a>1.1 ArrayList源码分析</h3><ol>
<li><strong>底层的物理存储结构：</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br></pre></td></tr></table></figure>

<p>可见，ArrayList的物理存储结构为Object类型的数组——elementData。</p>
<p>然后，一个私有整型变量记录elementData中真实存放的元素的个数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>构造器：</strong></li>
</ol>
<ul>
<li><strong>空参构造</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">  * 这个注释是JDK7的注释，如果是JDK7，那么这里会创建出一个默认长度为10的Object[]数组</span></span><br><span class="line"><span class="comment">  * 而JDK8没有直接创建长度为10的数组。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接将elementData赋值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">  * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">  * first element is added.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// DEFAULTCAPACITY_EMPTY_ELEMENTDATA是全局常量，长度为0的Object数组，JDK8这样做的好处是最大限度的节省了内存空间，它会等到真正添加元素时再创建数组。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>意即：调用ArrayList的空参构造器，底层会将全局常量（一个长度为0的Object数组）赋给elementData。</p>
<ul>
<li><strong>定容构造：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">  *         is negative</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始容量大于0，那么创建指定容量的Object数组赋值给elementData</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;	<span class="comment">// 指定容量为0，将elementData赋值为空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 指定容量为负数，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 如果定容构造器的容量被指定为0，那么elementData也被赋值为一个全局常量。（长度为0的Object数组）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<blockquote>
<p><font color=red><strong>EMPTY_ELEMENTDATA</strong></font> 与 <font color=red><strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong></font>均是长度为0的Object数组，且均是全局常量。</p>
<p>但是前者是在定容构造器容量为0时为elementData赋值（理论上的容量是0）。</p>
<p>后者是空参构造器为elementData赋值（理论上的容量是10，只是现在没有创建）。它实际上是在add时再创建。</p>
</blockquote>
<ol start="3">
<li><strong>add(E e)方法</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;		<span class="comment">// 容量满足需求了，那将指定的这个元素追加到原数组末尾</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是确定增加一个元素后，需不需要扩容。然后在满足容量的elementData中新增元素便可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将必须存储的最小容量值作为参数（minCapacity）传入，以判断是否有扩容的必要</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算一次容量，实际上是顺应空参构造中的DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里就体现了JDK8与JDK7不同的地方，对于空参构造，JDK8是在这里为默认长度为10的Object开辟空间的。即如果elementData是被空参构造赋值过且数组未使用过，那么返回默认长度和最小长度中最大的那个值作为新的最小长度。</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// DEFAULT_CAPACITY是类中定义的全局常量，它的值为10</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果elementData不是默认空参构造过未初始化的，那么直接返回最小容量</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)	<span class="comment">// 判断是否有扩容的必要</span></span><br><span class="line">        grow(minCapacity);	<span class="comment">// 扩容方法的具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">  * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;	<span class="comment">// 绑定原有长度</span></span><br><span class="line">    <span class="comment">// 将新长度扩容为原有长度的1.5倍（原长+原长/2）</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新长度还是小于最小容量，那么最小容量就作为新长度（默认空参构造会在这里被指定为10）</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)	<span class="comment">// 极端的大于整数界限的情况</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);	<span class="comment">// 数组扩容方法，将elementData扩容为newCapacity，并且原有数据不变，返回值更新elementData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，ArrayList的一次add就完成了。</p>
<p><strong>小结：JDK8在处理ArrayList的空参构造上使用<font color=red>延迟创建</font>的方式，较大限度的节省了内存空间。</strong></p>
<h3 id="1-2-LinkedList源码分析"><a href="#1-2-LinkedList源码分析" class="headerlink" title="1.2 LinkedList源码分析"></a>1.2 LinkedList源码分析</h3><ol>
<li><strong>底层的物理存储结构：</strong></li>
</ol>
<p>底层的物理存储结构是<font color=red>双向链表</font>，其定义了名为Node的内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 三个属性元素、后序节点、前序节点</span></span><br><span class="line">    E item;		</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList中比较核心的<font color=red>三个属性</font>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;		<span class="comment">// 记录双向链表中元素的个数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Pointer to first node.</span></span><br><span class="line"><span class="comment">  * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">  *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;	<span class="comment">// 标识双向链表中第一个元素所在的节点</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Pointer to last node.</span></span><br><span class="line"><span class="comment">  * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">  *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;		<span class="comment">// 标识双向链表中最后一个元素所在的节点</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>构造器：</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty list.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，空参构造器调Object的空参构造，它们什么都不会做，也就是那三个属性都将是默认值：</p>
<blockquote>
<ul>
<li><p>size = 0;    </p>
</li>
<li><p>first = null;</p>
</li>
<li><p>last = null;</p>
</li>
</ul>
</blockquote>
<ol start="3">
<li><strong>add(E e)：</strong></li>
</ol>
<p>因为双向链表本身就是动态的，因此不在需要频繁的去考虑扩容、缩容等问题了。其add方法就是新建一个节点，然后将这个节点的指针与链表末尾节点的指针绑定好就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);	<span class="comment">// 在双向链表的尾部添加元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Links e as last element.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;		<span class="comment">// 绑定双向链表的尾节点</span></span><br><span class="line">    <span class="comment">// 创建待添加的新节点，前序节点为双向链表的尾节点，后序节点为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);	</span><br><span class="line">    <span class="comment">// 更新双向链表的尾节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果原双向链表为空（原尾节点为null代表链表空）</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;	<span class="comment">// 那么首节点和尾节点都会指向这个新增的第一个节点</span></span><br><span class="line">    <span class="keyword">else</span>					<span class="comment">// 如果原双向链表非空，那么原尾节点的后续指向新增节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;					<span class="comment">// 双向链表元素个数加一</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-Collections-SynchronizedList和Vector的区别"><a href="#1-3-Collections-SynchronizedList和Vector的区别" class="headerlink" title="1.3 Collections.SynchronizedList和Vector的区别"></a>1.3 Collections.SynchronizedList和Vector的区别</h3><ul>
<li><p>如果使用add方法，那么他们的扩容机制不一样。</p>
</li>
<li><p>SynchronizedList可以指定锁定的对象。</p>
</li>
</ul>
<p>（Collections.SynchronizedList只是使用同步代码块包裹了ArrayList的方法，而ArrayList和Vector中同名方法的方法体内容并无太大差异，所以在锁定范围和锁的作用域上两者并无却别。 在锁定的对象区别上，SynchronizedList的同步代码块锁定的是mutex对象，Vector锁定的是this对象。那么mutex对象是SynchronizedList在使用构造函数时可以传入一个Object,如果在调用的时候显示的传入一个对象，那么锁定的就是用户传入的对象。如果没有指定，那么锁定的也是this对象。）</p>
<h2 id="2-Set接口"><a href="#2-Set接口" class="headerlink" title="2. Set接口"></a>2. Set接口</h2><ul>
<li><p>Set接口继承了Collection接口，而且Set接口内没有额外的提供方法。</p>
</li>
<li><p>Set接口代表了<strong>无序、不可重复</strong>的集合。</p>
</li>
<li><p>Set的主要实现类有：<font color=red>HashSet、LinkedHashSet、TreeSet</font>。</p>
</li>
</ul>
<blockquote>
<ul>
<li>HashSet：<ul>
<li>Set接口的主要实现类。</li>
<li>线程不安全，效率高。</li>
<li>能够存储null值。</li>
</ul>
</li>
<li>LinkedHashSet：<ul>
<li>是HashSet的子类。</li>
<li>以链表的方式组织，可以<font color=red>按照添加时的顺序</font>遍历LinkedHashSet中的数据。</li>
</ul>
</li>
<li>TreeSet：<ul>
<li>底层使用HashMap，即，实际采用<font color=red><strong>红黑树</strong></font>存储。</li>
<li>要求TreeSet中存放的对象均属于同一个类。</li>
<li>可以按照对象指定的属性进行排序。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>理解Set的无序性：</strong></li>
</ul>
<blockquote>
<p>Set的无序性不等同于随机性，它存储的数据在底层不是依次存放的，<font color=red>而是根据数据的Hash值决定元素的存放位置。</font></p>
</blockquote>
<ul>
<li><strong>理解Set的不可重复性：</strong></li>
</ul>
<blockquote>
<p>Set中保证添加的元素在使用equals()方法判断时不能返回true，即相同的元不能被添加进来。</p>
<p><font color=red><strong>注意</strong>：Set判断重复元素的方法是先根据hashCode方法返回的hash值确定元素要存放的位置索引，然后再与具有相同索引的所有元素去equals()。</font>这样做可以大大减少比较次数，提高效率。</p>
</blockquote>
<p><strong><font color=red>由此也可知，Set中存放的元素类型应该是重写了equals()和hashCode()的类型。意即，使用HashSet及其子类，必定需要重写equals()和hashCode()方法，而且equals()和hashCode()方法的重写应当要满足相等的对象应该具有相等的hash值的原则。</font></strong></p>
<h3 id="2-1-重写hashCode"><a href="#2-1-重写hashCode" class="headerlink" title="2.1 重写hashCode()"></a>2.1 重写hashCode()</h3><p>使用IDEA自动重写hashCode()方法时，会发现有系数<font color=red>31</font>，原因：</p>
<ul>
<li>选择系数的时候要选择尽量大的系数，因为如果计算出来的hash地址越大，所谓的“冲突”就会越少，查找起来的效率就会越高。<font color=red>(所以一般要乘以一个系数)</font></li>
<li>并且31只占用5bits，<strong>相乘造成数据溢出的概率较小</strong>。</li>
<li>i*31可以由<font color=red>( i &lt;&lt; 5 ) - 1</font>来表示，现在很多虚拟机都有相关的优化，能够提高算法效率。</li>
<li>31是一个素数，素数的作用就是某个数乘以一个素数，那么结果只能被被乘数、素数本身和1整除，同样可以减少冲突。</li>
</ul>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 重写Object类的hashCode方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object.hash(name, age)实际上调用的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span> </span>&#123;	<span class="comment">// 可变长参数</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这里可见其生成hash值的过程</span></span><br><span class="line">    <span class="keyword">for</span> (Object element : a)</span><br><span class="line">        <span class="comment">// 如果elemenet是null，那么返回0，如果不是那么返回这个类型重写的hashCode值然后与乘了31的result进行累和</span></span><br><span class="line">        result = <span class="number">31</span> * result + (element == <span class="keyword">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重写hashCode与equals应该要具有一致性，即<font color=red><strong>equals()中比较的属性在hashCode中也要用到。</strong></font></li>
</ul>
<h3 id="2-2-主要实现类"><a href="#2-2-主要实现类" class="headerlink" title="2.2  主要实现类"></a>2.2  主要实现类</h3><ol>
<li><strong>HashSet</strong></li>
</ol>
<ul>
<li>HashSet底层是以<font color=red>”数组+链表“</font>的方式实现的。</li>
<li>HashSet中元素添加的过程：<strong>【必须理解这个过程，这也是HashMap的过程】</strong></li>
</ul>
<blockquote>
<ul>
<li>想要在HashSet中添加元素a，那么<strong>首先要调用元素a所在类的hashCode方法</strong>，计算元素a的hash值。</li>
<li>此hash值通过某种hash函数确定（计算出）<strong>HashSet底层数组中的存放位置</strong>。判断该位置是否有其他元素。<ul>
<li>如果没有其他元素，那么直接添加，返回<font color=red><strong>添加成功</strong></font>。</li>
<li>如果有其他元素<font color=red><strong>（并且这些元素会以链表形式存放）</strong></font>，那么针对链表上的每个元素调用a元素所在类的equals方法<font color=red>比较两个元素内容是否相等</font><ul>
<li>如果equals返回true，那么<font color=red><strong>添加失败</strong></font>。</li>
<li>a.equals(链上所有元素)均返回false，那么元素a**<font color=red>添加成功</font>**。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ol start="2">
<li><strong>LinkedHashSet</strong></li>
</ol>
<p>LinkedHashSet作为HashSet的子类，在添加数据<font color=red>（添加数据的操作与HashSet一样）</font>的同时每个数据还维护了<font color=red>两个引用</font>，记录此数据的前序数据和后序数据。</p>
<p>优点： 在需要对集合进行频繁的遍历时，LinkedHashSet效率高于HashSet。</p>
<ol start="3">
<li><strong>TreeSet</strong></li>
</ol>
<ul>
<li><p>TreeSet的底层实现是红黑树。</p>
</li>
<li><p>向TreeSet中添加的元素必须是同一个类的对象。（因为TreeSet是实现排序类的，如果要排序，那么集合中存储的元素应该都具有相同的属性）。</p>
</li>
<li><p>使用TreeSet的空参构造 —— 自然排序。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person that = (Person) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(that.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;illegal argument!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空参构造，以自然排序为依据</span></span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;tina&quot;</span>, <span class="number">15</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;tony&quot;</span>, <span class="number">19</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;kobe&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;jhon&quot;</span>, <span class="number">17</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;jhon&quot;</span>, <span class="number">13</span>));</span><br><span class="line">    <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person&#123;name=<span class="string">&#x27;jhon&#x27;</span>, age=<span class="number">17</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;kobe&#x27;</span>, age=<span class="number">23</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;tina&#x27;</span>, age=<span class="number">15</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;tony&#x27;</span>, age=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<blockquote>
<p>输出的结果中，最后一条记录new Person(“jhon”, 13)没有加入集合。原因：</p>
<ul>
<li>**<font color=red>特别注意</font>**，如果TreeSet中的元素使用的是自然排序（实现Comparable接口），<font color=red>那么TreeSet认为比较两个元素是否相等的标准为Comparable接口中compareTo方法的返回值（返回值为0则相等，不为0则不等）</font>。不再是equals方法了。然而，TreeSet中是不允许存放相等的元素的（这是Set集合的共性），所以最后这条名为jhon的记录就没有被添加到集合中。</li>
</ul>
</blockquote>
<ul>
<li>使用TreeSet的比较器构造 —— 定制排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不让Person类实现Comparable接口，而是在实例化TreeSet对象的时候使用Comparator构造器，便可实现定制排序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将Comparator实现类的对象作为参数来实现定制排序</span></span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">                Person person1 = (Person) o1;</span><br><span class="line">                Person person2 = (Person) o2;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(person1.age, person2.age);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;illegal argument!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;tina&quot;</span>, <span class="number">15</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;tony&quot;</span>, <span class="number">19</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;kobe&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;jhon&quot;</span>, <span class="number">17</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;jhon&quot;</span>, <span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同样，使用定制排序来实例化TreeSet对象，它内部比较两个元素是否相等的依据也是比较器中compare方法，而不是equals。</li>
<li>其实**<font color=red>排序的属性不能重复</font><strong>的原理很简单，</strong>因为TreeSet底层是红黑树实现的（二叉树），父节点的左子节点必定小于父节点，右子节点必定大于父节点。不会存在两个节点相同的情况！**</li>
</ul>
<h3 id="2-3-面试题"><a href="#2-3-面试题" class="headerlink" title="2.3 面试题"></a>2.3 面试题</h3><p>假设Person类重写了equals()与hashCode()方法，考虑如下程序的运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">    set.remove(p1);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Person&#123;name=<span class="string">&#x27;BB&#x27;</span>, age=<span class="number">1002</span>&#125;, Person&#123;name=<span class="string">&#x27;AA&#x27;</span>, age=<span class="number">1001</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;BB&#x27;</span>, age=<span class="number">1002</span>&#125;, Person&#123;name=<span class="string">&#x27;CC&#x27;</span>, age=<span class="number">1001</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;BB&#x27;</span>, age=<span class="number">1002</span>&#125;, Person&#123;name=<span class="string">&#x27;CC&#x27;</span>, age=<span class="number">1001</span>&#125;, Person&#123;name=<span class="string">&#x27;CC&#x27;</span>, age=<span class="number">1001</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;BB&#x27;</span>, age=<span class="number">1002</span>&#125;, Person&#123;name=<span class="string">&#x27;CC&#x27;</span>, age=<span class="number">1001</span>&#125;, Person&#123;name=<span class="string">&#x27;CC&#x27;</span>, age=<span class="number">1001</span>&#125;, Person&#123;name=<span class="string">&#x27;AA&#x27;</span>, age=<span class="number">1001</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<blockquote>
<ul>
<li>第一行输出没有疑问，显然p1和p2的哈希值是不同的，直接输出集合中的两个元素p1和p2。</li>
<li>程序在执行p1.name = “CC”;后再去调用remove方法，那么系统就会根据p1对象生成的新的哈希值去找底层存储p1对象的位置。<ul>
<li>然而，<font color=red>之前存放位置的哈希值是根据AA生成的，现在是以CC生成的哈希值去寻找，自然位置不同，那么HashSet会认为集合中根本就没有这个p1这个对象，</font>因此直接没有进行删除操作。所以得到第二行的输出。</li>
</ul>
</li>
<li>程序在执行set.add(new Person(1001, “CC”));后，会根据1001和CC两个属性去生成哈希值，然后去存放这个新的Person对象。<ul>
<li>然而之前的程序并<font color=red>没有在这个哈希值的位置存放任何内容</font>，因此这个对象将被成功放入集合中。所以得到第三行输出。</li>
</ul>
</li>
<li>程序在执行set.add(new Person(1001, “AA”));后，会根据1001和AA两个属性生成哈希值，然后去存放这个新的Person对象。<ul>
<li>然而这个位置已经存放了对象Person(1001, “CC”)，<font color=red>因此系统会转而去判断equals()的返回值</font>。很显然，返回值为false，因此Person(1001, “AA”)对象被成功添加到集合中。所以得到第四行输出。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3-Map接口"><a href="#3-Map接口" class="headerlink" title="3. Map接口"></a>3. Map接口</h2><p>Map接口作为双列数据的主接口，主要用于存放键值对数据。</p>
<p>Map接口的主要实现类：</p>
<blockquote>
<ul>
<li>HashMap：作为Map接口的<font color=red>主要实现类</font>。线程不安全，效率高。能够存储null的key和value。<font color=red>底层实现，JDK7为数组+链表，JDK8为数组+链表+红黑树。</font><ul>
<li>LinkedHashMap：HashMap的子类。保证在遍历Map元素时，可以按照添加的顺序实现遍历<strong>（原因，在HashMap的底层结构基础上，添加了一对指针，指向前一个和后一个元素）</strong>。<font color=red>对于频繁的遍历操作，此类的执行效率高于HashMap。</font></li>
</ul>
</li>
<li>TreeMap：保证按照添加的key-value对进行排序，实现排序遍历。排序依据为key（比较key是唯一的、不重复的）。<font color=red>底层使用红黑树实现。</font></li>
<li>Hashtable：作为Map接口的古老实现类。线程安全，效率相对较低。不能够存储null的key和value。<font color=red>（基本不会使用，即使需要线程安全的也会找Collections的方法替代）</font><ul>
<li>Properties：Hashtable的子类，其key和value都是String类型的。常用来处理配置文件。 </li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>理解Map结构</strong></li>
</ul>
<p>$$<br>\begin{cases}</p>
<ol>
<li>key\<br>\</li>
<li>value\<br>\</li>
<li>Entry<br>\end{cases}<br>$$</li>
</ol>
<blockquote>
<ul>
<li>**<font color=red>key 是无序的不可重复的，其主要使用Set来存储所有的key</font>**。但是具体是什么类型的Set就要看是什么类型的Map了。（比如，如果是HashMap，那么key就用HashSet，如果是LinkedHasMap，那么key就用LinkedHashSet）。</li>
<li>**<font color=red>value是无序可重复的</font>**，泛泛来说就是用Collection存储的。</li>
<li>**<font color=red>Entry是无序不可重复的，</font>**使用Set进行存储。注意，一个key-value(键值对)就构成一个Entry对象。</li>
</ul>
</blockquote>
<h3 id="3-1-HashMap源码分析"><a href="#3-1-HashMap源码分析" class="headerlink" title="3.1 HashMap源码分析"></a>3.1 HashMap源码分析</h3><ul>
<li><p>JDK7的与JDK8的HashMap实现略有不同，主要以JDK8为准，然后选择性提示JDK7中的区别部分。</p>
</li>
<li><p>JDK8中HashMap的底层实现主要是：<font color=red>数组 + 链表 + 红黑树</font>。</p>
</li>
</ul>
<p>HashMap中一些主要常量与结构：</p>
<ul>
<li>常量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">  * 全局常量，默认初始化数组容量，定义为16.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">  * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">  * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">  * 全局常量，数组能够承受的最大容量，定义为2^30。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">  * 全局常量，默认加载因子0.75，其作用是用于判断数组是否需要扩容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">  * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">  * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">  * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">  * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">  * shrinkage.</span></span><br><span class="line"><span class="comment">  * 全局常量，如果某个数组位置的链表长度大于这个默认阈值8，那么就将链表转化成红黑树</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">  * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">  * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">  * 全局常量，如果某个数组位置的红黑树节点个数小于这个阈值，那么就将红黑树转换成链表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">  * 静态内部类，存放键值对的基本结构Node（JDK7直接是Entry类），Node同样也是实现了Map.Entry接口。</span></span><br><span class="line"><span class="comment">  * 主要的属性是一个标识Node的hash值，一个键，一个值，一个指向下一节点的引用。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;	<span class="comment">// 注意，键赋值后不能改变，值可以改变</span></span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">	<span class="comment">// 重写hashCode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// set方法（只有value能够set，key不能set）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 重写equals()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">  * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">  * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">  * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">  * 核心数组。Node&lt;K,V&gt;类型的数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">  * for keySet() and values().</span></span><br><span class="line"><span class="comment">  * 键的存放是以Set的方式（不可重复是关键）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">  * 真实元素的长度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">  * 判断数组是否需要扩容的阈值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">  * 加载因子，主要用于判断数组是否需要扩容</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>



<ol>
<li><strong><font color=red>空参构造</font></strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">  * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">  * 这些注释是JDK7的，如果是JDK7，那么空参构造就会创建一个Entry数组，且默认初始长度为16</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空参构造中只是简单的指示下加载因子为DEFAULT_LOAD_FACTOR（0.75）; </span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><font color=red><strong>定容构造</strong></font></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial </span></span><br><span class="line"><span class="comment">  * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.   </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定默认的加载因子后，转而调用带加载因子的构造器</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">  * capacity and load factor.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">  *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定初始容量小于0，抛非法参数异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 给定初始容量大于数组最大，那么数组最大就作为初始常量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 如果加载因子小于0或加载因子不是合法的浮点数，抛非法参数异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 为加载因子赋值，并计算阈值（数组是否需要扩容的阈值）</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li><p>loadFactor与threshold的值直接决定数组是否需要扩容。</p>
</li>
<li><p>HashMap的扩容不是简单的数组用完了就扩，因为由于Hash冲突等原因，可能在某个数组的索引位置，一个链会拉的很长很长。而其余的数组索引根本就没有使用。所以要引入加载因子。</p>
</li>
<li><p><font color=red>加载因子太大可能导致一个位置上链很长，加载因子太小可能导致数组的利用率太低。</font>可能根据统计学的等计算加载因子为0.75时较合适。</p>
</li>
</ul>
</blockquote>
<ol start="3">
<li><font color=red><strong>put方法</strong></font></li>
</ol>
<p>可以发现，不论是空参构造，还是两个定容构造，HashMap构造器中并没有创建核心的底层数组。这是JDK8区别与JDK7的地方（JDK7是直接在构造器中就创建了）。与之前的ArrayList类似，JDK8使用了<font color=red>延迟创建机制</font>，<strong>它会在真正需要使用数组的时候再去创建数组，目的是最大限度的减少了内存空间</strong>。</p>
<p>HashMap的put方法主要考虑三个方面的问题：<font color=red>底层数组的创建、数组扩容、红黑树转换</font>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">  * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">  * value is replaced.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">  *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">  *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">  *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">  * put方法的最外层调用，注意，他是有返回值的，如果当前添加的键值对的键在map中已经存在，那么将旧值替换为新值，并且返回旧值。如果不存在，那么返回null。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 转而调用putVal方法完成处理，参数是：</span></span><br><span class="line"><span class="comment">      * 根据key计算得到的hash值</span></span><br><span class="line"><span class="comment">      * key</span></span><br><span class="line"><span class="comment">      * value</span></span><br><span class="line"><span class="comment">      * 后面两个忽略。。</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">  * 该方法是实现put方法的主体，主要流程如下：</span></span><br><span class="line"><span class="comment">  * 	1. 看是否是没有初始化的数组。如果是，那么就转到扩容方法进行初始化。</span></span><br><span class="line"><span class="comment">  * 	2. 计算hash值对应的数组索引位置，如果该位置上没有元素，直接插入成功。</span></span><br><span class="line"><span class="comment">  * 	3. 如果有元素了，那么用当前key的hash值和该索引位置上链表的所有节点的hash值进行比较。如果全都不同，那么插入成功。如果其中有相同的，那么比较调用当前节点的equals()方法进行比较，如果equals()返回false，那么仍然可以插入，如果equals（）返回true那么用当前节点的value去更新旧值。</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个tab作为属性table的副本，节点p用来作为某个节点的副本</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果属性table为空，或者map的长度为0，那么就表示底层数组没有初始化，转而就去调扩容方法来将数组进行初始化。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 节点p指向key的hash值计算得到的数组索引位置上的节点，如果这个索引位置上没有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 那么直接调用插入方法，将新节点插入在这个索引位置上</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果计算得到的数组索引上有元素了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果链表上的头结点和待插入节点的hash值相等且equals也是true，那么后面是直接会执行更新value操作的，这里给e赋值是标志。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果这个数组索引上不是链表而是红黑树，那么调用红黑树的put操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果待插入节点和头结点没有同一个key，那么比较链表上之后的所有节点的hash值和equals方法。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果全部比较完，还是没有相同的key那么这里e会是null（就是需要直接插入的情况）</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将新节点插在链表最末尾（七上八下，JDK7是插在头节点前面，JDK8是插在最末尾）</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 判断一下新节点插入后，链表是否需要转化称红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果存在与待插入节点相等的key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 循环增量</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e有值，那就是存在与待插入的节点相同的key，那么执行更新旧value的操作</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果执行了直接插入的操作，那么这里判断一下要不要扩容。且插入节点（没有更新旧value）返回null</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>有一点需要注意</strong>，<font color=red>即使是同一个数组索引位置上同一链表上的节点，也是会hash值不同的，而且很常见。</font>因为这个索引位置的确定是通过hash值取与运算得到的，所以任然有将待插入元素的key与链表上的所有元素的key比较hash值的必要。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">  * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">  * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">  * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">  * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">  * 数组扩容的主体方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// oldTab作为属性table的副本</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 如果是空参构造来的这里（数组没有赋值），那么原容量为0，否则就是取原数组的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 属性阈值的副本oldThr</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果不是还未使用过的数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果原容量已经（或者大于）最大容量了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 那么容量不变，阈值更新为整型的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，新容量扩容为原来的两倍。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 如果扩容后小于最大容量，并且原容量是大于默认容量的，那么将阈值扩大一倍（原来的两倍）</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定容构造器初始化了阈值，但是如果数组未定义过，因此数组新容量取阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 空参构造来到这里（数组没定义过，阈值没初始化过）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;	<span class="comment">// 新容量为默认容量值：16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新阈值为0，（定容构造调用会来到这里）那么，重新计算阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;	</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将属性阈值更新</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 容量确定后，用新容量创建新的底层数组，然后完成将原有数组中的元素嫁接到新数组中的一系列工作</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;		<span class="comment">// 数组统一是在这里造的</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-2-LinkedHashMap源码分析"><a href="#3-2-LinkedHashMap源码分析" class="headerlink" title="3.2 LinkedHashMap源码分析"></a>3.2 LinkedHashMap源码分析</h3><p>搞懂HashMap的底层实现后LinkedHashMap的底层实现就很简单了。</p>
<p><font color=red>LinkedHashMap是HashMap的子类，而且LinkedHashMap中很方法并没有重写，而是直接用了父类的方法。</font>因此只需重点关注不同部分。</p>
<ul>
<li>空参构造</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment">  * with the default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();	<span class="comment">// 直接调的父类HashMap的空参构造方法</span></span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定容构造</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment">  * with the specified initial capacity and a default load factor (0.75).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);	<span class="comment">// 同样是父类HashMap定容构造方法</span></span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，重点关注他的put方法如何实现在遍历Map元素时，可以按照添加的顺序实现遍历便可了。</p>
<p>但是</p>
<blockquote>
<ul>
<li>LinkedHashMap没有重写父类的put方法，因此子类对象调用put方法是直接去调的父类的put方法。</li>
<li>LinkedHashMap也没有重写父类的putValue方法，因此也是直接用的父类方法。</li>
</ul>
</blockquote>
<p>但是，LinkedHashMap重写了父类的newNode方法，即，在向数组（或数组索引位置上的链表）添加元素时，会调用子类自己的newNode方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调的是LinkedHashMap中自定义的结构Entry</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">  * Entry是HashMap中Node结构的子类，它继承了父类Node的结构外还定义了两个指针before和after，这样就在底层数组存放的同时，一个指向他的前序一个指向它的后序。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>意即，虽然LinkedHashMap底层的存储仍然是数组+链表+红黑树，<font color=red>但是每个元素节点都配有指向前序和后序的节点。</font>这样，在遍历起来就靠前序、后序找了。针对需要频繁遍历的map而言，提高的效率（遍历效率）。<strong>其余的与HashMap无异。</strong></li>
</ul>
<h3 id="3-3-TreeMap"><a href="#3-3-TreeMap" class="headerlink" title="3.3 TreeMap"></a>3.3 TreeMap</h3><p>向TreeMap中添加键值对，<font color=red>要求key必须是由同一个类创建的对象</font>。因为要按照&lt;key进行排序，因此便要考虑比较器<strong>（Comparable或Comparator）</strong>。</p>
<p>注意，只能按照key中的属性来排序，不能按照value排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        Map treeMap = <span class="keyword">new</span> TreeMap(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Student &amp;&amp; o2 <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">                    Student s1 = (Student) o1;</span><br><span class="line">                    Student s2 = (Student) o2;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(s1.age, s2.age);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;illegal argument exception!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">// 按照键的age属性进行排序。切记，不可按值排序</span></span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Student(<span class="string">&quot;tom&quot;</span>, <span class="number">10</span>), <span class="number">1</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Student(<span class="string">&quot;mary&quot;</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Student(<span class="string">&quot;kobe&quot;</span>, <span class="number">12</span>), <span class="number">3</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Student(<span class="string">&quot;jerff&quot;</span>, <span class="number">20</span>), <span class="number">4</span>);</span><br><span class="line">        System.out.println(treeMap);</span><br><span class="line"><span class="comment">// 运行结果： &#123;Student&#123;name=&#x27;mary&#x27;, age=9&#125;=2, Student&#123;name=&#x27;tom&#x27;, age=10&#125;=1, Student&#123;name=&#x27;kobe&#x27;, age=12&#125;=3, Student&#123;name=&#x27;jerff&#x27;, age=20&#125;=4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color=red>注意</font>区别LinkedHashMap的顺序和有TreeMap的有序。前者是能够保证输出的时候能够按照输入的顺序输出，后者是真正的排序。</strong></p>
<h3 id="3-4-Properties"><a href="#3-4-Properties" class="headerlink" title="3.4 Properties"></a>3.4 Properties</h3><ul>
<li><p>Properties类是Hashtable类的子类，虽然说Hashtable不怎么用了，但是Properties用于处理属性（配置）文件帮助很大。</p>
</li>
<li><p>Properties的<font color=red>键值对都是String类型</font>。</p>
</li>
<li><p>存取数据建议使用<font color=red>setProperties(String key, String value)方法</font>和<font color=red>getProperties(String key)方法</font>。</p>
</li>
</ul>
<p>考虑如下实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 操作文件需要读取文件流（配置文件为.properties结尾的文件）</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">        <span class="comment">// 加载流对应的文件</span></span><br><span class="line">        properties.load(fis);</span><br><span class="line">        <span class="comment">// 获取配置信息</span></span><br><span class="line">        String name = properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String age = properties.getProperty(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name :&quot;</span> + name + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;age:&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-Collections工具类"><a href="#4-Collections工具类" class="headerlink" title="4. Collections工具类"></a>4. Collections工具类</h2><ul>
<li>Collections是一个操作Set、List和Map等集合的工具类。</li>
<li>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</li>
</ul>
<ol>
<li><font color=red><strong>void reverse(List )</strong></font> ：反转List中元素的顺序。</li>
<li><font color=red><strong>void shuffle(List )</strong> </font>： 对List集合元素进行随机排序。</li>
<li><font color=red><strong>void sort(List )</strong></font> ： 根据元素的自然顺序对指定List集合元素按升序排序。</li>
<li><font color=red><strong>void sort(List , Comparator )</strong></font>： 根据指定的Comparator产生的顺序对List集合元素进行排序。</li>
<li><font color=red><strong>void swap(List , int , int )</strong> </font>： 将指定List集合中的两元素顺序进行交换。</li>
<li><font color=red><strong>Object max(Collection )</strong> </font>： 根据元素的自然顺序(Comparable接口)，返回给定集合中的最大元素。</li>
<li><font color=red><strong>Object max(Collection , Comparator )</strong> </font>：根据Comparator指定的顺序，返回给定集合中的最大元素。</li>
<li><font color=red><strong>Object min(Collection )</strong> </font>： 根据元素的自然顺序(Comparable接口)，返回给定集合中的最小元素。</li>
<li><font color=red><strong>Object max(Collection , Comparator)</strong> </font>： 根据元素的自然顺序(Comparable接口)，返回给定集合中的最小元素。</li>
<li><font color=red><strong>int frequency(Collection , Object )</strong> </font>：返回指定集合中指定元素的出现次数。</li>
<li><font color=red><strong>void copy(List dest, List src)</strong> </font>： 将src中的内容复制到dest中。<strong>（注意，dest的长度要大于src才行）</strong></li>
<li><font color=red><strong>boolean replaceAll(Lits list, Object oldVal, Object newVal)</strong></font>：使用新值替换list对象中的所有旧值。</li>
</ol>
<p><strong>注意：使用copy方法一定要确保dest的长度不小于src：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List src = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        src.add(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        src.add(<span class="number">15</span>);</span><br><span class="line">        src.add(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 现要将src的复制到dest中,注意将dest的长度设置为src长度的这个操作</span></span><br><span class="line">        List dest = Arrays.asList(<span class="keyword">new</span> Object[src.size()]);</span><br><span class="line">        Collections.copy(dest, src);</span><br><span class="line">        System.out.println(dest);   <span class="comment">// [ok, 15, 16]</span></span><br><span class="line">        System.out.println(src);    <span class="comment">// [ok, 15, 16]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="13">
<li><font color=red><strong>List synchronizedList(List )</strong></font>：将参数List转换为一个线程安全的List，这个线程安全的List作为返回值输出。所有根本不需要用Vector。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list1 = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<ol start="14">
<li><font color=red><strong>Map synchronizedMap(Map )</strong></font>：将参数Map转换为一个线程安全的Map，这个线程安全的Map作为返回值输出。所以根本不需要用Hashtable。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>计算机网络学习笔记</title>
    <url>/2020/12/06/notepad/read/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><ul>
<li>TCP: 提供可靠的数据传输服务</li>
<li>UDP： 不能保证数据的可靠传输</li>
</ul>
<h4 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h4><p>运输层负责将数据包发给 进程， 其中要到多路复用和多路分解</p>
<p>TCP： 使用四元组区分（源IP地址，源端口号， 目的IP地址， 目的端口号） 决定一个连接</p>
<p>UDP： 不是面向连接的，多个主机可以和一个主机使用连接， 只是对网络层协议增加了一点多路复用和分解服务而已</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP 的报文段结构只有  源端口号， 目的端口号， 长度，校验和（16）位，应用数据， </p>
<p>checksum：  按照一定距离拆分求和</p>
<p>为什么要在 UDP 设置checksum 呢？  原因是由于不能保证源与目的之间的所有链路都提供差错检测！ 链路层的协议可能不一样！ 在路由器的内存中也可能出错， 链路层只能保证在链路上不出错！</p>
<h4 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h4><p>使用有限状态机构建可靠的数据传输方式</p>
<p>使用流水线传输， 解决流水线差错恢复的基本方法是： 回退 N 步 和 选择重传</p>
<h5 id="回退N步（也称为滑动窗口协议）"><a href="#回退N步（也称为滑动窗口协议）" class="headerlink" title="回退N步（也称为滑动窗口协议）"></a>回退N步（也称为滑动窗口协议）</h5><p>基序号 +  下一个序号 +  窗口长度</p>
<h5 id="选择重传（SR）"><a href="#选择重传（SR）" class="headerlink" title="选择重传（SR）"></a>选择重传（SR）</h5><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>差错检测， 重传， 累计确认，定时器以及序号和确认号的首部字段。</p>
<p>TCP 提供全双工的服务</p>
<p>MSS + 40 Bit = MTU （链路层可以装下的数据长度）</p>
<p>当收到3 个 ACK的时候快速重传，ps： 为什么不是两个？</p>
<h5 id="连接管理："><a href="#连接管理：" class="headerlink" title="连接管理："></a>连接管理：</h5><p>三次握手， 四次挥手</p>
<p>拥塞控制</p>
<h5 id="TCP-拥塞控制算法"><a href="#TCP-拥塞控制算法" class="headerlink" title="TCP 拥塞控制算法"></a>TCP 拥塞控制算法</h5><p>1、 慢启动</p>
<p>2、 拥塞避免</p>
<p>3、 快速恢复</p>
<p>总结： </p>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。 </li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </li>
<li>TCP 的接收端会丢弃重复的数据。 </li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送，通过告知窗口。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </li>
</ol>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>路由器的主要作用便是将数据报从入链路转发到出链路</p>
<p>主要有三个组件</p>
<ul>
<li>第一个组件 IP 协议</li>
<li>第二个组件 路由选择算法</li>
<li>第三个组件是差错</li>
</ul>
<h5 id="转发和路由选择"><a href="#转发和路由选择" class="headerlink" title="转发和路由选择"></a>转发和路由选择</h5><ul>
<li>转发</li>
</ul>
<p>当一个分组到达路由器的一条输入链路时， 路由器必须将该分组移动到适当的输出链路</p>
<ul>
<li>路由选择</li>
</ul>
<p>当分组从发送方流向接收方时， 网络层必须决定这些分组所采用的路由或路径</p>
<p>网络层提供的是尽力而为的服务， why？</p>
<h4 id="虚电路和数据报网络"><a href="#虚电路和数据报网络" class="headerlink" title="虚电路和数据报网络"></a>虚电路和数据报网络</h4><ul>
<li>虚电路网络</li>
</ul>
<p>仅在网络层提供连接服务的网络，每一台路由器都要参与虚电路的建立，并且知道所有的虚电路， 路由器要分配 vc 号</p>
<ul>
<li>数据报网络</li>
</ul>
<p>仅在网络层提供无连接服务的网络</p>
<p>每隔 1- 5 分钟更新一次转发表</p>
<h4 id="路由器的工作原理"><a href="#路由器的工作原理" class="headerlink" title="路由器的工作原理"></a>路由器的工作原理</h4><ul>
<li>接受帧    </li>
<li>放入队列（缓存管理）    </li>
<li>交换<ul>
<li>经过内存交换（多个线路分速率）</li>
<li>经总线交换</li>
<li>经互联网交换</li>
</ul>
</li>
</ul>
<h4 id="因特网中的转发和编址"><a href="#因特网中的转发和编址" class="headerlink" title="因特网中的转发和编址"></a>因特网中的转发和编址</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/fuck.png"></p>
<p>IP 数据分片， 当链路层提供的 MTU 大小比 IP 数据报小时， IP 数据包就要进行分片！</p>
<h5 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h5><h6 id="无类别域间路由选择-CIDR"><a href="#无类别域间路由选择-CIDR" class="headerlink" title="无类别域间路由选择(CIDR)"></a>无类别域间路由选择(CIDR)</h6><p>也叫 地址聚合，路由聚合，路由摘要</p>
<h6 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h6><p>DHCP 是 4 个步骤的过程</p>
<ul>
<li>DHCP 服务器发现， 通过链路层广播</li>
<li>DHCP 服务器提供，也是广播，因为可能有多个</li>
<li>DHCP 请求一个 IP</li>
<li>DHCP ACK 一个报文</li>
</ul>
<h6 id="网络地址转换-（NAT）"><a href="#网络地址转换-（NAT）" class="headerlink" title="网络地址转换 （NAT）"></a>网络地址转换 （NAT）</h6><p>对外界就如同具有单一 IP 地址的单一设备， 使用端口来区分主机</p>
<h5 id="因特网控制报文协议（ICMP）"><a href="#因特网控制报文协议（ICMP）" class="headerlink" title="因特网控制报文协议（ICMP）"></a>因特网控制报文协议（ICMP）</h5><p>ICMP 可以认为是 IP 的一部分， 但是从体系结构上讲它是位于 IP 之上的，因为 ICMP 报文是承载在 <strong>IP 分组中的</strong> </p>
<p>ping 程序是直接在 OS 支持的服务，不是一个进程</p>
<p>tracetoute 是用  ICMP 报文来实现的， 每次发送一个 TTL i 的 <strong>IP 数据</strong>报</p>
<h4 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h4><h5 id="全局式路由选择算法"><a href="#全局式路由选择算法" class="headerlink" title="全局式路由选择算法"></a>全局式路由选择算法</h5><p>链路状态算法（Link State， LS），dijkstra算法</p>
<p>OSPF（广播算法实现）</p>
<h5 id="分散式路由选择算法"><a href="#分散式路由选择算法" class="headerlink" title="分散式路由选择算法"></a>分散式路由选择算法</h5><p>距离向量（Distance-Vector， DV），bellman-ford</p>
<p>分布式的，不需要知道全局的信息， 迭代，异步</p>
<p>RIP， BGP，ARP</p>
<p>1、 链路费用给比啦与链路故障</p>
<p>使用了由之前计算出的距离，需要迭代很慢。</p>
<p>2、 增加毒性逆转</p>
<p>无法解决多节点的无穷计数问题</p>
<h5 id="层次路由选择"><a href="#层次路由选择" class="headerlink" title="层次路由选择"></a>层次路由选择</h5><p>当规模大的时候，路由器组织 自治系统（AS）来解决， 相同的AS 中选择相同的路由选择算法，多个AS 之间发送数据的路由器为<strong>网关路由器</strong></p>
<h4 id="因特网中的路由选择"><a href="#因特网中的路由选择" class="headerlink" title="因特网中的路由选择"></a>因特网中的路由选择</h4><h5 id="自治系统内部的路由选择："><a href="#自治系统内部的路由选择：" class="headerlink" title="自治系统内部的路由选择："></a>自治系统内部的路由选择：</h5><p>AS 内部路由选择协议又称为<strong>内部网关协议</strong></p>
<h6 id="路由选择信息协议：-RIP（Routing-Infomation-Protocal）"><a href="#路由选择信息协议：-RIP（Routing-Infomation-Protocal）" class="headerlink" title="路由选择信息协议： RIP（Routing Infomation Protocal）"></a>路由选择信息协议： RIP（Routing Infomation Protocal）</h6><p>距离向量协议， 路由选择更新信息在邻居之间通过 RIP 响应报文来交换，大约 30 秒相互交换一次， 维护一张路由选择表的RIP 表。</p>
<p><font color = "red"> important: </font> RIP 使用一个位于<strong>网络层协议（IP）</strong>之上的<strong>运输层协议（UDP）</strong>来实现<strong>网络层功能</strong>！</p>
<h6 id="开放最短路优先：OSPF-（Open-SHortest-Path-First）"><a href="#开放最短路优先：OSPF-（Open-SHortest-Path-First）" class="headerlink" title="开放最短路优先：OSPF （Open SHortest Path First）"></a>开放最短路优先：OSPF （Open SHortest Path First）</h6><p>使用洪泛链路状态信息和 dijkstra算法</p>
<h5 id="自治系统间的路由选择："><a href="#自治系统间的路由选择：" class="headerlink" title="自治系统间的路由选择："></a>自治系统间的路由选择：</h5><h5 id="边界网关协议：Broder-Gateway-Protocol（BGP）"><a href="#边界网关协议：Broder-Gateway-Protocol（BGP）" class="headerlink" title="边界网关协议：Broder Gateway Protocol（BGP）"></a>边界网关协议：Broder Gateway Protocol（BGP）</h5><ul>
<li>从相邻AS 处获得子网可达信息</li>
<li>向本 AS 内部的所有路由器传播这些可达性信息</li>
<li>基于可达性信息和 AS 策略， 决定达到子网的“好”路由</li>
</ul>
<p>使用的是 TCP 连接， 目的地是CDIR 前缀， 每一个前缀表示一个子网或者一个子网集合</p>
<h4 id="广播和多播路由选择"><a href="#广播和多播路由选择" class="headerlink" title="广播和多播路由选择"></a>广播和多播路由选择</h4><h5 id="广播路由选择"><a href="#广播路由选择" class="headerlink" title="广播路由选择"></a>广播路由选择</h5><p>网络层提供了从一种源节点到网络中的其他所有节点交付分组的服务</p>
<h6 id="无控制洪泛"><a href="#无控制洪泛" class="headerlink" title="无控制洪泛"></a>无控制洪泛</h6><p>向相邻的节点发送副本</p>
<h6 id="受控洪泛"><a href="#受控洪泛" class="headerlink" title="受控洪泛"></a>受控洪泛</h6><p>使用序号控制洪泛</p>
<h6 id="生成树广播"><a href="#生成树广播" class="headerlink" title="生成树广播"></a>生成树广播</h6><p>最小生成树的方向上去广播</p>
<h6 id="实践中的广播算法"><a href="#实践中的广播算法" class="headerlink" title="实践中的广播算法"></a>实践中的广播算法</h6><p>广播协议被用于应用层和网络层</p>
<ul>
<li><p>TCP 使用 TTL 跳数 限制</p>
</li>
<li><p>OSPF 路由选择算法和中间系统到中间系统路由选择算法中，使用了一种序号控制洪泛来广播链路状态通告</p>
</li>
</ul>
<h5 id="多播路由选择"><a href="#多播路由选择" class="headerlink" title="多播路由选择"></a>多播路由选择</h5><p>使单个源节点能够向其他网络节点的一个子集发送分组的副本</p>
<p>使用间接地址来编址，用一个标识来表示一组接收方</p>
<h6 id="因特网组管理协议（IGMP）"><a href="#因特网组管理协议（IGMP）" class="headerlink" title="因特网组管理协议（IGMP）"></a>因特网组管理协议（IGMP）</h6><p>使用的生成树多播，这一部分略略略</p>
<hr>
<h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>链路层的主体部分是在网络适配器中实现的， 网络适配器有时也称为网络接口卡（网卡 Network Interface Card， NIC）。</p>
<p>一句话概述其工作过程就是将网络层的分组数据包组织起来，通过物理层以比特流的形式发送。</p>
<h4 id="差错检测的3种技术"><a href="#差错检测的3种技术" class="headerlink" title="差错检测的3种技术"></a>差错检测的3种技术</h4><h5 id="1、-奇偶校验（描述原理）"><a href="#1、-奇偶校验（描述原理）" class="headerlink" title="1、 奇偶校验（描述原理）"></a>1、 奇偶校验（描述原理）</h5><p>包含一位附加比特位， 所有的 1 的比特的数量为<strong>偶数</strong>。</p>
<h5 id="2、检验和-checksum（传输层）"><a href="#2、检验和-checksum（传输层）" class="headerlink" title="2、检验和 checksum（传输层）"></a>2、检验和 checksum（传输层）</h5><p>一个d 比特的数据看做一个k比特整数的序列处理，将这些整数加起来的和作为检测差错比特。</p>
<p><font color='gree'> 传输层的检测方法？</font></p>
<h5 id="3、循环冗余检测-CRC（用于链路层）"><a href="#3、循环冗余检测-CRC（用于链路层）" class="headerlink" title="3、循环冗余检测 CRC（用于链路层）"></a>3、循环冗余检测 CRC（用于链路层）</h5><blockquote>
<p>D ·  2 ^r^  XOR R = nG</p>
</blockquote>
<p>数据段： D， 冗余检测段： R， r位的R，</p>
<blockquote>
<p> R = remainder( D · 2^r^ / G ) </p>
</blockquote>
<p>数据段 D 一直除以 G 就可以得到 2^r^  和 余数R</p>
<p>通过发送端和接受端都根据G 来计算出 R，原理是什么？</p>
<h6 id="为什么传输层用-checksum-而链路层用CRC？"><a href="#为什么传输层用-checksum-而链路层用CRC？" class="headerlink" title="为什么传输层用 checksum 而链路层用CRC？"></a>为什么传输层用 checksum 而链路层用CRC？</h6><p>因为传输层是运行于os 的软件实现，需要简单快速， 链路层是在适配器中用专门的硬件实现的，能够快速执行 CRC 操作！</p>
<h4 id="多路访问链路协议"><a href="#多路访问链路协议" class="headerlink" title="多路访问链路协议"></a>多路访问链路协议</h4><p>网络链路类型</p>
<ul>
<li>点对点链路</li>
<li>广播链路： 共享一个信道</li>
</ul>
<h6 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h6><ul>
<li>时分多路复用</li>
<li>频分多路复用</li>
<li>码分多址（CDMA）</li>
</ul>
<h6 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h6><ul>
<li>时隙ALOHA</li>
</ul>
<p>随机开始发送， 有冲突时以一定概率延时一些时隙</p>
<p>当 N 个节点访问的时候， 效率为 37 %，低！</p>
<ul>
<li>ALOHA</li>
</ul>
<p>随机开发发送，有冲突时一定概率继续发送</p>
<p>效率更低！ 为时隙的一半</p>
<ul>
<li>载波侦听多路访问（CSMA/CD carrier sense multiple access with collision detection）</li>
</ul>
<p>理论效率接近 1</p>
<h6 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h6><ul>
<li>轮询协议</li>
</ul>
<p>主节点轮询访问每一个节点，控制发送，解决冲突问题， 但是引入了轮询时延和主节点单点故障</p>
<ul>
<li>令牌传递协议</li>
</ul>
<p>传递令牌来作为主节点</p>
<h4 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h4><h5 id="链路层寻址和-ARP"><a href="#链路层寻址和-ARP" class="headerlink" title="链路层寻址和 ARP"></a>链路层寻址和 ARP</h5><ul>
<li>MAC 地址</li>
</ul>
<p>48位，每一个适配器（网络接口） 有链路层地址，不是主机。</p>
<h6 id="为什么要有-MAC地址？"><a href="#为什么要有-MAC地址？" class="headerlink" title="为什么要有 MAC地址？"></a>为什么要有 MAC地址？</h6><blockquote>
<p>1、 局域网是为任意的网络层协议设计的， 不只是 IP 和 因特网。</p>
</blockquote>
<blockquote>
<p> 2、如果是IP地址，存储于 RAM 每次都要重新配置</p>
</blockquote>
<blockquote>
<p> 如果将ip存在适配器中，那么每次发的信息都会中断主机</p>
</blockquote>
<ul>
<li>地址解析协议（ARP）</li>
</ul>
<p>将 IP 解析为 MAC 地址， 类似DNS， 属于网络层和链路层。</p>
<p><strong>路由器的每一个接口都有一个  ARP 模块和适配器！</strong></p>
<p>路由器和交换机的区别</p>
<p>路由器是第3 层的， 交换机是第二层（链路层）， 对于主机和交换机是透明的存在</p>
<h5 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h5><p>以太网帧的第一段为数据字段， 最大为 1500， 因此 MTU  =  1500</p>
<h4 id="浏览器访问的流程"><a href="#浏览器访问的流程" class="headerlink" title="浏览器访问的流程"></a>浏览器访问的流程</h4><p>主机     –    交换机A    –  路由器A</p>
<h5 id="准备阶段一：-DHCP，-UDP，-IP，-以太网帧"><a href="#准备阶段一：-DHCP，-UDP，-IP，-以太网帧" class="headerlink" title="准备阶段一： DHCP， UDP， IP， 以太网帧"></a>准备阶段一： DHCP， UDP， IP， 以太网帧</h5><p>1、 主机运行dhcp 服务， 没有ip的情况下， 发送DHCP 报文</p>
<p>2、 以太网帧封装 DHCP 帧，进行广播</p>
<p>3、交换机A广播以太网帧</p>
<p>4、路由器A 接受到DHCO 报文， 进行解析UDP</p>
<p>5、封装 IP 等信息返回给主机</p>
<p>6、交换接收到会保存交换机表，下次不用再访问</p>
<p>7、主机发送 DHCP ACK</p>
<p>至此已经获得了 IP 地址可以发送数据了</p>
<h5 id="准备阶段二：DNS和ARP"><a href="#准备阶段二：DNS和ARP" class="headerlink" title="准备阶段二：DNS和ARP"></a>准备阶段二：DNS和ARP</h5><p>8、 对于浏览器链接首先要解析出 IP， 发送 DNS 报文</p>
<p>9、 网关路由器的 MAC 还不知道， 封装 ARP 协议 </p>
<p>10、封装网关的IP 进行 ARP 广播</p>
<p>11、 网关收到了ARP 报文帧，返回 MAC 地址</p>
<p>12、 此时主机得到网关的 MAC</p>
<p>13、 现在可以发动数据了，发送 DNS数据</p>
<h5 id="准备阶段三：-路由到DNS服务器"><a href="#准备阶段三：-路由到DNS服务器" class="headerlink" title="准备阶段三： 路由到DNS服务器"></a>准备阶段三： 路由到DNS服务器</h5><p>14、 根据路由表发送 DNS 数据到 DNS的路由器上</p>
<p>15、 DNS 的路由器收到消息后再转发到 DNS 服务器上，（BGP协议）</p>
<p>16、  DNS 返回IP给主机</p>
<p>17、 获得了 目的主机的 ip</p>
<h5 id="CS-交互：-TCP-HTTP"><a href="#CS-交互：-TCP-HTTP" class="headerlink" title="CS 交互： TCP HTTP"></a>CS 交互： TCP HTTP</h5><p>18、 首先3次握手，封装 目的 MAC 地址为网关路由器的的帧， 后面就直接BGP 跳转了。。。 MAC 只是局部的</p>
<p>19、 使用转发表一直到目的主机</p>
]]></content>
  </entry>
  <entry>
    <title>easy_c</title>
    <url>/2020/12/06/notepad/read/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/easy_c/</url>
    <content><![CDATA[<h1 id="easy-c"><a href="#easy-c" class="headerlink" title="easy_c"></a><center>easy_c</center></h1><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>实现一门基于 x86 平台的编译器， 链接基于GNU as， 功能实现加减乘除， 函数调用， if 语句和while循环，，输出整数值和字符串，不实现指针和数组。</p>
<p>目的在于实现编译器的功能， 所以没有做很强大的语法功能， 自选了几个常用的作为实现， 虽然弱小，但五脏俱全！</p>
<p>湖南大学编译原理实验1-8， 这里大概介绍实现的思路， 具体太多细节， 看原码： <a class="link"   href="https://github.com/Fierygit/easy_c" >github<i class="fas fa-external-link-alt"></i></a></p>
<p>开始实现时参考了 青木的自制编译器， 发现书中用到的语言是java，我打算使用c来实现， 发现有很多的不同， 书中前段使用了java的正则表达式等， 我想使用编译原理课上学过的知识来实现。</p>
<h2 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h2><p>这一部分在开始的没有列全，好后悔好后悔！！！倒置项目在进行到最后的时候， 发现这也忘记考虑了， 那也忘记考虑了， 吸取经验： <strong>在写项目的时候， 一定先要有一个实现目标</strong>。 不然到最后突然发现， 输出字符串词法分析没有实现， 倒置到最后只能强前面几千方的代码， 也只能使用ID作为字符串输出ID的值。-_-</p>
<h4 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+ - * /</span><br></pre></td></tr></table></figure>

<h4 id="逻辑运算："><a href="#逻辑运算：" class="headerlink" title="逻辑运算："></a>逻辑运算：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">== 	&lt;= 	&gt;=</span><br></pre></td></tr></table></figure>

<h4 id="操作符："><a href="#操作符：" class="headerlink" title="操作符："></a>操作符：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+= 	 -=	 /= 	*=</span><br></pre></td></tr></table></figure>

<h4 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h4><p>变量使用前统一声明， 在函数开始时， 或者全局声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数里面的a会首先找函数体里面声明的变量， 然后再找全局变量里声明的符号</span></span><br></pre></td></tr></table></figure>

<p>所有的大括号不能省略！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a == <span class="number">10</span>) <span class="keyword">return</span> a;  <span class="comment">// error!!!</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>);           <span class="comment">//error!!!</span></span><br></pre></td></tr></table></figure>

<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a;</span><br><span class="line">a &#x3D; 10;</span><br><span class="line">print(a);</span><br><span class="line">&#x2F;&#x2F; &gt; 10</span><br><span class="line">print[a];</span><br><span class="line">&#x2F;&#x2F; &gt; a</span><br></pre></td></tr></table></figure>




<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p> <strong>else  if  int  return  void  while</strong> <strong>print</strong></p>
<h4 id="专用符号"><a href="#专用符号" class="headerlink" title="专用符号"></a>专用符号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ - * &#x2F; &lt;  &gt; &#x3D; ; , ( )  &#123; &#125; &#x2F;* *&#x2F;</span><br></pre></td></tr></table></figure>



<h4 id="其他标记"><a href="#其他标记" class="headerlink" title="其他标记"></a>其他标记</h4><p>ID = letter letter*</p>
<p>NUM = digit digit*</p>
<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D; &lt;&#x3D; &gt;&#x3D;</span><br></pre></td></tr></table></figure>

<h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+&#x3D; 	-&#x3D;	  *&#x3D;	 &#x2F;&#x3D;</span><br></pre></td></tr></table></figure>

<h4 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h4><p>使用状态机：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200118150829.png"></p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/tes"></p>
<p>其它类似方法！！！</p>
<p>每次读入一个字符就判断它去了那个状态， 简单的编译器使用这种方法是实现简单，但是当编译器大的时候， 这种情况就变的十分的庞大！</p>
<h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span>&#123;</span></span><br><span class="line">  <span class="built_in">string</span> type;</span><br><span class="line">  <span class="built_in">string</span> value;</span><br><span class="line">  <span class="keyword">int</span> row;			<span class="comment">// 保留每个token的 行数</span></span><br><span class="line">  <span class="keyword">int</span> column;		<span class="comment">// 保留每个token的  列数</span></span><br><span class="line">  Token(<span class="built_in">string</span> type, <span class="built_in">string</span> value, <span class="keyword">int</span> row, <span class="keyword">int</span> column)&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;type = type;</span><br><span class="line">      <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">      <span class="keyword">this</span>-&gt;row = row;</span><br><span class="line">      <span class="keyword">this</span>-&gt;column = column;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>保存每一个记号的 行数 和 列数</p>
<p><img src="C:%5CUsers%5CFirefly%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200118195516438.png" alt="image-20200118195516438"></p>
<p>上面图片是将每一个token存入 vector 中， 最后将其输出！</p>
<h2 id="语法分析："><a href="#语法分析：" class="headerlink" title="语法分析："></a>语法分析：</h2><p>语法分析采用的是 LL（1） 的递归下降文法！ 向前看看一个字符， 首先转换为右递归文法！！</p>
<p>LL（1）是。。。。。。</p>
<h5 id="NFA文法：（提取自c-编译器）"><a href="#NFA文法：（提取自c-编译器）" class="headerlink" title="NFA文法：（提取自c-编译器）"></a>NFA文法：（提取自c-编译器）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">param -&gt;  INT</span><br><span class="line">param_list  -&gt;  param  |  param_list, param</span><br><span class="line">params -&gt; NULL |  param_list</span><br><span class="line">local_declaration  -&gt;   var-decaration  | NULL</span><br><span class="line">arg-list → arg-list , expression|expression</span><br><span class="line">args → arg - list | empty</span><br><span class="line">call →  ID (args)</span><br><span class="line">factor  -&gt;  ( expression ) | var | call | NUM</span><br><span class="line">term   -&gt; factor  op  term  | factor   右循环</span><br><span class="line">additive_expression   -&gt;    term  |   term op  additive_expression ;  op &#x3D; + | -</span><br><span class="line">simple_expression  -&gt;  additive_expression </span><br><span class="line">				|  additive_expression op additive_expression  (op &#x3D;&#x3D; &gt;&#x3D; &lt;&#x3D;)</span><br><span class="line">iteration_stmt    -&gt;   while(expression) &#123; statement_list &#125;</span><br><span class="line">expression    -&gt;   simple_expression  |  var &#x3D; expression</span><br><span class="line">expression_stmt   -&gt;   expression ; || ;</span><br><span class="line">statement -&gt;  iteration_stmt | selection_stmt | expression_stmt |</span><br><span class="line">				return_stmt | print_stmt</span><br><span class="line">statement_list   -&gt;   statement_list statement || NULL</span><br><span class="line">compound_stmt -&gt;  local_declaration &amp; statement_list</span><br><span class="line">declaration  -&gt; var-declare | fun-declare</span><br><span class="line">declaration_list   -&gt;  declaration |  declaration_list</span><br><span class="line">。。。。。</span><br><span class="line">参考parse.cpp</span><br></pre></td></tr></table></figure>

<p>由此生成语法树！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">child</span>[4];</span>  <span class="comment">//四个子节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">sibling</span>;</span>   <span class="comment">//存储兄弟节点</span></span><br><span class="line">  <span class="keyword">int</span> tokenIndex;             <span class="comment">//存储代码的位置, 可以获取到信息</span></span><br><span class="line">  NodeKind nodekind;          <span class="comment">//存储类型</span></span><br><span class="line">  <span class="built_in">string</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> isVisit;  <span class="comment">// 中间代码生成的时候用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个函数最多有四部分构成  int max （ ） ｛  ｝</p>
<p>所以使用 四个子孩子就行了！</p>
<h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>语义分析主要有两大部分：</p>
<h4 id="一、变量声明"><a href="#一、变量声明" class="headerlink" title="一、变量声明"></a>一、变量声明</h4><p>当有一个变量声明， 把声明加入符号表， 之后要是用到了这个变量就查找符号表！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VariableInfo</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">int</span> lineNo;      <span class="comment">//所在的代码行数</span></span><br><span class="line">  <span class="keyword">int</span> location;    <span class="comment">// 在内存的位置</span></span><br><span class="line">  <span class="built_in">string</span> type;     <span class="comment">//变量的类型， 只有一个类型 INT</span></span><br><span class="line">  TreeNode *node;  <span class="comment">//记录声明的节点在哪里</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录 每一个变量声明的地方  &lt; 函数名字，  &lt; 变量名字， Variableinfo  &gt;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;VariableInfo&gt; &gt; var_table</span><br></pre></td></tr></table></figure>

<p>// 记录 每一个变量声明的地方  &lt; 函数名字，  &lt; 变量名字， Variableinfo  &gt;</p>
<p>通过函数 变量名字找信息， 全局变量的 函数名字为 golbal， 在找一个id是否有定义的时候， 通过这个map找信息，  c语言是可以重复命名的， if 里面可以定义变量， 在一开始定义语言的时候， 想的是使用变量时必须函数一开始要定义， 没想到要在if里面也可以定义， 所以这里这个数据结构够用了， 如果要考虑作用域， 加多一个 scope 的变量， 标记同一个变量名的作用域， 作用域从小往大找， 找到global都没有就报错！</p>
<h4 id="二、类型检查"><a href="#二、类型检查" class="headerlink" title="二、类型检查"></a>二、类型检查</h4><p>类型检查包括两大部分：</p>
<h5 id="函数参数检查"><a href="#函数参数检查" class="headerlink" title="函数参数检查"></a>函数参数检查</h5><p>每当有一个函数声明， 记录函数的参数个数， 当调用的时候，检查类型和参数！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FunctionInfo</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> param_num;       <span class="comment">// 参数的个数</span></span><br><span class="line">  vstr param_type;     <span class="comment">// 每个参数的类型</span></span><br><span class="line">  <span class="built_in">string</span> return_type;  <span class="comment">// 返回的类型</span></span><br><span class="line">  TreeNode *node;      <span class="comment">//记录声明的节点在哪里</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录每一个 函数的信息符号表, 全局变量也在这里</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, FunctionInfo&gt; fun_table;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是记录， 函数的信息， 每当有一个函数声明的时候加入这个数据结构， 当有函数调用的时候， 找这个表，检查参数的个数！</p>
<h5 id="语句类型检查"><a href="#语句类型检查" class="headerlink" title="语句类型检查"></a>语句类型检查</h5><p>检查语句两边的参数是否正确， 不正确的话，输出错误！</p>
<p>如果有一个语法树的节点为 + ， <strong>递归</strong>检查这个节点的两边是否都为整形！</p>
<h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><p>前序遍历语法树， 把对应的节点生成 <strong>三地址码</strong>。</p>
<p>这部分最主要的是设计数据结构， 由于一开始没有设计好数据结构， 发现后面写的很乱！！！！！</p>
<p>提前想好程序是怎么跑的很重要！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MidArgs</span> &#123;</span></span><br><span class="line">  <span class="comment">// type 分为 STR, ID， TMP,  NUM；</span></span><br><span class="line">  <span class="comment">// bool  用INT  0  1 表示</span></span><br><span class="line">  <span class="built_in">string</span> type;</span><br><span class="line">  <span class="built_in">string</span> value;</span><br><span class="line">  <span class="comment">// 代码有全局变量和非全局变量</span></span><br><span class="line">  <span class="comment">// 到符号表里面找， 全变量用伪标签</span></span><br><span class="line">  <span class="comment">// 堆： 自己创建的内存（不用）   栈： 函数临时变量   全局区：</span></span><br><span class="line">  <span class="comment">// 静态和全局变量区（伪标签实现） 字符串 属于全局区</span></span><br><span class="line">  <span class="keyword">bool</span> isGlobal;</span><br><span class="line">  <span class="keyword">int</span> offset;  <span class="comment">//栈中, type = tmp, id                  全局变量直接用！！！，</span></span><br><span class="line">               <span class="comment">//不用找</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数调用     call(10, a);</span></span><br><span class="line"><span class="comment">// op = param arg1 = a  arg2 = NULL   op = param  arg1 = 10  arg2 = NULL</span></span><br><span class="line"><span class="comment">// op = call  arg1 = id       op  = return arg1 = id or null</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MidCodeItem</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> dest;</span><br><span class="line">  <span class="built_in">string</span> op;</span><br><span class="line">  MidArgs *arg1;</span><br><span class="line">  MidArgs *arg2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MidCode</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> funcName;</span><br><span class="line">  <span class="keyword">int</span> stackSize;  <span class="comment">// 只有整形的值， 只考虑4字节， 因此只需要偏移量, 动态变化</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;MidCodeItem *&gt; item;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">vector</span>&lt;MidCode *&gt; midCode;</span><br><span class="line"><span class="comment">// 声明 ID 加入， value随机初始     TMP 生成一条语句加入 ， 或更改id，</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;, MidArgs *&gt; stackInfo;  <span class="comment">// ID, TMP, 加入</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这一部分我写的最头疼一部分的时候， 太多变量要去考虑， 刚开始的时候每出现一个变量就去看看他的定义， 没办法， 每一个变量都要用到。</p>
<p>每一个操作数的节点，+ - * / 都会生成一个临时变量， 函数调用也会。用一个全局变量递增临时变量， 加上双下划线作为前缀防止变量名冲突！！！</p>
<p>（注意函数调用的三地址码）</p>
<p>下面是其中一个代码的中间代码： </p>
<p>dest                                             op                                                arg1                                                    arg2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FUNCTION: VAR_DECLARE	(stackSize: <span class="number">0</span>)</span><br><span class="line">	                    INT                 	[p, ID, <span class="number">0</span>, <span class="number">1</span>]                 NONE                          </span><br><span class="line">FUNCTION: test	(stackSize: <span class="number">4</span>)</span><br><span class="line">	__t1                +                   	[a, ARG, <span class="number">0</span>, <span class="number">0</span>]                [b, ARG, <span class="number">1</span>, <span class="number">0</span>]                </span><br><span class="line">	ans                 =                   	[__t1, TMP, <span class="number">1</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	__t2                -                   	[ans, ID, <span class="number">0</span>, <span class="number">0</span>]               [<span class="number">1</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                </span><br><span class="line">	                    PRINT               	[__t2, TMP, <span class="number">2</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	__t3                -                   	[a, ARG, <span class="number">0</span>, <span class="number">0</span>]                [<span class="number">1</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                </span><br><span class="line">	                    <span class="keyword">return</span>              	[__t3, TMP, <span class="number">3</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">FUNCTION: main	(stackSize: <span class="number">9</span>)</span><br><span class="line">	a                   =                   	[<span class="number">3</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                NONE                          </span><br><span class="line">	p                   =                   	[<span class="number">1</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                NONE                          </span><br><span class="line">	Label0:             LABEL               	NONE                          NONE                          </span><br><span class="line">	                    <span class="keyword">if</span>                  	[a, ID, <span class="number">0</span>, <span class="number">0</span>]                 NONE                          </span><br><span class="line">	                    <span class="keyword">goto</span>                	[Label1:, LABEL, <span class="number">1</span>, <span class="number">0</span>]        NONE                          </span><br><span class="line">	                    <span class="keyword">goto</span>                	[Label2:, LABEL, <span class="number">2</span>, <span class="number">0</span>]        NONE                          </span><br><span class="line">	Label1:             LABEL               	NONE                          NONE                          </span><br><span class="line">	__t3                =                   	[a, ID, <span class="number">0</span>, <span class="number">0</span>]                 NONE                          </span><br><span class="line">	__t4                =                   	[p, ID, <span class="number">0</span>, <span class="number">1</span>]                 NONE                          </span><br><span class="line">	                    ARG                 	[__t4, TMP, <span class="number">4</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	                    ARG                 	[__t3, TMP, <span class="number">3</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	__t5                CALL                	[test, CALL, <span class="number">0</span>, <span class="number">0</span>]            [<span class="number">8</span>, ARG_NUM, <span class="number">0</span>, <span class="number">0</span>]            </span><br><span class="line">	a                   =                   	[__t5, TMP, <span class="number">5</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	                    <span class="keyword">goto</span>                	[Label0:, TMP, <span class="number">6</span>, <span class="number">0</span>]          NONE                          </span><br><span class="line">	Label2:             LABEL               	NONE                          NONE                          </span><br><span class="line">	                    PRINT               	[<span class="number">4</span>, STR, <span class="number">0</span>, <span class="number">1</span>]                NONE                          </span><br><span class="line">	                    PRINT               	[space, STR, <span class="number">0</span>, <span class="number">1</span>]            NONE                          </span><br><span class="line">	                    PRINT               	[<span class="number">5</span>, STR, <span class="number">0</span>, <span class="number">1</span>]                NONE                          </span><br><span class="line">	                    PRINT               	[<span class="built_in">endl</span>, STR, <span class="number">0</span>, <span class="number">1</span>]             NONE                          </span><br><span class="line">	                    <span class="keyword">if</span>                  	[<span class="number">1</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                NONE                          </span><br><span class="line">	                    <span class="keyword">goto</span>                	[Label3:, LABEL, <span class="number">7</span>, <span class="number">0</span>]        NONE                          </span><br><span class="line">	                    <span class="keyword">goto</span>                	[Label4:, LABEL, <span class="number">8</span>, <span class="number">0</span>]        NONE                          </span><br><span class="line">	Label3:             LABEL               	NONE                          NONE                          </span><br><span class="line">	p                   =                   	[<span class="number">2020</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	                    PRINT               	[p, ID, <span class="number">0</span>, <span class="number">1</span>]                 NONE                          </span><br><span class="line">	Label4:             LABEL               	NONE                          NONE                          </span><br><span class="line">	                    <span class="keyword">return</span>              	[<span class="number">0</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                NONE     </span><br></pre></td></tr></table></figure>

<p>总结这一步分， 烦， 烦人！ 想吐</p>
<p>到这一部分和前面感觉又分开了！！！^ _ ^，  我只需要遍历中间代码的数据结构， 生成对应的汇编， 首先还得学汇编，，， 于是另一篇博客产生， 总结汇编用到的指令</p>
<h2 id="汇编代码生成"><a href="#汇编代码生成" class="headerlink" title="汇编代码生成"></a>汇编代码生成</h2><p>总思路：</p>
<p>把字符串放到 rodata静态变量段</p>
<p>全局变量通过 comm 放到 静态数据段</p>
<p>所有的变量直接进行压栈处理</p>
<p>函数一开始，先分配所有变量用到的空间大小</p>
<p>当要函数调用时， 有多少个参数就扩大多少栈空间，在函数调用后返回值在eax， 再还原栈空间</p>
<p>还有很多对应汇编知识和实现方式细节：</p>
<p><a href="">blog</a></p>
<h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><h4 id="优化一：活性分析"><a href="#优化一：活性分析" class="headerlink" title="优化一：活性分析"></a>优化一：活性分析</h4><p>按照之前的思路， 在生成汇编代码的时候， 有很多临时变量也压栈了， 但是大多数的临时变量其实只用了一次， 也就是说一次性用品， 按照上课的思路， 来一个活性分析， 当一个变量在后面没有再被引用的情况， 把这个变量在栈的空间赋给另一个变量使用！！！ 但是这个实现有点难， 老师也只讲了思路，有点复杂， 没有实现</p>
<h4 id="优化二：常量折叠"><a href="#优化二：常量折叠" class="headerlink" title="优化二：常量折叠"></a>优化二：常量折叠</h4><p>当一个语法树节点为+ - 等， 而且左右子节点树都为常量， 提前计算好！！！这个遍历语法书就行了</p>
<h4 id="优化三：提前条件判断"><a href="#优化三：提前条件判断" class="headerlink" title="优化三：提前条件判断"></a>优化三：提前条件判断</h4><p>if(0)  这种情况直接不要！！！！</p>
]]></content>
  </entry>
</search>
