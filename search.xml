<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/1899/11/30/notepad/README/</url>
    <content><![CDATA[<h1 id="notepad"><a href="#notepad" class="headerlink" title="notepad"></a>notepad</h1><p>hexo</p>
<h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><ul>
<li>sql必知必回</li>
</ul>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><ul>
<li><p>netty</p>
</li>
<li><p>tomcat</p>
</li>
</ul>
<h2 id="数据密集型应用"><a href="#数据密集型应用" class="headerlink" title="数据密集型应用"></a>数据密集型应用</h2><h2 id="毕设"><a href="#毕设" class="headerlink" title="毕设"></a>毕设</h2><div class="friends-link-container">
    <ul class="friends-link-list">
            <li class="friends-link-item">
                <a href="https://xpoet.cn/">
                    <div class="content">
                        <div class="avatar radius">
                                <img class="radius" alt="XPoet" src="https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg">   
                        </div>
                        <div class="info">
                            <div class="name">XPoet</div>
                            <div class="description">所有命运的馈赠，早已在暗中标好价格。</div>
                        </div>
                    </div>
                </a>
            </li>
            <li class="friends-link-item">
                <a target="_blank" rel="noopener" href="https://www.nomar.cn/">
                    <div class="content">
                        <div class="avatar radius">
                                <i class="fas fa-user-friends"></i>
                        </div>
                        <div class="info">
                            <div class="name">nomar</div>
                            <div class="description">技术记录分享</div>
                        </div>
                    </div>
                </a>
            </li>
            <li class="friends-link-item">
                <a target="_blank" rel="noopener" href="https://mphy.gitee.io/">
                    <div class="content">
                        <div class="avatar radius">
                                <img class="radius" alt="Murphy's Blog" src="https://mphy.gitee.io/images/head.jpg">   
                        </div>
                        <div class="info">
                            <div class="name">Murphy's Blog</div>
                            <div class="description">热爱互联网、热爱技术、热爱代码！</div>
                        </div>
                    </div>
                </a>
            </li>
    </ul>
    <div class="clear"></div>
</div>









]]></content>
  </entry>
  <entry>
    <title>easy_c</title>
    <url>/2019/06/05/notepad/compiling/easy_c/</url>
    <content><![CDATA[<h1 id="easy-c"><a href="#easy-c" class="headerlink" title="easy_c"></a><center>easy_c</center></h1><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>实现一门基于 x86 平台的编译器， 链接基于GNU as， 功能实现加减乘除， 函数调用， if 语句和while循环，，输出整数值和字符串，不实现指针和数组。</p>
<p>目的在于实现编译器的功能， 所以没有做很强大的语法功能， 自选了几个常用的作为实现， 虽然弱小，但五脏俱全！</p>
<p>湖南大学编译原理实验1-8， 这里大概介绍实现的思路， 具体太多细节， 看原码： <a class="link"   href="https://github.com/Fierygit/easy_c" >github<i class="fas fa-external-link-alt"></i></a></p>
<p>开始实现时参考了 青木的自制编译器， 发现书中用到的语言是java，我打算使用c来实现， 发现有很多的不同， 书中前段使用了java的正则表达式等， 我想使用编译原理课上学过的知识来实现。</p>
<h2 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h2><p>这一部分在开始的没有列全，好后悔好后悔！！！倒置项目在进行到最后的时候， 发现这也忘记考虑了， 那也忘记考虑了， 吸取经验： <strong>在写项目的时候， 一定先要有一个实现目标</strong>。 不然到最后突然发现， 输出字符串词法分析没有实现， 倒置到最后只能强前面几千方的代码， 也只能使用ID作为字符串输出ID的值。-_-</p>
<h4 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+ - * /</span><br></pre></td></tr></table></figure>

<h4 id="逻辑运算："><a href="#逻辑运算：" class="headerlink" title="逻辑运算："></a>逻辑运算：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">== 	&lt;= 	&gt;=</span><br></pre></td></tr></table></figure>

<h4 id="操作符："><a href="#操作符：" class="headerlink" title="操作符："></a>操作符：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+= 	 -=	 /= 	*=</span><br></pre></td></tr></table></figure>

<h4 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h4><p>变量使用前统一声明， 在函数开始时， 或者全局声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数里面的a会首先找函数体里面声明的变量， 然后再找全局变量里声明的符号</span></span><br></pre></td></tr></table></figure>

<p>所有的大括号不能省略！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a == <span class="number">10</span>) <span class="keyword">return</span> a;  <span class="comment">// error!!!</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>);           <span class="comment">//error!!!</span></span><br></pre></td></tr></table></figure>

<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a;</span><br><span class="line">a &#x3D; 10;</span><br><span class="line">print(a);</span><br><span class="line">&#x2F;&#x2F; &gt; 10</span><br><span class="line">print[a];</span><br><span class="line">&#x2F;&#x2F; &gt; a</span><br></pre></td></tr></table></figure>




<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p> <strong>else  if  int  return  void  while</strong> <strong>print</strong></p>
<h4 id="专用符号"><a href="#专用符号" class="headerlink" title="专用符号"></a>专用符号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ - * &#x2F; &lt;  &gt; &#x3D; ; , ( )  &#123; &#125; &#x2F;* *&#x2F;</span><br></pre></td></tr></table></figure>



<h4 id="其他标记"><a href="#其他标记" class="headerlink" title="其他标记"></a>其他标记</h4><p>ID = letter letter*</p>
<p>NUM = digit digit*</p>
<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D; &lt;&#x3D; &gt;&#x3D;</span><br></pre></td></tr></table></figure>

<h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+&#x3D; 	-&#x3D;	  *&#x3D;	 &#x2F;&#x3D;</span><br></pre></td></tr></table></figure>

<h4 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h4><p>使用状态机：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200118150829.png"></p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/tes"></p>
<p>其它类似方法！！！</p>
<p>每次读入一个字符就判断它去了那个状态， 简单的编译器使用这种方法是实现简单，但是当编译器大的时候， 这种情况就变的十分的庞大！</p>
<h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span>&#123;</span></span><br><span class="line">  <span class="built_in">string</span> type;</span><br><span class="line">  <span class="built_in">string</span> value;</span><br><span class="line">  <span class="keyword">int</span> row;			<span class="comment">// 保留每个token的 行数</span></span><br><span class="line">  <span class="keyword">int</span> column;		<span class="comment">// 保留每个token的  列数</span></span><br><span class="line">  Token(<span class="built_in">string</span> type, <span class="built_in">string</span> value, <span class="keyword">int</span> row, <span class="keyword">int</span> column)&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;type = type;</span><br><span class="line">      <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">      <span class="keyword">this</span>-&gt;row = row;</span><br><span class="line">      <span class="keyword">this</span>-&gt;column = column;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>保存每一个记号的 行数 和 列数</p>
<p><img src="C:%5CUsers%5CFirefly%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200118195516438.png" alt="image-20200118195516438"></p>
<p>上面图片是将每一个token存入 vector 中， 最后将其输出！</p>
<h2 id="语法分析："><a href="#语法分析：" class="headerlink" title="语法分析："></a>语法分析：</h2><p>语法分析采用的是 LL（1） 的递归下降文法！ 向前看看一个字符， 首先转换为右递归文法！！</p>
<p>LL（1）是。。。。。。</p>
<h5 id="NFA文法：（提取自c-编译器）"><a href="#NFA文法：（提取自c-编译器）" class="headerlink" title="NFA文法：（提取自c-编译器）"></a>NFA文法：（提取自c-编译器）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">param -&gt;  INT</span><br><span class="line">param_list  -&gt;  param  |  param_list, param</span><br><span class="line">params -&gt; NULL |  param_list</span><br><span class="line">local_declaration  -&gt;   var-decaration  | NULL</span><br><span class="line">arg-list → arg-list , expression|expression</span><br><span class="line">args → arg - list | empty</span><br><span class="line">call →  ID (args)</span><br><span class="line">factor  -&gt;  ( expression ) | var | call | NUM</span><br><span class="line">term   -&gt; factor  op  term  | factor   右循环</span><br><span class="line">additive_expression   -&gt;    term  |   term op  additive_expression ;  op &#x3D; + | -</span><br><span class="line">simple_expression  -&gt;  additive_expression </span><br><span class="line">				|  additive_expression op additive_expression  (op &#x3D;&#x3D; &gt;&#x3D; &lt;&#x3D;)</span><br><span class="line">iteration_stmt    -&gt;   while(expression) &#123; statement_list &#125;</span><br><span class="line">expression    -&gt;   simple_expression  |  var &#x3D; expression</span><br><span class="line">expression_stmt   -&gt;   expression ; || ;</span><br><span class="line">statement -&gt;  iteration_stmt | selection_stmt | expression_stmt |</span><br><span class="line">				return_stmt | print_stmt</span><br><span class="line">statement_list   -&gt;   statement_list statement || NULL</span><br><span class="line">compound_stmt -&gt;  local_declaration &amp; statement_list</span><br><span class="line">declaration  -&gt; var-declare | fun-declare</span><br><span class="line">declaration_list   -&gt;  declaration |  declaration_list</span><br><span class="line">。。。。。</span><br><span class="line">参考parse.cpp</span><br></pre></td></tr></table></figure>

<p>由此生成语法树！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">child</span>[4];</span>  <span class="comment">//四个子节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">sibling</span>;</span>   <span class="comment">//存储兄弟节点</span></span><br><span class="line">  <span class="keyword">int</span> tokenIndex;             <span class="comment">//存储代码的位置, 可以获取到信息</span></span><br><span class="line">  NodeKind nodekind;          <span class="comment">//存储类型</span></span><br><span class="line">  <span class="built_in">string</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> isVisit;  <span class="comment">// 中间代码生成的时候用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个函数最多有四部分构成  int max （ ） ｛  ｝</p>
<p>所以使用 四个子孩子就行了！</p>
<h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>语义分析主要有两大部分：</p>
<h4 id="一、变量声明"><a href="#一、变量声明" class="headerlink" title="一、变量声明"></a>一、变量声明</h4><p>当有一个变量声明， 把声明加入符号表， 之后要是用到了这个变量就查找符号表！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VariableInfo</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">int</span> lineNo;      <span class="comment">//所在的代码行数</span></span><br><span class="line">  <span class="keyword">int</span> location;    <span class="comment">// 在内存的位置</span></span><br><span class="line">  <span class="built_in">string</span> type;     <span class="comment">//变量的类型， 只有一个类型 INT</span></span><br><span class="line">  TreeNode *node;  <span class="comment">//记录声明的节点在哪里</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录 每一个变量声明的地方  &lt; 函数名字，  &lt; 变量名字， Variableinfo  &gt;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;VariableInfo&gt; &gt; var_table</span><br></pre></td></tr></table></figure>

<p>// 记录 每一个变量声明的地方  &lt; 函数名字，  &lt; 变量名字， Variableinfo  &gt;</p>
<p>通过函数 变量名字找信息， 全局变量的 函数名字为 golbal， 在找一个id是否有定义的时候， 通过这个map找信息，  c语言是可以重复命名的， if 里面可以定义变量， 在一开始定义语言的时候， 想的是使用变量时必须函数一开始要定义， 没想到要在if里面也可以定义， 所以这里这个数据结构够用了， 如果要考虑作用域， 加多一个 scope 的变量， 标记同一个变量名的作用域， 作用域从小往大找， 找到global都没有就报错！</p>
<h4 id="二、类型检查"><a href="#二、类型检查" class="headerlink" title="二、类型检查"></a>二、类型检查</h4><p>类型检查包括两大部分：</p>
<h5 id="函数参数检查"><a href="#函数参数检查" class="headerlink" title="函数参数检查"></a>函数参数检查</h5><p>每当有一个函数声明， 记录函数的参数个数， 当调用的时候，检查类型和参数！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FunctionInfo</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> param_num;       <span class="comment">// 参数的个数</span></span><br><span class="line">  vstr param_type;     <span class="comment">// 每个参数的类型</span></span><br><span class="line">  <span class="built_in">string</span> return_type;  <span class="comment">// 返回的类型</span></span><br><span class="line">  TreeNode *node;      <span class="comment">//记录声明的节点在哪里</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录每一个 函数的信息符号表, 全局变量也在这里</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, FunctionInfo&gt; fun_table;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是记录， 函数的信息， 每当有一个函数声明的时候加入这个数据结构， 当有函数调用的时候， 找这个表，检查参数的个数！</p>
<h5 id="语句类型检查"><a href="#语句类型检查" class="headerlink" title="语句类型检查"></a>语句类型检查</h5><p>检查语句两边的参数是否正确， 不正确的话，输出错误！</p>
<p>如果有一个语法树的节点为 + ， <strong>递归</strong>检查这个节点的两边是否都为整形！</p>
<h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><p>前序遍历语法树， 把对应的节点生成 <strong>三地址码</strong>。</p>
<p>这部分最主要的是设计数据结构， 由于一开始没有设计好数据结构， 发现后面写的很乱！！！！！</p>
<p>提前想好程序是怎么跑的很重要！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MidArgs</span> &#123;</span></span><br><span class="line">  <span class="comment">// type 分为 STR, ID， TMP,  NUM；</span></span><br><span class="line">  <span class="comment">// bool  用INT  0  1 表示</span></span><br><span class="line">  <span class="built_in">string</span> type;</span><br><span class="line">  <span class="built_in">string</span> value;</span><br><span class="line">  <span class="comment">// 代码有全局变量和非全局变量</span></span><br><span class="line">  <span class="comment">// 到符号表里面找， 全变量用伪标签</span></span><br><span class="line">  <span class="comment">// 堆： 自己创建的内存（不用）   栈： 函数临时变量   全局区：</span></span><br><span class="line">  <span class="comment">// 静态和全局变量区（伪标签实现） 字符串 属于全局区</span></span><br><span class="line">  <span class="keyword">bool</span> isGlobal;</span><br><span class="line">  <span class="keyword">int</span> offset;  <span class="comment">//栈中, type = tmp, id                  全局变量直接用！！！，</span></span><br><span class="line">               <span class="comment">//不用找</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数调用     call(10, a);</span></span><br><span class="line"><span class="comment">// op = param arg1 = a  arg2 = NULL   op = param  arg1 = 10  arg2 = NULL</span></span><br><span class="line"><span class="comment">// op = call  arg1 = id       op  = return arg1 = id or null</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MidCodeItem</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> dest;</span><br><span class="line">  <span class="built_in">string</span> op;</span><br><span class="line">  MidArgs *arg1;</span><br><span class="line">  MidArgs *arg2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MidCode</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> funcName;</span><br><span class="line">  <span class="keyword">int</span> stackSize;  <span class="comment">// 只有整形的值， 只考虑4字节， 因此只需要偏移量, 动态变化</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;MidCodeItem *&gt; item;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">vector</span>&lt;MidCode *&gt; midCode;</span><br><span class="line"><span class="comment">// 声明 ID 加入， value随机初始     TMP 生成一条语句加入 ， 或更改id，</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;, MidArgs *&gt; stackInfo;  <span class="comment">// ID, TMP, 加入</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这一部分我写的最头疼一部分的时候， 太多变量要去考虑， 刚开始的时候每出现一个变量就去看看他的定义， 没办法， 每一个变量都要用到。</p>
<p>每一个操作数的节点，+ - * / 都会生成一个临时变量， 函数调用也会。用一个全局变量递增临时变量， 加上双下划线作为前缀防止变量名冲突！！！</p>
<p>（注意函数调用的三地址码）</p>
<p>下面是其中一个代码的中间代码： </p>
<p>dest                                             op                                                arg1                                                    arg2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FUNCTION: VAR_DECLARE	(stackSize: <span class="number">0</span>)</span><br><span class="line">	                    INT                 	[p, ID, <span class="number">0</span>, <span class="number">1</span>]                 NONE                          </span><br><span class="line">FUNCTION: test	(stackSize: <span class="number">4</span>)</span><br><span class="line">	__t1                +                   	[a, ARG, <span class="number">0</span>, <span class="number">0</span>]                [b, ARG, <span class="number">1</span>, <span class="number">0</span>]                </span><br><span class="line">	ans                 =                   	[__t1, TMP, <span class="number">1</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	__t2                -                   	[ans, ID, <span class="number">0</span>, <span class="number">0</span>]               [<span class="number">1</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                </span><br><span class="line">	                    PRINT               	[__t2, TMP, <span class="number">2</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	__t3                -                   	[a, ARG, <span class="number">0</span>, <span class="number">0</span>]                [<span class="number">1</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                </span><br><span class="line">	                    <span class="keyword">return</span>              	[__t3, TMP, <span class="number">3</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">FUNCTION: main	(stackSize: <span class="number">9</span>)</span><br><span class="line">	a                   =                   	[<span class="number">3</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                NONE                          </span><br><span class="line">	p                   =                   	[<span class="number">1</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                NONE                          </span><br><span class="line">	Label0:             LABEL               	NONE                          NONE                          </span><br><span class="line">	                    <span class="keyword">if</span>                  	[a, ID, <span class="number">0</span>, <span class="number">0</span>]                 NONE                          </span><br><span class="line">	                    <span class="keyword">goto</span>                	[Label1:, LABEL, <span class="number">1</span>, <span class="number">0</span>]        NONE                          </span><br><span class="line">	                    <span class="keyword">goto</span>                	[Label2:, LABEL, <span class="number">2</span>, <span class="number">0</span>]        NONE                          </span><br><span class="line">	Label1:             LABEL               	NONE                          NONE                          </span><br><span class="line">	__t3                =                   	[a, ID, <span class="number">0</span>, <span class="number">0</span>]                 NONE                          </span><br><span class="line">	__t4                =                   	[p, ID, <span class="number">0</span>, <span class="number">1</span>]                 NONE                          </span><br><span class="line">	                    ARG                 	[__t4, TMP, <span class="number">4</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	                    ARG                 	[__t3, TMP, <span class="number">3</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	__t5                CALL                	[test, CALL, <span class="number">0</span>, <span class="number">0</span>]            [<span class="number">8</span>, ARG_NUM, <span class="number">0</span>, <span class="number">0</span>]            </span><br><span class="line">	a                   =                   	[__t5, TMP, <span class="number">5</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	                    <span class="keyword">goto</span>                	[Label0:, TMP, <span class="number">6</span>, <span class="number">0</span>]          NONE                          </span><br><span class="line">	Label2:             LABEL               	NONE                          NONE                          </span><br><span class="line">	                    PRINT               	[<span class="number">4</span>, STR, <span class="number">0</span>, <span class="number">1</span>]                NONE                          </span><br><span class="line">	                    PRINT               	[space, STR, <span class="number">0</span>, <span class="number">1</span>]            NONE                          </span><br><span class="line">	                    PRINT               	[<span class="number">5</span>, STR, <span class="number">0</span>, <span class="number">1</span>]                NONE                          </span><br><span class="line">	                    PRINT               	[<span class="built_in">endl</span>, STR, <span class="number">0</span>, <span class="number">1</span>]             NONE                          </span><br><span class="line">	                    <span class="keyword">if</span>                  	[<span class="number">1</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                NONE                          </span><br><span class="line">	                    <span class="keyword">goto</span>                	[Label3:, LABEL, <span class="number">7</span>, <span class="number">0</span>]        NONE                          </span><br><span class="line">	                    <span class="keyword">goto</span>                	[Label4:, LABEL, <span class="number">8</span>, <span class="number">0</span>]        NONE                          </span><br><span class="line">	Label3:             LABEL               	NONE                          NONE                          </span><br><span class="line">	p                   =                   	[<span class="number">2020</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]             NONE                          </span><br><span class="line">	                    PRINT               	[p, ID, <span class="number">0</span>, <span class="number">1</span>]                 NONE                          </span><br><span class="line">	Label4:             LABEL               	NONE                          NONE                          </span><br><span class="line">	                    <span class="keyword">return</span>              	[<span class="number">0</span>, NUM, <span class="number">0</span>, <span class="number">0</span>]                NONE     </span><br></pre></td></tr></table></figure>

<p>总结这一步分， 烦， 烦人！ 想吐</p>
<p>到这一部分和前面感觉又分开了！！！^ _ ^，  我只需要遍历中间代码的数据结构， 生成对应的汇编， 首先还得学汇编，，， 于是另一篇博客产生， 总结汇编用到的指令</p>
<h2 id="汇编代码生成"><a href="#汇编代码生成" class="headerlink" title="汇编代码生成"></a>汇编代码生成</h2><p>总思路：</p>
<p>把字符串放到 rodata静态变量段</p>
<p>全局变量通过 comm 放到 静态数据段</p>
<p>所有的变量直接进行压栈处理</p>
<p>函数一开始，先分配所有变量用到的空间大小</p>
<p>当要函数调用时， 有多少个参数就扩大多少栈空间，在函数调用后返回值在eax， 再还原栈空间</p>
<p>还有很多对应汇编知识和实现方式细节：</p>
<p><a href="">blog</a></p>
<h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><h4 id="优化一：活性分析"><a href="#优化一：活性分析" class="headerlink" title="优化一：活性分析"></a>优化一：活性分析</h4><p>按照之前的思路， 在生成汇编代码的时候， 有很多临时变量也压栈了， 但是大多数的临时变量其实只用了一次， 也就是说一次性用品， 按照上课的思路， 来一个活性分析， 当一个变量在后面没有再被引用的情况， 把这个变量在栈的空间赋给另一个变量使用！！！ 但是这个实现有点难， 老师也只讲了思路，有点复杂， 没有实现</p>
<h4 id="优化二：常量折叠"><a href="#优化二：常量折叠" class="headerlink" title="优化二：常量折叠"></a>优化二：常量折叠</h4><p>当一个语法树节点为+ - 等， 而且左右子节点树都为常量， 提前计算好！！！这个遍历语法书就行了</p>
<h4 id="优化三：提前条件判断"><a href="#优化三：提前条件判断" class="headerlink" title="优化三：提前条件判断"></a>优化三：提前条件判断</h4><p>if(0)  这种情况直接不要！！！！</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>x86 汇编器编程</title>
    <url>/2019/06/05/notepad/compiling/x86%20%E6%B1%87%E7%BC%96%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="x86-汇编器编程"><a href="#x86-汇编器编程" class="headerlink" title="x86 汇编器编程"></a>x86 汇编器编程</h2><p>基于x86 实现编译器首先得了解x86 平台的指令调度， 以下是一些我在实现编译器过程中用到的基础知识！</p>
<p>大部分内容参考了 青木的自制编译器，</p>
<h3 id="基于GNU汇编器"><a href="#基于GNU汇编器" class="headerlink" title="基于GNU汇编器"></a>基于GNU汇编器</h3><p>c语言使用gcc 编译， 而gcc 编译器将c代码转化为汇编之后， 也是用的GNU as 的汇编器将汇编语言 .s 转化为.o，然后再连接， 因此如果自制编译器， 也是做到汇编这一步， 所以又得学x86 汇编器的使用方法！</p>
<p>gcc 用的 GNU， 那我就直接使用gcc！</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">as hello.s &#x2F;&#x2F;默认生成 a.out</span><br></pre></td></tr></table></figure>

<p>也可以指定名字：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">as -o hello.o hello.s</span><br></pre></td></tr></table></figure>

<p>生成目标文件后还要连接才可以执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>

<p>最后就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure>



<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>指令包括  <strong>助记符</strong> 和 <strong>操作数</strong> 组成，比如 <code>movl %esp， %ebp</code> , movl 助记符， 后面两个为操作数， 操作数可以为多个！逗号分隔。</p>
<p>这个是由cpu直接执行的指令</p>
<h4 id="汇编伪操作"><a href="#汇编伪操作" class="headerlink" title="汇编伪操作"></a>汇编伪操作</h4><p>以点 “.” 开头的， 末尾没有冒号 “：” 的 <strong>行</strong> 都是汇编伪操作行。</p>
<p>由汇编器执行，记录元数据和设定指令的属性。</p>
<p>汇编的首行缩进是没有影响的</p>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>以冒号“：” 结尾的 <strong>行</strong> 都是标签行</p>
<p>冒号是语法， 标签名为冒号前面的值。</p>
<p>一般命名加上 . ，避免和代码里面的名字重复。</p>
<h4 id="助记符后缀"><a href="#助记符后缀" class="headerlink" title="助记符后缀"></a>助记符后缀</h4><table>
<thead>
<tr>
<th align="center">后缀</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">b</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">32</td>
</tr>
</tbody></table>
<h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><h5 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h5><p>使用$num 来标识， $1 表示 1</p>
<h5 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h5><p>可以直接当做立即数， 使用 % 作为前缀， %eax = %EAX</p>
<h5 id="直接内存引用"><a href="#直接内存引用" class="headerlink" title="直接内存引用"></a>直接内存引用</h5><p>直接访问固定内存</p>
<h5 id="间接内存访问"><a href="#间接内存访问" class="headerlink" title="间接内存访问"></a>间接内存访问</h5><p>相当于使用c语言的数组</p>
<p>例子：</p>
<p><code>movl %ecx, %eax</code><br>最后，将ecx 寄存器中的数据作为地址访问内存，并将内存上的数据加载到eax 寄存器中<br>的写法如下所示。</p>
<p><code>movl (%ecx), %eax</code><br>不习惯汇编的话会觉得%ecx 和(%ecx) 的区别难以理解，可以把它当作C 语言的指针。<br>指针变量ptr 自身的值等同于%ecx 的话，那么对指针的取值操作*ptr 就相当于(%ecx)。<br>另外，%ecx 是访问寄存器，而(%ecx) 则是利用寄存器访问内存。</p>
<p>//todo important</p>
<h3 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h3><h4 id="传输指令："><a href="#传输指令：" class="headerlink" title="传输指令："></a>传输指令：</h4><h5 id="movl"><a href="#movl" class="headerlink" title="movl"></a>movl</h5><p>mov 是在寄存器或内存之间传输数据，或者将立即数加载到寄存器或<br>内存的指令。mov 也是汇编语言中最常用的指令之一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov 立即数，寄存器</span><br><span class="line">mov 寄存器， 寄存器</span><br><span class="line">mov 内存，寄存器</span><br><span class="line">mov 立即数，内存</span><br><span class="line">mov 寄存器，内存</span><br><span class="line">mov 内存，内存</span><br></pre></td></tr></table></figure>



<h5 id="pop-and-push"><a href="#pop-and-push" class="headerlink" title="pop and push"></a>pop and push</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 立即数</span><br><span class="line">push 寄存器</span><br></pre></td></tr></table></figure>

<p>push 指令将数据压栈。具体来说，<strong>将esp 寄存器减去压栈的数据的大小</strong>(注意会自己减去)，再将数据存储到<br>esp 寄存器所指向的地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop 寄存器</span><br></pre></td></tr></table></figure>

<p>pop 指令将数据出栈并写入寄存器。具体来说，将数据从esp 寄存器所指向的地址加载到<br>寄存器，再将esp 寄存器加上出栈的数据的大小。</p>
<h5 id="leal"><a href="#leal" class="headerlink" title="leal"></a>leal</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea 内存，寄存器</span><br></pre></td></tr></table></figure>

<p>lea 指令将地址加载到寄存器。lea 是Load Effective Address（实效地址加载）的简称。<br>“lea 内存, 寄存器”将内存对应的地址加载到寄存器。</p>
<p><strong>note:</strong></p>
<p>mov 指令表示将ebx 寄存器加4 后的值作为内存地址进行访问，并将数据加载到eax 寄存器中。<br><code>movl 4(%ebx), %eax</code></p>
<p>另一方面，将上述语句中的mov 指令替换为lea 指令，如下所示。该语句表示将ebx 寄存<br>器加上4 后的值保存到eax。</p>
<p><code>leal 4(%ebx), %eax</code><br>同样是间接内存引用的语句，mov 指令取得的是内存地址所指向的内存上的数据，而lea<br>指令取得的是内存地址本身。</p>
<p>//! important</p>
<h4 id="运算指令："><a href="#运算指令：" class="headerlink" title="运算指令："></a>运算指令：</h4><h5 id="addl"><a href="#addl" class="headerlink" title="addl"></a>addl</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add 立即数， 寄存器</span><br><span class="line">add 寄存器， 寄存器</span><br><span class="line">add 内存， 寄存器</span><br><span class="line">add 立即数， 内存</span><br><span class="line">add 寄存器， 内存</span><br></pre></td></tr></table></figure>

<p>add 指令将第1 操作数和第2 操作数相加，并将结果写入第2 操作数。<br>请注意“将运算结果写入第2 操作数”这一点。</p>
<p>例如add$1, %eax 表示将eax 寄存器的数据加1，并将结果保存到eax 寄存器。类似于C 语言中的+= 运算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">addl $<span class="number">1</span>, %eax # 将eax 寄存器加<span class="number">1</span></span><br><span class="line">addl %ecx, %eax <span class="meta"># eax 寄存器和ecx 寄存器的数据相加后存放到eax 寄存器</span></span><br><span class="line">addl $<span class="number">4</span>, (%ebx) # 将ebx 寄存器所指向的内存中的数据加<span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>加减乘除差不多！！</p>
<h3 id="流程控制指令："><a href="#流程控制指令：" class="headerlink" title="流程控制指令："></a><strong>流程控制指令：</strong></h3><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>jmp</td>
<td>无条件跳转</td>
</tr>
<tr>
<td>jz、jnz、je、jne</td>
<td>条件跳转</td>
</tr>
<tr>
<td>cmp</td>
<td>数据的比较</td>
</tr>
<tr>
<td>test</td>
<td>数据的非0 检查</td>
</tr>
<tr>
<td>sete、setne、setg、setge、setl、setle</td>
<td>获取eflags 寄存器中的各个标志位</td>
</tr>
<tr>
<td>call</td>
<td>函数调用</td>
</tr>
<tr>
<td>ret</td>
<td>从子程序返回</td>
</tr>
</tbody></table>
<p>其它指令类似！</p>
<h3 id="汇编的功能"><a href="#汇编的功能" class="headerlink" title="汇编的功能"></a>汇编的功能</h3><table>
<thead>
<tr>
<th>代码段</th>
<th>功能</th>
<th>对应汇编格式</th>
</tr>
</thead>
<tbody><tr>
<td>bss段</td>
<td>BSS段通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文BlockStartedby Symbol的简称。BSS段属于静态内存分配。</td>
<td>.bss</td>
</tr>
<tr>
<td>data段</td>
<td>数据段通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</td>
<td>.comm</td>
</tr>
<tr>
<td>text段</td>
<td>代码段通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</td>
<td>.text</td>
</tr>
<tr>
<td>rodata段</td>
<td>存放C中的字符串和#define定义的常量</td>
<td>.rodata</td>
</tr>
<tr>
<td>stack栈</td>
<td>用户存放程序临时创建的局部变量</td>
<td>push和pop使用</td>
</tr>
</tbody></table>
<h3 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a>函数调用：</h3><p>经过我无数次直接从gcc 生成汇编观察出， 调用函数， 首先是参数压栈处理然后， ebp 的值压栈， 接下来返回地址压栈， 用一个图表示：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200130211927.png"></p>
<p>当调用函数时， 先扩大栈空间， 把参数压栈， 然后在被调用函数里面使用参数记得是 ebp 加上 8， 中间有返回地址和旧ebp的值！</p>
<h3 id="赋值语句实现："><a href="#赋值语句实现：" class="headerlink" title="赋值语句实现："></a>赋值语句实现：</h3><p>x86所有的寄存器是通用的， 想用那个就用哪个！</p>
<p>截取自ecc</p>
<pre><code># asign
movl    8(%esp),%esi
leal    12(%esp),%edi
movl    %esi,(%edi)</code></pre>
<p>其它类似。。。我用gcc 生成汇编，一步一步摸索出来的。。。</p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Wolrd In C</title>
    <url>/2019/11/02/notepad/cxx/c_notepad/</url>
    <content><![CDATA[<h1 id="c-c-note"><a href="#c-c-note" class="headerlink" title=" c / c++ note"></a><center> c / c++ note</center></h1><p>c / c++ 遇到的bug 或者小技巧集</p>
<p>[TOC]</p>
<h2 id="typedef-和-define"><a href="#typedef-和-define" class="headerlink" title="typedef 和 #define"></a>typedef 和 #define</h2><p>每一个例子都看懂 == 入门c</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义新的类型</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>* t1;</span><br><span class="line"><span class="comment">//预处理， 替换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> t2  int*</span></span><br><span class="line"></span><br><span class="line">t1 a, b; <span class="comment">//等价于  int *a, *b;</span></span><br><span class="line">t2 a,b;  <span class="comment">//等价于  int *a, b;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> b = <span class="number">10</span>; <span class="comment">//等价于 const int b = 10;*************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这两种写法是一样的，  定义 指针常量, t1 相当于一个新的类型, 如b的定义</span></span><br><span class="line">t1 <span class="keyword">const</span> p1 = &amp;a;</span><br><span class="line"><span class="keyword">const</span> t1 p1 = &amp;a;</span><br><span class="line">*t1 = <span class="number">12</span>;    <span class="comment">//可改变量</span></span><br><span class="line">t1 = &amp;b; <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t1 *p5 = &amp;p1; <span class="comment">// 指向  新类型的指针， 这个指针不可变</span></span><br><span class="line">p1 = &amp;b; 			<span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t1 * <span class="keyword">const</span> p5 = &amp;p1; <span class="comment">// 这个指针不可变, 而且指针指向的指针的对应的值不可变</span></span><br><span class="line">**p1 = <span class="number">11</span> <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t2 p2 = &amp;a;</span><br><span class="line"><span class="comment">//等价于 const int * p2 = &amp;a;</span></span><br></pre></td></tr></table></figure>









<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>~ 用于数字或者整形变量之前，表示对该数取反操作，其规则是~0=1, ~1=0, 如二进制0101 0101取反后就是1010 1010</p>
<p>测试得到： -a - 1  ==  ~a </p>
<ul>
<li>判断 2 的 乘方：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n &amp; n - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>输出二进制 1 的个数:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int cnt &#x3D; 0;</span><br><span class="line">while(n) n &amp;&#x3D; n-1, ++cnt</span><br></pre></td></tr></table></figure>



<h2 id="memset赋值无穷大"><a href="#memset赋值无穷大" class="headerlink" title="memset赋值无穷大"></a>memset赋值无穷大</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> G[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(G, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(G));   <span class="comment">//  输出这个1061109567,给数据赋值无穷大的方法</span></span><br></pre></td></tr></table></figure>

<p>memset 是按照一个字节来赋值的， 因此memset 会执行  sizeof（int） * 10 也就是40次的赋值，因此，</p>
<p> <code>G[0] = 0x3f3f3f3f</code> .</p>
<p>为什么要选择 0x3f3f3f3f 作为无穷大？  因为这个数相加还是在 int 的范围之内， 无穷大相加还是无穷大， 而且这个数方便写, 连续4个 3f！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0x3f3f3f3f</span> 	&lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0x3f3f3f3f</span> * <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0x7fffffff</span> 	&lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ~(<span class="number">1</span>&lt;&lt;<span class="number">31</span>) 		&lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1061109567</span></span><br><span class="line"><span class="number">2122219134</span></span><br><span class="line"><span class="number">2147483647</span></span><br><span class="line"><span class="number">2147483647</span></span><br></pre></td></tr></table></figure>







<h2 id="格式化标准输入输出"><a href="#格式化标准输入输出" class="headerlink" title="格式化标准输入输出"></a>格式化标准输入输出</h2><p>cout.setf(ios::left);   //左对齐 右对齐相同 </p>
<p>cout.width(3);    //宽度为3</p>
<h2 id="struct-初始化的一个小细节"><a href="#struct-初始化的一个小细节" class="headerlink" title="struct 初始化的一个小细节"></a>struct 初始化的一个小细节</h2><p>2019-11-2<br>1.今天写实验定义了一个这样的结构体，然后赋值： </p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/c1.png"></p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/c2.jpg"></p>
<p>debug了半天， 一个一个输出，终于找到错误的源头，原来是。。。。。。string和struct有冲突，什么原因呢？</p>
<p>经查，  malloc/free和new/delete </p>
<hr>
<ul>
<li>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。</li>
</ul>
<hr>
<ul>
<li>malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</li>
</ul>
<hr>
<p>所以解决的方案是： <code>TreeNode *temp = new TreeNode;</code></p>
<p>struct 是c里面的， 而string 类是 c++的，所以当在用c++的时候，写c语言就要考虑一下兼容问题。</p>
<h2 id="map的一个小细节"><a href="#map的一个小细节" class="headerlink" title="map的一个小细节"></a>map的一个小细节</h2><p>当创建一个map的时候，map是没有预分配内存的，当map一个没有的key的时候，就会默认创建这个对象，并且map的size加一！</p>
<p>看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; map1;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; map2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;out1-----------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;map1.size(): &quot;</span> &lt;&lt;  map1.size() &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="built_in">endl</span>  ; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;map2.size(): &quot;</span> &lt;&lt;  map2.size() &lt;&lt; <span class="string">&quot;\t&quot;</span>  ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n out2-----------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;map1[a]: &quot;</span> &lt;&lt;  map1[<span class="string">&quot;a&quot;</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;map2[a]: &quot;</span> &lt;&lt;  map2[<span class="string">&quot;a&quot;</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(map2[<span class="string">&quot;a&quot;</span>] == <span class="string">&quot;&quot;</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;empty string!!!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;map1.size(): &quot;</span> &lt;&lt;  map1.size() &lt;&lt; <span class="string">&quot;\t&quot;</span>  &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;map2.size(): &quot;</span> &lt;&lt;  map2.size() &lt;&lt; <span class="string">&quot;\t&quot;</span>  &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">out1-----------</span><br><span class="line">map1.size(): <span class="number">0</span></span><br><span class="line">map2.size(): <span class="number">0</span></span><br><span class="line"> out2-----------</span><br><span class="line">map1[a]: <span class="number">0</span></span><br><span class="line">map2[a]:</span><br><span class="line">empty <span class="built_in">string</span>!!!!</span><br><span class="line">map1.size(): <span class="number">1</span></span><br><span class="line">map2.size(): <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>当写一些需要用到map的代码的时候，就要注意了， 可能要花掉你半天的时间去debug这个小问题！！！</p>
<h2 id="操作系统的-堆和栈"><a href="#操作系统的-堆和栈" class="headerlink" title="操作系统的 堆和栈"></a>操作系统的 堆和栈</h2><p>学操作系统的时候，系统分配内存会分配 堆和栈</p>
<p>有一个我纠结了很久的问题，堆是一个二叉树实现的，而分配内存的堆是一个线性的地址，这两者有什么关联呢？</p>
<p>结论，数据结构没有学好！！  找个时间马一个heap</p>
<p>栈和堆都可以用二叉树实现， 堆栈就是栈， 堆插入一个元素二叉树放到最后面，如果删除了父节点，就要调整二叉树， 而栈只能在二叉树尾部删除和操作，没有其它操作，所以堆栈的含义：堆的后面多了一个限定词， 把范围限定的更小了！！ 但栈一般直接使用数组就好了，查看网上的说法：栈是一种受限制的堆。</p>
<p>查看数据结构的书本，发现这样一句话，我还画了出来 ： 学生们经常把堆的逻辑表示与利用基于数组的完全二叉树的物理实现相混淆。二者并非同义，虽然堆的一般实现方法是使用数组，但是从逻辑的角度来看，堆实际上是一种树结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; 全局初始化区</span><br><span class="line"><span class="keyword">char</span> *p1; 全局未初始化区</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> b; 栈</span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">&quot;abc&quot;</span>; 栈</span><br><span class="line"><span class="keyword">char</span> *p2; 栈</span><br><span class="line"><span class="keyword">char</span> *p3 = <span class="string">&quot;123456&quot;</span>; <span class="number">123456</span>\<span class="number">0</span>在常量区，p3在栈上。</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>； 全局（静态）初始化区</span><br><span class="line">p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">分配得来得<span class="number">10</span>和<span class="number">20</span>字节的区域就在堆区。</span><br><span class="line"><span class="built_in">strcpy</span>(p1, <span class="string">&quot;123456&quot;</span>); <span class="number">123456</span>\<span class="number">0</span>放在常量区，编译器可能会将它与p3所指向的</span><br><span class="line"><span class="string">&quot;123456&quot;</span>优化成一个</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> d = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> e = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;addr: %p\n&quot;</span>, &amp;a);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;addr: %p\n&quot;</span>, &amp;b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;addr: %p\n&quot;</span>, &amp;c);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;addr: %p\n&quot;</span>, &amp;d);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;addr: %p\n&quot;</span>, &amp;e);</span><br><span class="line">  <span class="keyword">int</span> *a1, *b1, *c1, *d1, *e1;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n-----------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  a1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  b1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  c1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  d1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  e1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;addr: %p\n&quot;</span>, &amp;a1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;addr: %p\n&quot;</span>, &amp;b1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;addr: %p\n&quot;</span>, &amp;c1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;addr: %p\n&quot;</span>, &amp;d1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;addr: %p\n&quot;</span>, &amp;e1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输出</span><br><span class="line">addr: <span class="number">0061F</span>F1C</span><br><span class="line">addr: <span class="number">0061F</span>F18</span><br><span class="line">addr: <span class="number">0061F</span>F14</span><br><span class="line">addr: <span class="number">0061F</span>F10</span><br><span class="line">addr: <span class="number">0061F</span>F0C</span><br><span class="line">-----------------</span><br><span class="line">addr: <span class="number">0061F</span>F08</span><br><span class="line">addr: <span class="number">0061F</span>F04</span><br><span class="line">addr: <span class="number">0061F</span>F00</span><br><span class="line">addr: <span class="number">0061F</span>EFC</span><br><span class="line">addr: <span class="number">0061F</span>EF8</span><br><span class="line">可以看出  heap 是 从减小的，  <span class="built_in">stack</span>是增大的</span><br></pre></td></tr></table></figure>







<p>for(int i = 0, siz = a.size(); i &lt; siz; i++)  //for循环可以有有四个值</p>
<p>​      有时也可以两个值       for( ; a &lt; b; ++a); </p>
<p>return cout &lt;&lt; “ “ &lt;&lt; endl,0;      //可以在return 后面输出</p>
<p>在for循环里 ++i 比 i++ 的效率高 <a class="link"   href="https://blog.csdn.net/FireflyNo1/article/details/82809624" >详情请点击<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>CXX</category>
      </categories>
      <tags>
        <tag>CXX</tag>
      </tags>
  </entry>
  <entry>
    <title>cplusplus</title>
    <url>/2017/11/21/notepad/cxx/cplusplus/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="c11的语言特性"><a href="#c11的语言特性" class="headerlink" title="c11的语言特性"></a>c11的语言特性</h2><p>.h 头文件可以不加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector.h&gt;</span></span></span><br></pre></td></tr></table></figure>



<h3 id="function-bind"><a href="#function-bind" class="headerlink" title="function, bind"></a>function, bind</h3><p>关于std::function 的用法：<br>其实就可以理解成函数指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存自由函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span> a)&gt; func;</span><br><span class="line">func = printA;</span><br><span class="line">func(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存lambda表达式</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; func_1 = []()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">func_1();</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    Foo(<span class="keyword">int</span> num) : num_(num) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_add</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; num_+i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> Foo&amp;, <span class="keyword">int</span>)&gt; f_add_display = &amp;Foo::print_add;</span><br><span class="line"><span class="function">Foo <span class="title">foo</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">f_add_display(foo, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">在实际使用中都用 <span class="keyword">auto</span> 关键字来代替<span class="built_in">std</span>::function… 这一长串了。</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun_3</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;z&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_2</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    a++; b++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">std</span>::bind(fun,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//表示绑定函数 fun 的第一，二，三个参数值为： 1 2 3</span></span><br><span class="line">    f1(); <span class="comment">//print:1  2  3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f2 = <span class="built_in">std</span>::bind(fun, placeholders::_1,placeholders::_2,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//表示绑定函数 fun 的第三个参数为 3，而fun 的第一，二个参数分别有调用 f2 的第一，二个参数指定</span></span><br><span class="line">    f2(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//print:1  2  3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f3 = <span class="built_in">std</span>::bind(fun,placeholders::_2,placeholders::_1,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//表示绑定函数 fun 的第三个参数为 3，而fun 的第一，二个参数分别有调用 f3 的第二，一个参数指定</span></span><br><span class="line">    <span class="comment">//注意： f2  和  f3 的区别。</span></span><br><span class="line">    f3(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//print:2  1  3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;    <span class="keyword">int</span> m = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f4 = <span class="built_in">std</span>::bind(fun_2, n,placeholders::_1);</span><br><span class="line">    f4(m); <span class="comment">//print:3  4</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//print:4  说明：bind对于不事先绑定的参数，通过std::placeholders传递的参数是通过引用传递的</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//print:2  说明：bind对于预先绑定的函数参数是通过值传递的</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">auto</span> f5 = <span class="built_in">std</span>::bind(&amp;A::fun_3, a,placeholders::_1,placeholders::_2);</span><br><span class="line">    f5(<span class="number">10</span>,<span class="number">20</span>);<span class="comment">//print:10 20</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; fc = </span><br><span class="line">        <span class="built_in">std</span>::bind(&amp;A::fun_3, a,<span class="built_in">std</span>::placeholders::_1,<span class="built_in">std</span>::placeholders::_2);</span><br><span class="line">    fc(<span class="number">10</span>,<span class="number">20</span>);<span class="comment">//print:10 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>auto_ptr、unique_ptr、shared_ptr和weak_ptr 这几个智能指针背后的设计思想: 将基本类型指针封装为类对象指针，并在析构函数里编写delete语句删除指针指向的内存空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">智能指针析构是会<span class="keyword">delete</span> 指针， 因此不要这样做</span><br><span class="line"><span class="function">tring <span class="title">vacation</span><span class="params">(<span class="string">&quot;I wandered lonely as a cloud.&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pvac</span><span class="params">(&amp;vacation)</span></span>;   <span class="comment">// No</span></span><br></pre></td></tr></table></figure>



<p>先来看下面的赋值语句:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt; <span class="built_in">string</span>&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;I reigned lonely as a cloud.”）;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">auto_ptr&lt;string&gt; vocation; </span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">vocaticn = ps;</span></span></span></span><br></pre></td></tr></table></figure>

<p>上述赋值语句将完成什么工作呢？如果ps和vocation是常规指针，则两个指针将指向同一个string对象。这是不能接受的，因为程序将试图删除同一个对象两次——一次是ps过期时，另一次是vocation过期时。要避免这种问题，方法有多种：</p>
<ul>
<li>定义陚值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。</li>
<li>建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和uniqiie_ptr 的策略，但unique_ptr的策略更严格。</li>
<li>创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。</li>
</ul>
<p>当然，同样的策略也适用于复制构造函数，每种方法都有其用途，但为何说要摒弃auto_ptr呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; films[<span class="number">5</span>] =</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Fowl Balls&quot;</span>)),</span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Duck Walks&quot;</span>)),</span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Chicken Runs&quot;</span>)),</span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Turkey Errors&quot;</span>)),</span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Goose Eggs&quot;</span>))</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; pwin;</span><br><span class="line"> pwin = films[<span class="number">2</span>]; </span><br><span class="line"> <span class="comment">// films[2] loses ownership. 将所有权从films[2]转让给pwin，</span></span><br><span class="line"> 此时films[<span class="number">2</span>]不再引用该字符串从而变成空指针</span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The nominees for best avian baseballl film are\n&quot;</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; *films[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The winner is &quot;</span> &lt;&lt; *pwin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cin</span>.get();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行下发现程序崩溃了，原因在上面注释已经说的很清楚，films[2]已经是空指针了，下面输出访问空指针当然会崩溃了。但这里如果把auto_ptr换成shared_ptr或unique_ptr后，程序就不会崩溃，原因如下：</p>
<ul>
<li><p>使用shared_ptr时运行正常，因为shared_ptr采用引用计数，pwin和films[2]都指向同一块内存，在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。</p>
</li>
<li><p>使用unique_ptr时编译出错，与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique_ptr时，程序不会等到运行阶段崩溃，而在编译器因下述代码行出现错误：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pwin;</span><br><span class="line">pwin = films[<span class="number">2</span>]; <span class="comment">// films[2] loses ownership.</span></span><br></pre></td></tr></table></figure>

<p>指导你发现潜在的内存错误。</p>
</li>
</ul>
<p>这就是为何要摒弃auto_ptr的原因，一句话总结就是：<strong>避免潜在的内存崩溃问题。</strong></p>
<ul>
<li>unique_ptr为何优于auto_ptr？</li>
</ul>
<p>可能大家认为前面的例子已经说明了unique_ptr为何优于auto_ptr，也就是安全问题，下面再叙述的清晰一点。<br>请看下面的语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_ptr&lt;string&gt; p1(new string (&quot;auto&quot;) ； &#x2F;&#x2F;#1</span><br><span class="line">auto_ptr&lt;string&gt; p2;                       &#x2F;&#x2F;#2</span><br><span class="line">p2 &#x3D; p1;                                   &#x2F;&#x2F;#3</span><br></pre></td></tr></table></figure>

<p>在语句#3中，p2接管string对象的所有权后，p1的所有权将被剥夺。前面说过，这是好事，可防止p1和p2的析构函数试图刪同—个对象；</p>
<p>但如果程序随后试图使用p1，这将是件坏事，因为p1不再指向有效的数据。</p>
<p>下面来看使用unique_ptr的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; p3 (new string (&quot;auto&quot;);   &#x2F;&#x2F;#4</span><br><span class="line">unique_ptr&lt;string&gt; p4；                       &#x2F;&#x2F;#5</span><br><span class="line">p4 &#x3D; p3;                                      &#x2F;&#x2F;#6</span><br></pre></td></tr></table></figure>

<p>编译器认为语句#6非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p>
<p><strong>但unique_ptr还有更聪明的地方。</strong><br>有时候，会将一个智能指针赋给另一个并不会留下危险的悬挂指针。假设有如下函数定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; demo(const char * s)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;string&gt; temp (new string (s))； </span><br><span class="line">    return temp；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并假设编写了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; ps;</span><br><span class="line">ps &#x3D; demo(&#39;Uniquely special&quot;)；</span><br></pre></td></tr></table></figure>

<p>demo()返回一个临时unique_ptr，然后ps接管了原本归返回的unique_ptr所有的对象，而返回时临时的 unique_ptr 被销毁，也就是说没有机会使用 unique_ptr 来访问无效的数据，换句话来说，这种赋值是不会出现任何问题的，即没有理由禁止这种赋值。实际上，编译器确实允许这种赋值，这正是unique_ptr更聪明的地方。</p>
<p><strong>总之，党程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做</strong>，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>

<p>其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。<strong>这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</strong></p>
<p>当然，您可能确实想执行类似于#1的操作，仅当以非智能的方式使用摒弃的智能指针时（如解除引用时），这种赋值才不安全。要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。下面是一个使用前述demo()函数的例子，该函数返回一个unique_ptr<string>对象：<br>使用move后，原来的指针仍转让所有权变成空指针，可以对其重新赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">ps2 = move(ps1);</span><br><span class="line">ps1 = demo(<span class="string">&quot;alexia&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如何选择智能指针？</li>
</ul>
<p>在掌握了这几种智能指针后，大家可能会想另一个问题：在实际应用中，应使用哪种智能指针呢？<br>下面给出几个使用指南。</p>
<p>（1）如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：</p>
<ul>
<li>有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；</li>
<li>两个对象包含都指向第三个对象的指针；</li>
<li>STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。</li>
</ul>
<p>（2）如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr。如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。可将unique_ptr存储到STL容器在那个，只要不调用将一个unique_ptr复制或赋给另一个算法（如sort()）。例如，可在程序中使用类似于下面的代码段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">make_int</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; &amp;p1)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; &gt; vp(size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vp.size(); i++)</span><br><span class="line">        vp[i] = make_int(rand() % <span class="number">1000</span>);              <span class="comment">// copy temporary unique_ptr</span></span><br><span class="line">    vp.push_back(make_int(rand() % <span class="number">1000</span>));     <span class="comment">// ok because arg is temporary</span></span><br><span class="line">    for_each(vp.begin(), vp.end(), show);           <span class="comment">// use for_each()</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中push_back调用没有问题，因为它返回一个临时unique_ptr，该unique_ptr被赋给vp中的一个unique_ptr。另外，如果按值而不是按引用给show()传递对象，for_each()将非法，因为这将导致使用一个来自vp的非临时unique_ptr初始化pi，而这是不允许的。前面说过，编译器将发现错误使用unique_ptr的企图。</p>
<p>在unique_ptr为右值时，可将其赋给shared_ptr，这与将一个unique_ptr赋给一个需要满足的条件相同。与前面一样，在下面的代码中，make_int()的返回类型为unique_ptr<int>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pup</span><span class="params">(make_int(rand() % <span class="number">1000</span>))</span></span>;   <span class="comment">// ok</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spp</span><span class="params">(pup)</span></span>;                       <span class="comment">// not allowed, pup as lvalue</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spr</span><span class="params">(make_int(rand() % <span class="number">1000</span>))</span></span>;   <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>模板shared_ptr包含一个显式构造函数，可用于将右值unique_ptr转换为shared_ptr。shared_ptr将接管原来归unique_ptr所有的对象。</p>
<p>在满足unique_ptr要求的条件时，也可使用auto_ptr，但unique_ptr是更好的选择。如果你的编译器没有unique_ptr，可考虑使用Boost库提供的scoped_ptr，它与unique_ptr类似。</p>
<h3 id="varidic-template"><a href="#varidic-template" class="headerlink" title="varidic template"></a>varidic template</h3><p>模版参数可变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  print(args...);<span class="comment">// 当参数为0 的时候， 调用上面的空函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="space-in-Template-Expression-nullptr，auto"><a href="#space-in-Template-Expression-nullptr，auto" class="headerlink" title="space in Template Expression, nullptr，auto"></a>space in Template Expression, nullptr，auto</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; &gt;  <span class="comment">// 旧版</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;&gt;	<span class="comment">// c11新版</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>*)</span></span>; </span><br><span class="line">foo(<span class="literal">NULL</span>) <span class="comment">// foo1? foo2 ? 旧版有冲突</span></span><br><span class="line">(<span class="literal">NULL</span> == <span class="number">0</span>) -&gt; <span class="literal">true</span></span><br><span class="line"><span class="literal">nullptr</span>(<span class="keyword">void</span> *) <span class="comment">//c11 解决方案</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">auto</span> i = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Uniform-Initiazation"><a href="#Uniform-Initiazation" class="headerlink" title="Uniform Initiazation"></a>Uniform Initiazation</h3><p>初始化统一可以用大括号，在变量的后面直接用!!!  (强)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> values[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str&#123;<span class="string">&quot;df&quot;</span>,<span class="string">&quot;df&quot;</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> p&#123;&#125;;  <span class="comment">//0</span></span><br><span class="line"><span class="keyword">int</span> *p;   <span class="comment">//no</span></span><br><span class="line"><span class="keyword">int</span> *q&#123;&#125;;	  <span class="comment">//nullptr</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span></span>&#123;</span><br><span class="line">    for_each(vals.begin(), vals.end(), print);</span><br><span class="line">&#125;</span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span>&#123;</span></span><br><span class="line">    P(<span class="keyword">int</span> a)&#123;&#125;</span><br><span class="line">    P(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; intlist)&#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; il)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">p</span><span class="params">(<span class="number">3</span>)</span></span>; 		<span class="comment">// 第一个构造函数</span></span><br><span class="line">P p&#123;<span class="number">3</span>&#125;;			<span class="comment">// 第二个</span></span><br><span class="line">P P&#123;<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">P P=&#123;<span class="number">3</span>,<span class="number">4</span>&#125;;		<span class="comment">// 第三个</span></span><br><span class="line"></span><br><span class="line">min(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">4</span>&#125;)</span><br><span class="line">max(&#123;<span class="built_in">string</span>(<span class="string">&quot;dsf&quot;</span>),<span class="built_in">string</span>(<span class="string">&quot;fsda&quot;</span>)&#125;); <span class="comment">// 强</span></span><br></pre></td></tr></table></figure>



<h3 id="explict-for-actors-taking-more-than-one-argument"><a href="#explict-for-actors-taking-more-than-one-argument" class="headerlink" title="explict for actors taking more than one argument"></a>explict for actors taking more than one argument</h3> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line">	<span class="function">explict <span class="title">C</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">C c = <span class="number">1</span>; <span class="comment">//error  1 -&gt; C not explict</span></span><br></pre></td></tr></table></figure>



<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;      <span class="number">1</span>,      <span class="number">2</span>,      <span class="number">3</span>  &#125;;</span><br><span class="line">  <span class="comment">//* -----------------------------------</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;auto &amp;&amp; foreach\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : a) i = <span class="number">2</span>;  <span class="comment">//取地址</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : a) &#123;        <span class="comment">//取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//! 尽量用 取值， 不然有拷贝会慢一点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  template&lt;class InputIterator, class Function&gt;</span></span><br><span class="line"><span class="comment">  Function for_each(InputIterator first, InputIterator last, Function fn)&#123;</span></span><br><span class="line"><span class="comment">      while (first!=last) &#123;</span></span><br><span class="line"><span class="comment">        fn (*first);</span></span><br><span class="line"><span class="comment">        ++first;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      return fn;      // or, since C++11: return move(fn);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">foreach</span> <span class="params">(a, a + <span class="number">5</span>)</span></span>;</span><br><span class="line">  for_each(foreach.begin(), foreach.end(), [](<span class="keyword">int</span> a) &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Sum</span> &#123;</span>  <span class="comment">//仿函数</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; sum += val; &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>



<h3 id="defalut-delete"><a href="#defalut-delete" class="headerlink" title="=defalut, =delete"></a>=defalut, =delete</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    B(<span class="keyword">int</span> a) : a(a)&#123;&#125; <span class="comment">// 写了后没有构造函数</span></span><br><span class="line">    B(<span class="keyword">const</span> B&amp;) = <span class="keyword">delete</span>; <span class="comment">//不给拷贝构造</span></span><br><span class="line">    B&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> B&amp;) = <span class="keyword">delete</span>; <span class="comment">//不给拷贝构造</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    	<span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以 放到private ，去friend中调用</span></span><br></pre></td></tr></table></figure>



<h3 id="alias-template"><a href="#alias-template" class="headerlink" title="alias template"></a>alias template</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> vec = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint <span class="comment">// 无法带参数！！！！！</span></span><br><span class="line">    </span><br><span class="line">vec&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">vint arr;</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = []()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">decltype</span>(t)&gt; v(t);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[]&#123; cou &lt;&lt;<span class="string">&quot;heloo&quot;</span>;&#125; 	<span class="comment">//函数</span></span><br><span class="line">[]&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;world&quot;</span>;&#125;();	<span class="comment">//</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">auto</span> q = [x, &amp;y]&#123;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><h3 id="简单的定义"><a href="#简单的定义" class="headerlink" title="简单的定义"></a>简单的定义</h3><p><em>左值 (lvalue, locator value)</em> 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</p>
<p><em>右值 (rvalue)</em> 则使用排除法来定义。一个表达式不是 <em>左值</em> 就是 <em>右值</em> 。 那么，右值是一个 <em>不</em> 表示内存中某个可识别位置的对象的表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> globalvar = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> globalvar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    foo() = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>将数组封装成模版类， 没有构造函数和析构函数， 模拟出数组！</p>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>使用模版继承实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> tu = make_tuple(<span class="number">22</span>,<span class="number">44</span>,<span class="string">&quot;dsjfk&quot;</span>);</span><br><span class="line">tuple_size&lt;&gt;::value</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Wolrd In Java</title>
    <url>/2018/10/28/notepad/java/Wolrd_In_Java/</url>
    <content><![CDATA[<h1 id="深入理解Java"><a href="#深入理解Java" class="headerlink" title="深入理解Java"></a>深入理解Java</h1><p>有空就记录一点小内容！！</p>
<h2 id="Java接口与抽象类的区别"><a href="#Java接口与抽象类的区别" class="headerlink" title="Java接口与抽象类的区别"></a>Java接口与抽象类的区别</h2><p>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p>
<ol>
<li>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li>
<li>类可以实现很多个接口，但是只能继承一个抽象类</li>
<li>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li>
<li>抽象类可以在不提供接口方法实现的情况下实现接口。</li>
<li>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</li>
<li>Java接口中的成员函数默认是<strong>public</strong>的。抽象类的成员函数可以是private，protected或者是public。</li>
<li><strong>接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化</strong>。</li>
<li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li>
</ol>
<p>一句话总结：</p>
<a id="more"></a>
<p><strong>从设计层面来说，抽象是对类的抽象，是一种<font color="red">模板设计</font>，接口是行为的抽象，是一种行为的规范</strong></p>
<h2 id="浅克隆和深克隆"><a href="#浅克隆和深克隆" class="headerlink" title="浅克隆和深克隆"></a><strong>浅克隆和深克隆</strong></h2><p>​     Java语言中，数据类型分为值类型（基本数据类型）和引用类型.</p>
<ul>
<li><p><strong>值类型</strong>包括int、double、byte、boolean、char等简单数据类型，</p>
</li>
<li><p><strong>引用类型</strong>包括类、接口、数组等复杂类型。</p>
</li>
</ul>
<p>浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制，下面将对两者进行详细介绍。 </p>
<p><strong>浅克隆</strong>(ShallowClone)</p>
<p>  在浅克隆中，如果原型对象的成员变量是<strong>值类型</strong>，将复制一份给克隆对象；如果原型对象的成员变量是<strong>引用类</strong>型，则将<strong>引用对象的地址</strong>复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p>
<p><strong>深克隆</strong>(DeepClone)</p>
<p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2018/05/27/notepad/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><center>JVM</center></h1><p>i do not love java at all!</p>
<h3 id="内存机制"><a href="#内存机制" class="headerlink" title="内存机制"></a>内存机制</h3><h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><ul>
<li>程序计数器</li>
</ul>
<p>线程私有，执行native方法时为空！ 不会OutOfMemoryError！</p>
<ul>
<li>java虚拟机栈</li>
</ul>
<p>线程私有，存放局部变量表，动态连接，返回信息等，每一个方法对应一个栈帧!   </p>
<p>OutOfMemoryError （扩展时无法申请）    OutOfMemoryError(超过允许最大深度)</p>
<ul>
<li>本地方法栈</li>
</ul>
<p>与虚拟机栈类似， 只是执行本地方法的栈！</p>
<ul>
<li>java堆</li>
</ul>
<p><strong>唯一目的</strong>： 存放对象实例； 几乎所有的对象实例都在这里分配内存， gc的主要区域！</p>
<ul>
<li>方法区</li>
</ul>
<p>与堆一样，放<strong>共享数据</strong>， 加载的类信息（存放类的版本，信息，方法，接口等），常量， 静态变量等</p>
<ul>
<li>运行时常量池</li>
</ul>
<p>属于方法区的一部分， 出了上述的， 还需存放<strong>编译时</strong>生成的字面量和符号引用</p>
<ul>
<li>直接内存</li>
</ul>
<p>不在堆， 而是直接使用物理内存（使用unsafe 类分配）</p>
<h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ul>
<li>检查是否被加载</li>
<li>分配内存</li>
<li>初始化0值</li>
<li>设置对象的信息（如是哪个类的实例等等）</li>
<li>调用 用户或者默认的&lt; init &gt; 方法</li>
</ul>
<h4 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h4><ul>
<li>通过句柄，将实例数据独立出来， （实例数据比类型数据多了初始化信息等）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200221224645.png"></p>
<ul>
<li>直接指针访问</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200221224710.png"></p>
<p>这两种对象访问方式个有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><ul>
<li>java堆溢出(无限创建变量)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Firefly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/22 9:20</span></span><br><span class="line"><span class="comment"> * VM args: -Xms20m -Xmx20m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testheap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;test&gt; tests = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            tests.add(<span class="keyword">new</span> test());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span><br></pre></td></tr></table></figure>

<ul>
<li>栈溢出(递归调用函数)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teststack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        len++;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Teststack t = <span class="keyword">new</span> Teststack();</span><br><span class="line">        t.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br></pre></td></tr></table></figure>

<p>栈的内存溢出可以通过建立线程设置得到！</p>
<ul>
<li>常量池溢出</li>
</ul>
<p>测试不出。。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><h4 id="class文件的数据结构"><a href="#class文件的数据结构" class="headerlink" title="class文件的数据结构"></a>class文件的数据结构</h4><p>javac 生成的是java字节码， 相当于编译原理的前段， javac 没有对代码进行优化， 字节码相当于是一种中间数据结构， 其它语言也可以通过前段编译器编译出字节码， 优化在jvm。</p>
<p>首先是一段代码：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200211101432.png"></p>
<p>javac 编译后生成如下的字节码的一部分：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20200211103302553.png"></p>
<ul>
<li>魔数</li>
</ul>
<p>前4个字节 CAFABABE 表示魔数， 大多数文件都有魔数 ， 很多java书都是一杯咖啡！</p>
<ul>
<li><p>接下来 4 个字节为 版本号， 我用1.8 编译的 所以<code>00 00 00 37</code> 表示8，</p>
</li>
<li><p>接下来是 常量池</p>
</li>
</ul>
<p>由于java使用了虚拟机， 因此没有连接这一步骤， 在class 加载的时候动态连接，只需要保存名字。</p>
<p>图中<code> 00 21</code> 表示 常量池的长度， 表示接下来21 个字节长度为常量池</p>
<p>下图是常量池的数据类型：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200211104155.png"></p>
<p>0A 查表表示 method， 由表得知下一字节为索引， 索引类型 0， 即字符串， 然后得到一个utf 常量值！</p>
<p>javap 可以自动帮我们转换， 因此， java是可以反编译的！</p>
<p>javap -verbose TestClass.class  java字节码转换成了人类看的懂得形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Classfile &#x2F;D:&#x2F;c&#x2F;TestClass.class</span><br><span class="line">  Last modified 2020年2月11日; size 474 bytes</span><br><span class="line">  MD5 checksum 2924e1bfe2ffb03842152f3c1e83460e</span><br><span class="line">  Compiled from &quot;TestClass.java&quot;</span><br><span class="line">public class jvm.TestClass</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 55</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #5                          &#x2F;&#x2F; jvm&#x2F;TestClass   </span><br><span class="line">  super_class: #6                         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">  interfaces: 0, fields: 1, methods: 3, attributes: 1        </span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #6.#19         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #5.#20         &#x2F;&#x2F; jvm&#x2F;TestClass.a:I</span><br><span class="line">   #3 &#x3D; Fieldref           #21.#22        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #4 &#x3D; Methodref          #23.#24        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">   #5 &#x3D; Class              #25            &#x2F;&#x2F; jvm&#x2F;TestClass</span><br><span class="line">   #6 &#x3D; Class              #26            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #7 &#x3D; Utf8               a</span><br><span class="line">   #8 &#x3D; Utf8               I</span><br><span class="line">   #9 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">  #10 &#x3D; Utf8               ()V</span><br><span class="line">  #11 &#x3D; Utf8               Code</span><br><span class="line">  #12 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #13 &#x3D; Utf8               getA</span><br><span class="line">  #14 &#x3D; Utf8               ()I</span><br><span class="line">  #15 &#x3D; Utf8               main</span><br><span class="line">  #16 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #17 &#x3D; Utf8               SourceFile</span><br><span class="line">  #18 &#x3D; Utf8               TestClass.java</span><br><span class="line">  #19 &#x3D; NameAndType        #9:#10         &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #20 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; a:I</span><br><span class="line">  #21 &#x3D; Class              #27            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #22 &#x3D; NameAndType        #28:#29        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #23 &#x3D; Class              #30            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #24 &#x3D; NameAndType        #31:#32        &#x2F;&#x2F; println:(I)V</span><br><span class="line">  #25 &#x3D; Utf8               jvm&#x2F;TestClass</span><br><span class="line">  #26 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #27 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #28 &#x3D; Utf8               out</span><br><span class="line">  #29 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #30 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #31 &#x3D; Utf8               println</span><br><span class="line">  #32 &#x3D; Utf8               (I)V</span><br></pre></td></tr></table></figure>



<ul>
<li>访问标志</li>
</ul>
<p>常量池结束后就是 访问标志了，</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200211105542.png"></p>
<p>vscode 插件 hex for dump 方便就找到了常量池的最后一个符号， 然后在往后两个字节  .! 的utf编码值00 21 ,后面的为索引索引常量的名字，得到类名， 父类名， 方法属性的访问权限的的等等，这一部分就不读了， 没有必要记住， 知道字节码是存放什么就行了。</p>
<h4 id="jvm字节码指令简介"><a href="#jvm字节码指令简介" class="headerlink" title="jvm字节码指令简介"></a>jvm字节码指令简介</h4><p>上面部分了解了class文件的数据结构， 在编译原理上可以通过 词法分析， 语法分析， 语义分析生成得到。</p>
<p>jvm的指令只有一个字节，所以查看返汇编的代码， 很多操作都是只有一个操作码， 没有操作数，jvm是面向操作数栈而不是寄存器的架构， 操作数在栈里！ </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    自动计算PC寄存器加<span class="number">1</span>；</span><br><span class="line">    根据PC寄存器的指示位置， 从字节码流中取出操作码</span><br><span class="line">    <span class="keyword">if</span>(字节码存在操作数)  从字节码中取出操作数</span><br><span class="line">     执行操作码所定义的操作</span><br><span class="line">&#125; <span class="keyword">while</span>( 字节码长度 &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>加载存储指令</li>
</ul>
<p>load， store  ，  push  对应的数值类型有  i a l等</p>
<ul>
<li>运算指令</li>
</ul>
<p>add， sub， mul， div， rem， neg， shl， or， and， xor， inc， cmpg</p>
<p>注意的是：</p>
<ol>
<li>只有除数为零的时候才会抛出ArithmeticException 异常，其它不应该抛出异常</li>
<li>浮点数舍入选择最近的数字， 浮点数到整形选择 向下舍入</li>
<li>处理浮点数不会报错</li>
</ol>
<ul>
<li><p>对象的创建和访问</p>
<p>创建对象： new    创建数组： newarray</p>
</li>
<li><p>异常处理指令</p>
</li>
</ul>
<p>通过异常表来跳转</p>
<ul>
<li>同步指令， 通过 管程实现  monitorEnter monitorExit</li>
</ul>
<h4 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h4><p>java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>
<p>类的生命周期分为7个阶段 加载 - 验证 - 准备 - 解析 - 初始化 - 使用 - 卸载</p>
<p>只有5种情况会立即初始化：</p>
<ol>
<li>new， getstatic， putstatic， invokestatic</li>
<li>使用 reflect 包进行反射调用</li>
<li>初始化时父类还没初始化</li>
<li>需要一个main</li>
<li>methodHandle</li>
</ol>
<p>例子：</p>
<p>1)被动引用才会初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SUperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> value <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="title">enxtends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> class <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码父类被引用了， 所以运行后父类会初始化</p>
<ol start="2">
<li>数组对象的初始化不会初始化对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    SuperClass sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码不会调用  SuperCLass的构造函数， 会创建一个内置的数组对象类， 并封装了越界检查，在指令上。</p>
<p>3） 常量的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> calss  ConstClass&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码不会调用构造函数！而是放到常量池</p>
<h4 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h4><ul>
<li>加载</li>
</ul>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所表示的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的Class 对象， 作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>字节码的获取可以来自任何地方</p>
<ul>
<li>验证</li>
</ul>
<p>相当于编译原理的 语义分析， 检查类型时候正确等等</p>
<p>如果自己的第三方包已经反复测试没有问题， 可以使用 -Xverify:none关闭验证，加快加载速度</p>
<ul>
<li>准备</li>
</ul>
<p>为类变量分配内存并且设置类变量的阶段。</p>
<p>public static int value = 123， 这个变量会设置初始值0，到方法区。</p>
<p>而类的<strong>实例变量</strong>，会随对象初始化在堆中， <code>pirvate int value</code> </p>
<p>还有一个特殊情况，  <code>public static final int value = 123</code>，加了final的变量会初始化为123</p>
<ul>
<li>解析   v</li>
</ul>
<p>将常量池的符号引用替换为直接的内存引用， 相当于java自动帮程序员转换指针， 因此程序员获取不到指针。</p>
<p>直接引用： 一个指向目标的指针， 相对偏移量或是一个能间接定位到目标的句柄</p>
<p>符号引用 ：一组符号描述目标</p>
<p>这一部分还涉及到语义分析的过程， 当一个变量重复定义的情况等等。</p>
<ul>
<li>初始化</li>
</ul>
<p>开始执行java程序（字节码）</p>
<p>调用  &lt; cinit &gt;() 方法：</p>
<ol>
<li>收集 static{}, 此时只可以赋值， 不可以访问， 访问会报 非法向前引用</li>
<li>不用调用父类的构造函数， jvm确保已经初始化</li>
<li>后面的值会覆盖前面的值</li>
<li>如果没有静态语句块， 不会生成这个方法</li>
<li>jvm 默认保证这个方法是线程安全的</li>
</ol>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>类加载的获取二进制文件的方法放到了类加载器中实现！</p>
<p>比较两个类是否相等，只有在这两个类是由==同一个类加载器==加载的前提下才有意义！</p>
<h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200213105357.png"></p>
<ul>
<li><p>启动类在  <java_home>\lib 目录下</p>
</li>
<li><p>扩展类在 <java_home>\lib\ext 目录下</p>
</li>
<li><p>应用类用户目录下</p>
</li>
</ul>
<p>工作过程： 如果一个类加载器收到了类加载的请求， 它首先不会自己去尝试加载这个类，而是把这个请求<strong>委派</strong>给父加载器加载， 当父加载器不能加载这个类的时候才自己加载</p>
<p>作用： 使得类的加载有优先层次关系， 会首先加载内置的类， 如果重名就加载不了！</p>
<h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><p>虚拟机为不同的物理机提供统一的外观！</p>
<h4 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h4><ul>
<li>局部变量表</li>
</ul>
<p>用于存放方法参数 和 局部变量， 如果局部变量是一个类， 则存储它的引用。</p>
<ul>
<li>操作数</li>
</ul>
<p>后入先出的栈（广义上的栈）， jvm执行指令时， 操作数就在栈里， 所谓基于栈的执行引擎的栈， 就是这里的栈。</p>
<ul>
<li>动态连接</li>
</ul>
<p>指向运行时常量池中改栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。</p>
<ul>
<li>方法返回地址</li>
</ul>
<p>存放返回的地址， 异常不会使用</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>在解析的时候， 满足条件的有： 编译期可知， 运行期不可变， 有静态方法和私有方法两种！叫做解析调用</p>
<p>分派（dispatch）调用可以是静态的也可以是动态的</p>
<ul>
<li>静态分派（Method overload Resotion） （方法重载）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">TestStaticDispatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>  <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sayHello</span><span class="params">(Human human)</span></span>&#123;System.out.println(<span class="string">&quot;hey guy&quot;</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sayHello</span><span class="params">(Man human)</span></span>&#123;System.out.println(<span class="string">&quot;hey man&quot;</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sayHello</span><span class="params">(Woman human)</span></span>&#123;System.out.println(<span class="string">&quot;hey human&quot;</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Man();</span><br><span class="line">        <span class="keyword">new</span> TestStaticDispatcher().sayHello(man);</span><br><span class="line">        <span class="keyword">new</span> TestStaticDispatcher().sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实际类型变化</span></span><br><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">man = <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">//静态类型变化</span></span><br><span class="line">sr,sayHello((Man)man);<span class="comment">// 确定的</span></span><br></pre></td></tr></table></figure>



<ul>
<li>动态分派 （重写）</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习笔记</title>
    <url>/2019/05/01/notepad/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><ul>
<li>TCP: 提供可靠的数据传输服务</li>
<li>UDP： 不能保证数据的可靠传输</li>
</ul>
<h4 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h4><p>运输层负责将数据包发给 进程， 其中要到多路复用和多路分解</p>
<p>TCP： 使用四元组区分（源IP地址，源端口号， 目的IP地址， 目的端口号） 决定一个连接</p>
<p>UDP： 不是面向连接的，多个主机可以和一个主机使用连接， 只是对网络层协议增加了一点多路复用和分解服务而已</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP 的报文段结构只有  源端口号， 目的端口号， 长度，校验和（16）位，应用数据， </p>
<p>checksum：  按照一定距离拆分求和</p>
<p>为什么要在 UDP 设置checksum 呢？  原因是由于不能保证源与目的之间的所有链路都提供差错检测！ 链路层的协议可能不一样！ 在路由器的内存中也可能出错， 链路层只能保证在链路上不出错！</p>
<h4 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h4><p>使用有限状态机构建可靠的数据传输方式</p>
<p>使用流水线传输， 解决流水线差错恢复的基本方法是： 回退 N 步 和 选择重传</p>
<h5 id="回退N步（也称为滑动窗口协议）"><a href="#回退N步（也称为滑动窗口协议）" class="headerlink" title="回退N步（也称为滑动窗口协议）"></a>回退N步（也称为滑动窗口协议）</h5><p>基序号 +  下一个序号 +  窗口长度</p>
<h5 id="选择重传（SR）"><a href="#选择重传（SR）" class="headerlink" title="选择重传（SR）"></a>选择重传（SR）</h5><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>差错检测， 重传， 累计确认，定时器以及序号和确认号的首部字段。</p>
<p>TCP 提供全双工的服务</p>
<p>MSS + 40 Bit = MTU （链路层可以装下的数据长度）</p>
<p>当收到3 个 ACK的时候快速重传，ps： 为什么不是两个？</p>
<h5 id="连接管理："><a href="#连接管理：" class="headerlink" title="连接管理："></a>连接管理：</h5><p>三次握手， 四次挥手</p>
<p>拥塞控制</p>
<h5 id="TCP-拥塞控制算法"><a href="#TCP-拥塞控制算法" class="headerlink" title="TCP 拥塞控制算法"></a>TCP 拥塞控制算法</h5><p>1、 慢启动</p>
<p>2、 拥塞避免</p>
<p>3、 快速恢复</p>
<p>总结： </p>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。 </li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </li>
<li>TCP 的接收端会丢弃重复的数据。 </li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送，通过告知窗口。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </li>
</ol>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>路由器的主要作用便是将数据报从入链路转发到出链路</p>
<p>主要有三个组件</p>
<ul>
<li>第一个组件 IP 协议</li>
<li>第二个组件 路由选择算法</li>
<li>第三个组件是差错</li>
</ul>
<h5 id="转发和路由选择"><a href="#转发和路由选择" class="headerlink" title="转发和路由选择"></a>转发和路由选择</h5><ul>
<li>转发</li>
</ul>
<p>当一个分组到达路由器的一条输入链路时， 路由器必须将该分组移动到适当的输出链路</p>
<ul>
<li>路由选择</li>
</ul>
<p>当分组从发送方流向接收方时， 网络层必须决定这些分组所采用的路由或路径</p>
<p>网络层提供的是尽力而为的服务， why？</p>
<h4 id="虚电路和数据报网络"><a href="#虚电路和数据报网络" class="headerlink" title="虚电路和数据报网络"></a>虚电路和数据报网络</h4><ul>
<li>虚电路网络</li>
</ul>
<p>仅在网络层提供连接服务的网络，每一台路由器都要参与虚电路的建立，并且知道所有的虚电路， 路由器要分配 vc 号</p>
<ul>
<li>数据报网络</li>
</ul>
<p>仅在网络层提供无连接服务的网络</p>
<p>每隔 1- 5 分钟更新一次转发表</p>
<h4 id="路由器的工作原理"><a href="#路由器的工作原理" class="headerlink" title="路由器的工作原理"></a>路由器的工作原理</h4><ul>
<li>接受帧    </li>
<li>放入队列（缓存管理）    </li>
<li>交换<ul>
<li>经过内存交换（多个线路分速率）</li>
<li>经总线交换</li>
<li>经互联网交换</li>
</ul>
</li>
</ul>
<h4 id="因特网中的转发和编址"><a href="#因特网中的转发和编址" class="headerlink" title="因特网中的转发和编址"></a>因特网中的转发和编址</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/fuck.png"></p>
<p>IP 数据分片， 当链路层提供的 MTU 大小比 IP 数据报小时， IP 数据包就要进行分片！</p>
<h5 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h5><h6 id="无类别域间路由选择-CIDR"><a href="#无类别域间路由选择-CIDR" class="headerlink" title="无类别域间路由选择(CIDR)"></a>无类别域间路由选择(CIDR)</h6><p>也叫 地址聚合，路由聚合，路由摘要</p>
<h6 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h6><p>DHCP 是 4 个步骤的过程</p>
<ul>
<li>DHCP 服务器发现， 通过链路层广播</li>
<li>DHCP 服务器提供，也是广播，因为可能有多个</li>
<li>DHCP 请求一个 IP</li>
<li>DHCP ACK 一个报文</li>
</ul>
<h6 id="网络地址转换-（NAT）"><a href="#网络地址转换-（NAT）" class="headerlink" title="网络地址转换 （NAT）"></a>网络地址转换 （NAT）</h6><p>对外界就如同具有单一 IP 地址的单一设备， 使用端口来区分主机</p>
<h5 id="因特网控制报文协议（ICMP）"><a href="#因特网控制报文协议（ICMP）" class="headerlink" title="因特网控制报文协议（ICMP）"></a>因特网控制报文协议（ICMP）</h5><p>ICMP 可以认为是 IP 的一部分， 但是从体系结构上讲它是位于 IP 之上的，因为 ICMP 报文是承载在 <strong>IP 分组中的</strong> </p>
<p>ping 程序是直接在 OS 支持的服务，不是一个进程</p>
<p>tracetoute 是用  ICMP 报文来实现的， 每次发送一个 TTL i 的 <strong>IP 数据</strong>报</p>
<h4 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h4><h5 id="全局式路由选择算法"><a href="#全局式路由选择算法" class="headerlink" title="全局式路由选择算法"></a>全局式路由选择算法</h5><p>链路状态算法（Link State， LS），dijkstra算法</p>
<p>OSPF（广播算法实现）</p>
<h5 id="分散式路由选择算法"><a href="#分散式路由选择算法" class="headerlink" title="分散式路由选择算法"></a>分散式路由选择算法</h5><p>距离向量（Distance-Vector， DV），bellman-ford</p>
<p>分布式的，不需要知道全局的信息， 迭代，异步</p>
<p>RIP， BGP，ARP</p>
<p>1、 链路费用给比啦与链路故障</p>
<p>使用了由之前计算出的距离，需要迭代很慢。</p>
<p>2、 增加毒性逆转</p>
<p>无法解决多节点的无穷计数问题</p>
<h5 id="层次路由选择"><a href="#层次路由选择" class="headerlink" title="层次路由选择"></a>层次路由选择</h5><p>当规模大的时候，路由器组织 自治系统（AS）来解决， 相同的AS 中选择相同的路由选择算法，多个AS 之间发送数据的路由器为<strong>网关路由器</strong></p>
<h4 id="因特网中的路由选择"><a href="#因特网中的路由选择" class="headerlink" title="因特网中的路由选择"></a>因特网中的路由选择</h4><h5 id="自治系统内部的路由选择："><a href="#自治系统内部的路由选择：" class="headerlink" title="自治系统内部的路由选择："></a>自治系统内部的路由选择：</h5><p>AS 内部路由选择协议又称为<strong>内部网关协议</strong></p>
<h6 id="路由选择信息协议：-RIP（Routing-Infomation-Protocal）"><a href="#路由选择信息协议：-RIP（Routing-Infomation-Protocal）" class="headerlink" title="路由选择信息协议： RIP（Routing Infomation Protocal）"></a>路由选择信息协议： RIP（Routing Infomation Protocal）</h6><p>距离向量协议， 路由选择更新信息在邻居之间通过 RIP 响应报文来交换，大约 30 秒相互交换一次， 维护一张路由选择表的RIP 表。</p>
<p><font color = "red"> important: </font> RIP 使用一个位于<strong>网络层协议（IP）</strong>之上的<strong>运输层协议（UDP）</strong>来实现<strong>网络层功能</strong>！</p>
<h6 id="开放最短路优先：OSPF-（Open-SHortest-Path-First）"><a href="#开放最短路优先：OSPF-（Open-SHortest-Path-First）" class="headerlink" title="开放最短路优先：OSPF （Open SHortest Path First）"></a>开放最短路优先：OSPF （Open SHortest Path First）</h6><p>使用洪泛链路状态信息和 dijkstra算法</p>
<h5 id="自治系统间的路由选择："><a href="#自治系统间的路由选择：" class="headerlink" title="自治系统间的路由选择："></a>自治系统间的路由选择：</h5><h5 id="边界网关协议：Broder-Gateway-Protocol（BGP）"><a href="#边界网关协议：Broder-Gateway-Protocol（BGP）" class="headerlink" title="边界网关协议：Broder Gateway Protocol（BGP）"></a>边界网关协议：Broder Gateway Protocol（BGP）</h5><ul>
<li>从相邻AS 处获得子网可达信息</li>
<li>向本 AS 内部的所有路由器传播这些可达性信息</li>
<li>基于可达性信息和 AS 策略， 决定达到子网的“好”路由</li>
</ul>
<p>使用的是 TCP 连接， 目的地是CDIR 前缀， 每一个前缀表示一个子网或者一个子网集合</p>
<h4 id="广播和多播路由选择"><a href="#广播和多播路由选择" class="headerlink" title="广播和多播路由选择"></a>广播和多播路由选择</h4><h5 id="广播路由选择"><a href="#广播路由选择" class="headerlink" title="广播路由选择"></a>广播路由选择</h5><p>网络层提供了从一种源节点到网络中的其他所有节点交付分组的服务</p>
<h6 id="无控制洪泛"><a href="#无控制洪泛" class="headerlink" title="无控制洪泛"></a>无控制洪泛</h6><p>向相邻的节点发送副本</p>
<h6 id="受控洪泛"><a href="#受控洪泛" class="headerlink" title="受控洪泛"></a>受控洪泛</h6><p>使用序号控制洪泛</p>
<h6 id="生成树广播"><a href="#生成树广播" class="headerlink" title="生成树广播"></a>生成树广播</h6><p>最小生成树的方向上去广播</p>
<h6 id="实践中的广播算法"><a href="#实践中的广播算法" class="headerlink" title="实践中的广播算法"></a>实践中的广播算法</h6><p>广播协议被用于应用层和网络层</p>
<ul>
<li><p>TCP 使用 TTL 跳数 限制</p>
</li>
<li><p>OSPF 路由选择算法和中间系统到中间系统路由选择算法中，使用了一种序号控制洪泛来广播链路状态通告</p>
</li>
</ul>
<h5 id="多播路由选择"><a href="#多播路由选择" class="headerlink" title="多播路由选择"></a>多播路由选择</h5><p>使单个源节点能够向其他网络节点的一个子集发送分组的副本</p>
<p>使用间接地址来编址，用一个标识来表示一组接收方</p>
<h6 id="因特网组管理协议（IGMP）"><a href="#因特网组管理协议（IGMP）" class="headerlink" title="因特网组管理协议（IGMP）"></a>因特网组管理协议（IGMP）</h6><p>使用的生成树多播，这一部分略略略</p>
<hr>
<h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>链路层的主体部分是在网络适配器中实现的， 网络适配器有时也称为网络接口卡（网卡 Network Interface Card， NIC）。</p>
<p>一句话概述其工作过程就是将网络层的分组数据包组织起来，通过物理层以比特流的形式发送。</p>
<h4 id="差错检测的3种技术"><a href="#差错检测的3种技术" class="headerlink" title="差错检测的3种技术"></a>差错检测的3种技术</h4><h5 id="1、-奇偶校验（描述原理）"><a href="#1、-奇偶校验（描述原理）" class="headerlink" title="1、 奇偶校验（描述原理）"></a>1、 奇偶校验（描述原理）</h5><p>包含一位附加比特位， 所有的 1 的比特的数量为<strong>偶数</strong>。</p>
<h5 id="2、检验和-checksum（传输层）"><a href="#2、检验和-checksum（传输层）" class="headerlink" title="2、检验和 checksum（传输层）"></a>2、检验和 checksum（传输层）</h5><p>一个d 比特的数据看做一个k比特整数的序列处理，将这些整数加起来的和作为检测差错比特。</p>
<p><font color='gree'> 传输层的检测方法？</font></p>
<h5 id="3、循环冗余检测-CRC（用于链路层）"><a href="#3、循环冗余检测-CRC（用于链路层）" class="headerlink" title="3、循环冗余检测 CRC（用于链路层）"></a>3、循环冗余检测 CRC（用于链路层）</h5><blockquote>
<p>D ·  2 ^r^  XOR R = nG</p>
</blockquote>
<p>数据段： D， 冗余检测段： R， r位的R，</p>
<blockquote>
<p> R = remainder( D · 2^r^ / G ) </p>
</blockquote>
<p>数据段 D 一直除以 G 就可以得到 2^r^  和 余数R</p>
<p>通过发送端和接受端都根据G 来计算出 R，原理是什么？</p>
<h6 id="为什么传输层用-checksum-而链路层用CRC？"><a href="#为什么传输层用-checksum-而链路层用CRC？" class="headerlink" title="为什么传输层用 checksum 而链路层用CRC？"></a>为什么传输层用 checksum 而链路层用CRC？</h6><p>因为传输层是运行于os 的软件实现，需要简单快速， 链路层是在适配器中用专门的硬件实现的，能够快速执行 CRC 操作！</p>
<h4 id="多路访问链路协议"><a href="#多路访问链路协议" class="headerlink" title="多路访问链路协议"></a>多路访问链路协议</h4><p>网络链路类型</p>
<ul>
<li>点对点链路</li>
<li>广播链路： 共享一个信道</li>
</ul>
<h6 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h6><ul>
<li>时分多路复用</li>
<li>频分多路复用</li>
<li>码分多址（CDMA）</li>
</ul>
<h6 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h6><ul>
<li>时隙ALOHA</li>
</ul>
<p>随机开始发送， 有冲突时以一定概率延时一些时隙</p>
<p>当 N 个节点访问的时候， 效率为 37 %，低！</p>
<ul>
<li>ALOHA</li>
</ul>
<p>随机开发发送，有冲突时一定概率继续发送</p>
<p>效率更低！ 为时隙的一半</p>
<ul>
<li>载波侦听多路访问（CSMA/CD carrier sense multiple access with collision detection）</li>
</ul>
<p>理论效率接近 1</p>
<h6 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h6><ul>
<li>轮询协议</li>
</ul>
<p>主节点轮询访问每一个节点，控制发送，解决冲突问题， 但是引入了轮询时延和主节点单点故障</p>
<ul>
<li>令牌传递协议</li>
</ul>
<p>传递令牌来作为主节点</p>
<h4 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h4><h5 id="链路层寻址和-ARP"><a href="#链路层寻址和-ARP" class="headerlink" title="链路层寻址和 ARP"></a>链路层寻址和 ARP</h5><ul>
<li>MAC 地址</li>
</ul>
<p>48位，每一个适配器（网络接口） 有链路层地址，不是主机。</p>
<h6 id="为什么要有-MAC地址？"><a href="#为什么要有-MAC地址？" class="headerlink" title="为什么要有 MAC地址？"></a>为什么要有 MAC地址？</h6><blockquote>
<p>1、 局域网是为任意的网络层协议设计的， 不只是 IP 和 因特网。</p>
</blockquote>
<blockquote>
<p> 2、如果是IP地址，存储于 RAM 每次都要重新配置</p>
</blockquote>
<blockquote>
<p> 如果将ip存在适配器中，那么每次发的信息都会中断主机</p>
</blockquote>
<ul>
<li>地址解析协议（ARP）</li>
</ul>
<p>将 IP 解析为 MAC 地址， 类似DNS， 属于网络层和链路层。</p>
<p><strong>路由器的每一个接口都有一个  ARP 模块和适配器！</strong></p>
<p>路由器和交换机的区别</p>
<p>路由器是第3 层的， 交换机是第二层（链路层）， 对于主机和交换机是透明的存在</p>
<h5 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h5><p>以太网帧的第一段为数据字段， 最大为 1500， 因此 MTU  =  1500</p>
<h4 id="浏览器访问的流程"><a href="#浏览器访问的流程" class="headerlink" title="浏览器访问的流程"></a>浏览器访问的流程</h4><p>主机     –    交换机A    –  路由器A</p>
<h5 id="准备阶段一：-DHCP，-UDP，-IP，-以太网帧"><a href="#准备阶段一：-DHCP，-UDP，-IP，-以太网帧" class="headerlink" title="准备阶段一： DHCP， UDP， IP， 以太网帧"></a>准备阶段一： DHCP， UDP， IP， 以太网帧</h5><p>1、 主机运行dhcp 服务， 没有ip的情况下， 发送DHCP 报文</p>
<p>2、 以太网帧封装 DHCP 帧，进行广播</p>
<p>3、交换机A广播以太网帧</p>
<p>4、路由器A 接受到DHCO 报文， 进行解析UDP</p>
<p>5、封装 IP 等信息返回给主机</p>
<p>6、交换接收到会保存交换机表，下次不用再访问</p>
<p>7、主机发送 DHCP ACK</p>
<p>至此已经获得了 IP 地址可以发送数据了</p>
<h5 id="准备阶段二：DNS和ARP"><a href="#准备阶段二：DNS和ARP" class="headerlink" title="准备阶段二：DNS和ARP"></a>准备阶段二：DNS和ARP</h5><p>8、 对于浏览器链接首先要解析出 IP， 发送 DNS 报文</p>
<p>9、 网关路由器的 MAC 还不知道， 封装 ARP 协议 </p>
<p>10、封装网关的IP 进行 ARP 广播</p>
<p>11、 网关收到了ARP 报文帧，返回 MAC 地址</p>
<p>12、 此时主机得到网关的 MAC</p>
<p>13、 现在可以发动数据了，发送 DNS数据</p>
<h5 id="准备阶段三：-路由到DNS服务器"><a href="#准备阶段三：-路由到DNS服务器" class="headerlink" title="准备阶段三： 路由到DNS服务器"></a>准备阶段三： 路由到DNS服务器</h5><p>14、 根据路由表发送 DNS 数据到 DNS的路由器上</p>
<p>15、 DNS 的路由器收到消息后再转发到 DNS 服务器上，（BGP协议）</p>
<p>16、  DNS 返回IP给主机</p>
<p>17、 获得了 目的主机的 ip</p>
<h5 id="CS-交互：-TCP-HTTP"><a href="#CS-交互：-TCP-HTTP" class="headerlink" title="CS 交互： TCP HTTP"></a>CS 交互： TCP HTTP</h5><p>18、 首先3次握手，封装 目的 MAC 地址为网关路由器的的帧， 后面就直接BGP 跳转了。。。 MAC 只是局部的</p>
<p>19、 使用转发表一直到目的主机</p>
]]></content>
  </entry>
  <entry>
    <title>tcp学习笔记</title>
    <url>/2019/02/28/notepad/network/%E8%AE%A1%E7%BD%91%E6%9D%82%E5%BD%95/</url>
    <content><![CDATA[<h3 id="tcp学习笔记"><a href="#tcp学习笔记" class="headerlink" title="tcp学习笔记"></a>tcp学习笔记</h3><p>TCP 连续发 10 个包， 客户端会收到什么消息？</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/tcptest.png"></p>
<h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/fuck.png" alt="image-20200405105204612"></p>
<p>3.1 环回地址必须是1 2 7 . 0 . 0 . 1吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不，任何网络 I D 为1 2 7 的A类地址都是可行的，尽管大多数系统使用了1 2 7 . 0 . 0 . 1。</span><br></pre></td></tr></table></figure>

<p>3.2 在图3 - 6中指出有两个网络接口的路由器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k p n o有5个接口：3个点对点链路和2 个以太网接口。R 1 0有4个以太网接口。</span><br><span class="line">g a t e w a y有3个接口： 2个点对点链路和1 个以太网接口。</span><br><span class="line">最后， n e t b有1个以太网接口和2个点对点链路。</span><br></pre></td></tr></table></figure>

<p>3.3 子网号为16 bit的A类地址与子网号为8 bit 的B类地址的子网掩码有什么不同？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">没有区别：作为一个没有再区分子网的C类地址，它们都有一个2 5 5 . 2 5 5 . 2 5 5 . 0的子网掩</span><br><span class="line">码。</span><br></pre></td></tr></table></figure>

<p>3.4 阅读RFC 1219 [Tsuchiya 1991]，学习分配子网号和主机号的有关推荐技术。</p>
<p>3.5 子网掩码2 5 5 . 2 5 5 . 0 . 2 5 5是否对A类地址有效？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">它是合法的，被称为非连续的子网掩码，因为其用于子网掩码的1 6位是不连续的。但是</span><br><span class="line">R F C建议反对使用非连续的子网掩码。</span><br></pre></td></tr></table></figure>

<p>3.6 你认为为什么3 . 9小节中打印出来的环回接口的M T U要设置为1 5 3 6？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个历史遗留问题。值是1 0 2 4＋5 1 2，但是打印的M T U值包含了所有需要的首部字</span><br><span class="line">节数。Solaris 2.2将回环接口的M T U设置为8 2 3 2（8 1 9 2＋4 0），其中包含了8 1 9 2字节的用</span><br><span class="line">户数据加上2 0字节的I P首部和2 0字节的T C P首部。</span><br></pre></td></tr></table></figure>

<p>3.7 T C P / I P协议族是基于一种数据报的网络技术，即I P层，其他的协议族则基于面向连接的<br>网络技术。阅读文献[Clark 1988]，找出数据报网络层提供的三个优点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一，数据报降低了路由器中对于连接状态的需求。第二，数据报提供了基本的构件，</span><br><span class="line">在它的上面可以构造不可靠的（ U D P）和可靠的（ T C P）的运输层。第三，数据报代表</span><br><span class="line">网络总数了最小的网络层假定，使得可以使用很大范围的数据链路层服务。</span><br></pre></td></tr></table></figure>







<p>17.1 我们已经介绍了以下几种分组格式： I P、I C M P、I G M P、U D P和T C P。每一种格式的首<br>部中均包含一个检验和。对每种分组，说明检验和包括I P数据报中的哪些部分，以及该<br>检验和是强制的还是可选的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">除了U D P的检验和，其他都是必需的。I P检验和只覆盖了I P首部，而其他字段都紧接着</span><br><span class="line">I P首部开始。</span><br></pre></td></tr></table></figure>

<p>17.2 为什么我们已经讨论的所有I n t e r n e t协议（I P, ICMP, IGMP, UDP, TCP）收到有检验和错<br>的分组都仅作丢弃处理？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">源I P地址、源端口号或者协议字段可能被破坏了。</span><br></pre></td></tr></table></figure>

<p>17.3 T C P提供了一种字节流服务，而收发双方都不保持记录的边界。应用程序如何提供它们<br>自己的记录标识？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">很多I n t e r n e t应用使用一个回车和换行来标记每个应用记录的结束。这是NVT ASCII采</span><br><span class="line">用的编码。另外一种技术是在每个记录之前加上一个记录的字节计数， D N S</span><br><span class="line">（习题1 4 . 4）和Sun RPC（2 9 . 2节）采用了这种技术。</span><br></pre></td></tr></table></figure>

<p>17.4 为什么在T C P首部的开始便是源和目的的端口号？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 就像我们在6 . 5节所看到的，一个 ICMP 差错报文必须至少返回引起差错的I P数据报中除了</span><br><span class="line">I P首部的前8 个字节。当T C P收到一个I C M P差错报文时，它需要检查两个端口号以决定差</span><br><span class="line">错对应于哪个连接。因此，端口号必须包含在T C P首部的前8个字节里。</span><br></pre></td></tr></table></figure>

<p>17.5 为什么T C P首部有一个首部长度字段而U D P首部（图11 - 2）中却没有？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP首部的最后有一些选项，但U D P首部中没有选项。</span><br></pre></td></tr></table></figure>



<h3 id="TCP连接的建立与终止"><a href="#TCP连接的建立与终止" class="headerlink" title="TCP连接的建立与终止"></a>TCP连接的建立与终止</h3>]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab基础语法</title>
    <url>/2019/08/22/notepad/others/matlab%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="matlab基础语法"><a href="#matlab基础语法" class="headerlink" title="matlab基础语法"></a>matlab基础语法</h2><p>disp显示结果<br>clc用来清除命令窗口的显示内容<br>clear用来清除工作空间里的数据内容<br>Who、whos命令用来在命令窗口中显示工作空间的变量信息<br>warning off用来去除出现的警告<br>dir用来显示当前工作目录的文件和子目录清单<br>-cd用来显示或设置当前工作目录<br>type用来显示指定m文件的内容<br>quit或exit用来关闭/推出MATALB<br>disp(X)：用于显示变量X的值，并且不显示变量名称X<br>num2str(A)：用于将数字A转换为字符串，根据这个函数的构造很容易看出它的意思“number to string”，是不是很有意思<br>input()：用于用户对程序内输入数据，具体用法为x = input(prompt)或者str = input(prompt,’s’)，前者表示输入一个数值，后者表示输入一个字符串。当程序运行到这个地方时，在命令窗口内，需要用户输入一个数据，以回车键结束，那么这个数据会存储到x(如果使用的是字符型输入，则存储到str)，其中，prompt表示提示语，一般是一个字符串，而且这个字符串必须有（可以为空字符串””）。</p>
<h2 id="1-创建一维矩阵"><a href="#1-创建一维矩阵" class="headerlink" title="1. 创建一维矩阵"></a>1. 创建一维矩阵</h2><p>首先，介绍如何创建行矩阵。</p>
<p>方法一：使用方括号“[ ]”操作符<br>例如，创建一个一维矩阵a</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;[1 3 pi 3+5*i]  %or a&#x3D;[1, 3, pi, 3+5*i] </span><br><span class="line">a&#x3D; 1.0000      3.0000      3.1416       3.0000 + 5.0000i</span><br></pre></td></tr></table></figure>

<p>方法二：使用冒号“:”操作符<br>利用冒号“:”操作符创建行向量的基本语法格式：<br>x=Start : Increment : End</p>
<ol>
<li>Start表示新向量x的第一个元素；</li>
<li>新向量x的最后一个元素不能大于End ；</li>
<li>Increment可正可负，若负，则必须Start&gt;End；若正，则必须Start End，否则创建的为空向量；</li>
<li>若Increment=1,则可简写为x=Start:End。<br>例如，创建以1~10顺序排列整数为元素的行向量b<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#x3D;1 : 1 : 10</span><br><span class="line"> b&#x3D;1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure>
方法三：利用函数linspace<br>函数linspace的基本语法为：<br>x= linspace(x1, x2, n)</li>
<li>该函数生成一个由n个元素组成的行向量；</li>
<li>x1为其第一个元素；</li>
<li>x2为其最后一个元素；</li>
<li>x1、x2之间元素的间隔=(x2-x1)/(n-1)；</li>
<li>如果忽略参数n，则系统默认生成100个元素的行向量。<br>例如，键入并执行x= linspace(1,2,5)，结果为：<br>x=1.0000 1.2500 1.5000 1.7500 2.0000</li>
</ol>
<p>其次，介绍如何创建列矩阵</p>
<p>使用方括号“[ ]”操作符，使用分号“;”分割行。<br>例如：键入并执行x= [1; 2; 3]，结果如下：<br>   X=1<br>     2<br>     3</p>
<h2 id="2-创建二维矩阵"><a href="#2-创建二维矩阵" class="headerlink" title="2. 创建二维矩阵"></a>2. 创建二维矩阵</h2><p>方法一：使用方括号“[ ]”操作符<br>使用规则如下：</p>
<ol>
<li>数组元素必须在“[ ]”内键入；</li>
<li>行与行之间须用分号“;” 间隔，也可以在分行处用回车键间隔；</li>
<li>行内元素用空格或逗号“,”间隔。<br>例如，键入并执行a2=[1 2 3;4 5 6;7 8 9]，或者a2=[1:3;4:6;7:9]，结果都是：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a2&#x3D;</span><br><span class="line">    1  2  3</span><br><span class="line">    4  5  6</span><br><span class="line">    7  8  9</span><br></pre></td></tr></table></figure>
当然，由向量构成二维数组，例如（结果自行验证）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;a&#x3D;[1 2 3]; b&#x3D;[2 3 4]; </span><br><span class="line">&gt;&gt;c&#x3D;[a;b];</span><br><span class="line">&gt;&gt;c1&#x3D;[a b];</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line">方法二：函数方法</span><br><span class="line"></span><br><span class="line">函数ones(生成全1矩阵)、zeros (生成全0矩阵) 、reshape都可以创建初始矩阵。在命令窗口键入help elmat获得基本的矩阵生成和操作函数列表，这里仅展示全1矩阵ones的用法。</span><br></pre></td></tr></table></figure>
<p>例如，创建全1的3x3矩阵。</p>
<blockquote>
<blockquote>
<p>ones(3)<br>而创建全1的1x3的矩阵则是：<br>ones(1,3)<br>又例如，创建全1的3x4矩阵。<br>ones(3,4)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 矩阵元素的相关操作</span><br><span class="line">对于一个给定的矩阵，里面有很多元素，那么如何取出这些元素、如何更改这些元素呢？对于一个给定的矩阵，要想取出它的某个元素，可以使用括号()来实现。</span><br><span class="line"></span><br><span class="line">例如，现有一个3x4的二维矩阵A，想要取出第2行第3列的数据给b，可以表示如下：</span><br><span class="line">b&#x3D;A(2,3);</span><br><span class="line"></span><br><span class="line">想要将第1行第2列元素设置为10，表示如下：</span><br><span class="line">A(1,2)&#x3D;10;</span><br><span class="line"></span><br><span class="line">同样，对于一个拥有10个元素的一维矩阵B，取出它的第3个元素给c的操作为：</span><br><span class="line">c&#x3D;B(3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">您可以使用 save 命令将工作区中的变量保存到称为 MAT 文件的 MATLAB 特定格式文件中。</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>save foo x<br>以上命令将名为 x 的变量保存到名为 foo.mat 的 MAT 文件中。<br>您可以使用 load 命令从 MAT 文件加载变量。<br>load foo</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">您可以使用 MATLAB 关键字 end，作为行或列索引来引用最后一个元素。</span><br><span class="line"></span><br><span class="line">用作索引时，冒号运算符 (:) 可指代该维度中的所有元素。以下语法</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>x = A(2,:)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">会创建一个包含 A 中第 2 行上所有元素的行向量。</span><br><span class="line"></span><br><span class="line">#### .*   是按照元素相乘</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>doc fcnName<br>以获取任何 MATLAB 函数的相关信息。</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plot 函数接受一个附加参数，该参数让您能够在单引号中使用各种符号来指定颜色、线型和标记样式。</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>plot(x,y,’r–o’)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以上命令将会绘制一条红色 (r) 虚线 (--)，并使用圆圈 (o) 作为标记。您可以在线条设定的文档中了解有关可用符号的详细信息。</span><br><span class="line"></span><br><span class="line">您会注意到，最开始创建的绘图消失了。要在一张图上先后绘制两条线，请使用 hold on 命令保留之前的绘图，然后添加另一条线。</span><br><span class="line"></span><br><span class="line">close all  关闭所有的窗口</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 plot 函数时，您可在绘图参数和线条设定符之后添加属性名称-属性值对组。</p>
<blockquote>
<blockquote>
<p>plot(x,y,’ro-‘,’LineWidth’,5)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">使用 numel 函数返回数组中的元素数目。</span><br><span class="line"></span><br><span class="line">您可以使用逻辑数组作为数组索引，在这种情况下，MATLAB 会提取索引为 true 的数组元素。以下示例将会提取 v1 中大于 6 的所有元素。</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>v = v1(v1 &gt; 6)<br>v =<br>    6.6678<br>    9.0698</p>
</blockquote>
</blockquote>
<pre><code>
#### 用 vpa 显示小数。</code></pre>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh配置公钥</title>
    <url>/2019/10/27/notepad/others/ssh%E9%85%8D%E7%BD%AE%E5%85%AC%E9%92%A5/</url>
    <content><![CDATA[<h1 id="ssh的使用"><a href="#ssh的使用" class="headerlink" title="ssh的使用"></a>ssh的使用</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ssh连接服务器是经常要操作的步骤，可当每次都要手动输入 <code>ssh user@ip </code> ，然后加上密码连接可谓是及其地麻烦，虽然有xs的记录密码，但当要将服务器分享给他人时，为了方便别人，可以配置公钥，配好后对方直接使用ssh username，就可以直接连上，密码都不用输入。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><a id="more"></a>
<p>。。。 不会，</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="pc端"><a href="#pc端" class="headerlink" title="pc端"></a>pc端</h3><p>要使用vps的pc端，cmd输入    <code> ssh-keygen -t rsa</code>，如果已经创建过就不用了，直接下两步，不然之前配的秘钥就换了，比如git配置的ssh密码。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh1.jpg"></p>
<p>这里我就不创建了，创建好按照提示进入创建的目录,一般默认就行，在用户目录下。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh2.jpg"></p>
<p>新建一个 config文件</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh3.jpg"></p>
<p>注意是没有后缀的</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh4.jpg"></p>
<p>其中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host 为服务器别名,取一个方便记的</span><br><span class="line">HostName 为服务器域名(ip)</span><br><span class="line">User 为登录的账号</span><br></pre></td></tr></table></figure>

<p>pc端操作完毕！</p>
<h3 id="vps"><a href="#vps" class="headerlink" title="vps"></a>vps</h3><p>终端输入    <code> ssh-keygen -t rsa</code>   , 回车回车回车。。。。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/sshshiyong.jpg"></p>
<p><code>ls -a</code> 可以查看到有一个 .ssh文件夹</p>
<p>进入,将刚才pc端创建的  id_ras.pub 放到 到 authorized_keys文件里面。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh5.jpg"></p>
<p>搞定！！！ </p>
<p>之后直接在cmd里输入 <code>ssh Host (为服务器别名,取一个方便记的)</code>就可以直接连上，不用输入密码。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh6.jpg"></p>
<p>配合vscode的ssh连接，简直不能再方便了！！！！</p>
<p>只要需要三步，就可以直接键代码跑到服务器，像操作自己的电脑一样，真的真的真的太太太太太方便了，谁用谁会爱上它！！！！！（当然vscode要下插件）</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/ssh7.jpg"></p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>windows的脚本命令一件部署后端服务</title>
    <url>/2019/09/11/notepad/others/windows%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%90%8E%E7%AB%AF/</url>
    <content><![CDATA[<h4 id="windows的脚本命令一件部署后端服务"><a href="#windows的脚本命令一件部署后端服务" class="headerlink" title="windows的脚本命令一件部署后端服务"></a>windows的脚本命令一件部署后端服务</h4><p> 实习一个月了，其中有许多有意思的东西希望能记住一些小技巧，今天想记录的是，花了一个下午才研究通透的一个windows脚本命令。</p>
<h2 id="一，BAT命令简要说明"><a href="#一，BAT命令简要说明" class="headerlink" title="一，BAT命令简要说明"></a>一，BAT命令简要说明</h2><p>  这个是windows的批处理文件，在这里可以这接写dos命令，一些恶意小程序就是可以在这里写，和linux的sh不同是，不用给文件赋予权限，bat只需要，把后缀改为bat就行了，其实windwos部署服务很少，习惯了linux，突然用dos感觉好不习惯。</p>
<ul>
<li><p>首先是注释  ：：  两个冒号代表注释一行，为了防止写着脚本自己写到哪里了都不知道，注释还是有作用的。<br><img src="https://img-blog.csdnimg.cn/20190808105234421.png" alt="在这里插入图片描述"></p>
</li>
<li><p>  goto  :next</p>
<pre><code>`echo &#39;pull sucess!&#39;
`echo &#39;pull sucess!&#39;
:next

  上面的goto语句是跳过中间的两个命令， 简洁明了</code></pre>
</li>
<li><p>echo off<br>  如果不想要每次都显示路径这个就可以只显示执行的情况。所以一般开头加一句</p>
</li>
<li><p> call  </p>
<pre><code>  这个命令值得注意下，如果在bat命令中调用了其它的bat，其它bat里面运行完一般会有退出命令，所以，如果不想在调用了其它命令后退出，就call 这个命令。比如说mvn命令，这个调用了之后运行完会直接退出，所以加个call</code></pre>
</li>
</ul>
<h2 id="二，流程"><a href="#二，流程" class="headerlink" title="二，流程"></a>二，流程</h2><ol>
<li><p> ::先随便到一个目录，把该目录下的jcSrc  保存<br>cd  E:\jc<br>::Q表示不显示文件名C错误也复制E所有子目录Y不提示覆盖<br>xcopy  E:\jc\jcSrc  E:\jc\jcSrcHistory/E/C/Y/Q<br>解释：此命令只是把先前的src复制一遍存起来</p>
</li>
<li><p>cd jcSrc<br>git pull origin master<br>echo ‘pull sucess!’<br>解释：上面的三条脚本在bash测试成功后放到这里，Git拉取src，git还要配置环境变量</p>
</li>
<li><p>::mvn打包<br>cd   E:\jc\jcSrc\common<br>call mvn clean compile<br>call mvn clean package<br>echo ‘mvn package success’<br>这个也要配置环境变量</p>
</li>
<li><p>::删除原来的包,注意改名jar<br>cd  E:\jc\jcJar<br>rd/s/q    common-0.0.1-SNAPSHOT.jar<br>echo ‘delete success！’<br>写到这里想起差点把我的一个大文件给删了。 注意注意注意</p>
</li>
<li><p>::将打包好的jar包复制到jcJar中<br>xcopy  E:\jc\jcSrc\common\target\common-0.0.1-SNAPSHOT.jar  E:\jc\jcJar/E/C/Y/Q<br>echo ‘copy jar success’</p>
</li>
<li><p>set port=8092<br>for /f “tokens=1-5” %%i in (‘netstat -ano^|findstr “:%port%”‘) do taskkill /F /pid %%m<br>echo ‘delete port success’<br>解释：这一步很重要，先要删除端口，很高兴在网上找到了删除端口对应程序的代码，在2008里面既然不能用，后来发现，是这个脚本命令不能换行。不然换行写多舒服！</p>
</li>
<li><p>::运行<br>cd  E:\jc\jcJar<br>java -jar common-0.0.1-SNAPSHOT.jar –server.port=8092<br>echo ‘如果你在运行的时候看到我,就说明启动失败啦!!!,上面的某一条命令没有执行成功’<br>echo ‘success!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!’<br>pause<br>解释：</p>
<pre><code>     1.因为java -jar  运行后端服务是持续的，所以后面的echo是要等到java运行完才打印的，如果没有启动成功，才会打印，=
     2.还是因为这是2008的上古神机windows版本，所以用了java命令，如果是window10，可以直接用javaw， 命令，这个命令可以让jar在后台执行。</code></pre>
</li>
</ol>
<p>最后来一个全的</p>
<pre><code>::先随便到一个目录，把该目录下的jcSrc  保存
cd  E:\jc
::Q表示不显示文件名C错误也复制E所有子目录Y不提示覆盖
xcopy  E:\jc\jcSrc  E:\jc\jcSrcHistory/E/C/Y/Q

echo &#39;copy sucess!&#39;

cd jcSrc
git pull origin master
echo &#39;pull sucess!&#39;


::mvn 打包
cd   E:\jc\jcSrc\common
call mvn clean compile
call mvn clean package
echo &#39;mvn package success&#39;


::删除原来的包,注意改名jar
cd  E:\jc\jcJar
rd/s/q    common-0.0.1-SNAPSHOT.jar
echo ‘delete success！’

::将打包好的jar包复制到jcJar中

xcopy  E:\jc\jcSrc\common\target\common-0.0.1-SNAPSHOT.jar  E:\jc\jcJar/E/C/Y/Q
echo &#39;copy jar success&#39;


set port=8092
for /f &quot;tokens=1-5&quot; %%i in (&#39;netstat -ano^|findstr &quot;:%port%&quot;&#39;) do taskkill /F /pid %%m

echo &#39;delete port success&#39;

::运行
cd  E:\jc\jcJar
java -jar common-0.0.1-SNAPSHOT.jar --server.port=8092
echo &#39;如果你在运行的时候看到我,就说明启动失败啦!!!,上面的某一条命令没有执行成功&#39;
echo &#39;success!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&#39;

pause</code></pre>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器自动拉取git脚本</title>
    <url>/2019/10/01/notepad/others/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96Git%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="linux-自动运行脚本代码"><a href="#linux-自动运行脚本代码" class="headerlink" title="linux 自动运行脚本代码"></a>linux 自动运行脚本代码</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Blog每次提交到git的时候，都要上服务器拉取一下，而且每次执行相同的操作，这种机械的操作机器是最擅长的，于是乎，上网查了，git可以使用hooks，在push了代码后，自动先向务器发出post请求，然后让服务器更新代码，尝试了一下，php文件不是很会，于是另寻它径。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>既然php程序不会写，那就直接写sh， 然后让crontab定时器，每分钟更新一遍代码！！！</p>
<p>首先写一个sh文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo off</span><br><span class="line">cd &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;firefly&#x2F;</span><br><span class="line">echo &#39;opened&#39;</span><br><span class="line"></span><br><span class="line">git pull # 拉取代码</span><br><span class="line"></span><br><span class="line">echo &#39;success&#39;</span><br></pre></td></tr></table></figure>

<p>然后使用定时器，每分钟执行一遍代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; crontab -e   # 进入编辑模式</span><br><span class="line">输入：</span><br><span class="line"> *&#x2F;1 * * *  &#x2F;root&#x2F;deploy.sh   # 这里是要执行的脚本</span><br></pre></td></tr></table></figure>


<p>执行<code>cd /var/log/</code>查看执行的指令</p>
<p><code>tail -n 3 /var/log/cron</code>这个可以看到一点输出</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派入坑之旅</title>
    <url>/2019/10/17/notepad/others/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="树莓派使用"><a href="#树莓派使用" class="headerlink" title="树莓派使用"></a>树莓派使用</h1><h2 id="树莓派的安装"><a href="#树莓派的安装" class="headerlink" title="树莓派的安装"></a>树莓派的安装</h2><p>1、安装Win32DiskImager-0.9.5-install.exe到电脑上。</p>
<p>解压2019-06-20-raspbian-buster-full.zip，打开此软件，选择官方系统img，选择SD卡的盘符，这里不能选错，否则会被格式化，如下图配置。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/shumeipai1.jpg"></p>
<p>2、选择Write进行烧录，等待烧录完成，拔掉SD卡，插入树莓派上电，系统会自动安装完成。</p>
<p>3、注意烧录完成后，win系统可能会因为无法识别Linux分区格式而提示用户格式化，此时不要点格式化！不要点格式化！不要点格式化！直接点取消就可以了。如果点了格式化，树莓派会因为丢失系统文件而无法开机，需要重新烧录IMG镜像文件。</p>
<p>4、安装完后添加显示器的配置文件，树莓派的小册子里有</p>
<p>开机搞定！！！！</p>
<h2 id="frp实现内网穿透"><a href="#frp实现内网穿透" class="headerlink" title="frp实现内网穿透"></a>frp实现内网穿透</h2><p>使用frp内网穿透控制家里的树莓派，这样即便在外面也可以随时控制树莓派，也可以让其他人操控树莓派。</p>
<p>需要用到的工具：</p>
<ul>
<li>树莓派</li>
<li>一台vps</li>
<li>树莓派摄像头</li>
<li>手</li>
</ul>
<p>首先，你需要分别在vps、树莓派上下载frp</p>
<p>你也可以自行前往GitHub下载<br><a class="link"   href="https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_386.tar.gz" >https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_386.tar.gz<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><p>首先是在vps上进行操作，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.29.0&#x2F;frp_0.29.0_linux_386.tar.gz</span><br><span class="line">tar zxvf frp_0.29.0_linux_386.tar.gz</span><br><span class="line">cd frp_0.29.0_linux_386</span><br><span class="line">vim frps.ini</span><br></pre></td></tr></table></figure>

<hr>
<p>在vps中修改解压出来的frps.ini文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"># 用于连接的端口bind_port &#x3D; 7000</span><br><span class="line"># 控制板端口dashboard_port &#x3D; 7500</span><br><span class="line"># 控制板登陆账号dashboard_user &#x3D; dashboard_user_name</span><br><span class="line"># 控制板登陆密码dashboard_pwd &#x3D; dashboard_pwd_value</span><br></pre></td></tr></table></figure>

<p>配置完成后，使用以下命令启动服务端的frp。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frps -c .&#x2F;frps.ini</span><br></pre></td></tr></table></figure>

<p>推荐设置开机自启动，方法：在 /etc/rc.local 添加上述命令行</p>
<p>然后即可访问 vps的ip:您设置的端口</p>
<hr>
<h3 id="树莓派"><a href="#树莓派" class="headerlink" title="树莓派"></a>树莓派</h3><p>接着就是树莓派上的设置，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.29.0&#x2F;frp_0.29.0_linux_arm.tar.gz</span><br><span class="line">tar zxvf frp_0.29.0_linux_arm.tar.gz</span><br><span class="line">cd frp_0.29.0_linux_arm</span><br><span class="line">vim frpc.ini</span><br></pre></td></tr></table></figure>

<hr>
<p>进行如下修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"># 你的服务器的IP、frps端口server_addr &#x3D; 你的vps的IP地址server_port &#x3D; 7000</span><br><span class="line">[ssh]</span><br><span class="line"># 需要被穿透的服务、本地ip、本地端口</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line"># 使用服务器的哪个端口进行穿透访问，记得打开防火墙</span><br><span class="line">remote_port &#x3D; 10023</span><br></pre></td></tr></table></figure>

<hr>
<p>启动frp客户端服务(建议添加到 /etc/rc.local 实现开机自启动)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure>

<p>测试一下是否成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -pi@ip -p 10023</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/shumeipai2.png"></p>
<p>成功啦！！！！</p>
<h2 id="rmtp推流到"><a href="#rmtp推流到" class="headerlink" title="rmtp推流到"></a>rmtp推流到</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>树莓派连在局域网，因此需要一台公网的服务器，pi使用ffmpeg推流到服务器，服务器监听这个流传播出去，然后推给虎牙，在虎牙上面查看流。</p>
<p>所以大致分为三步：</p>
<h4 id="1、服务器"><a href="#1、服务器" class="headerlink" title="1、服务器"></a>1、服务器</h4><p>​    这一步是最麻烦的，大致思路如下，首先你得安装nginx， 然后还有rmtp模块。</p>
<p><a class="link"   href="https://cloud.tencent.com/developer/article/1145657" >https://cloud.tencent.com/developer/article/1145657<i class="fas fa-external-link-alt"></i></a></p>
<p> <a class="link"   href="https://blog.csdn.net/sz76211822/article/details/79225716" >https://blog.csdn.net/sz76211822/article/details/79225716<i class="fas fa-external-link-alt"></i></a> </p>
<p>网上有很多很多的教程，也有直接配rmtp的教程，然并卵，要么这个有问题，要么那个有问题，但是没关系，先安装<strong>要用到的模块</strong>，慢慢试，一个一个试，总有一个是可以 nginx 运行成功的！！！</p>
<p> 接着就是配置文件的设置，这一步最关键，一个教程有一个方法，真的是服了，还好DMFer，找到了rmtp模块里头的README， README多言简意赅， 先读我！！！</p>
<p><a class="link"   href="https://github.com/arut/nginx-rtmp-module/blob/master/README.md?tdsourcetag=s_pctim_aiomsg" >README<i class="fas fa-external-link-alt"></i></a></p>
<p>按照里面给的例子，配置， and then cuccess！！！</p>
<p><strong>有些坑不踩过，是跳不过的。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtmp:&#x2F;&#x2F;119.3.239.133:1935&#x2F;hls ^_^</span><br></pre></td></tr></table></figure>



<h4 id="2、-pi"><a href="#2、-pi" class="headerlink" title="2、 pi"></a>2、 pi</h4><p>pi其实没有什么好设置的，只需要打开摄像头（百度），然后就是ffmpeg推流到服务器设置好的那个端口上就行！所以还得百度ffmpeg安装。</p>
<p>最简单的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i &#x2F;dev&#x2F;video0 -b:v 800k  -f flv rtmp:&#x2F;&#x2F;119.3.239.133:1935&#x2F;hls</span><br></pre></td></tr></table></figure>

<p>带点参数的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &#x2F;dev&#x2F;video0 -c:v libx264 -preset ultrafast  -acodec libmp3lame -ar 44100 -ac 1  -f flv rtmp:&#x2F;&#x2F;119.3.239.133:1935&#x2F;hls</span><br></pre></td></tr></table></figure>

<p>每条指令参数什么意思呢？搜索本站 ffmpeg，然后对应搜索每一个参数！</p>
<h4 id="3、-获取"><a href="#3、-获取" class="headerlink" title="3、 获取"></a>3、 获取</h4><p>这一步在服务器上操作，把rmtp转换为html的界面！</p>
<p><a class="link"   href="http://shumeipai.nxez.com/2017/11/01/build-rtmp-stream-live-server-with-raspberry-pi.html?tdsourcetag=s_pctim_aiomsg" >教程<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="mipg-streaming"><a href="#mipg-streaming" class="headerlink" title="mipg-streaming"></a>mipg-streaming</h2><p><a class="link"   href="http://shumeipai.nxez.com/2017/05/14/raspberry-pi-mjpg-streamer-installation.html" >http://shumeipai.nxez.com/2017/05/14/raspberry-pi-mjpg-streamer-installation.html<i class="fas fa-external-link-alt"></i></a></p>
<p>先放一下教程，听同学说很卡，不打算尝试</p>
<h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><h3 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h3><p>要用它来拍摄照片的话，可以从命令行运行raspistill：</p>
<p><code> raspistill -o keychain.jpg -t 2000</code> </p>
<p>这句命令将在 2000ms 后拍摄一张照片，然后保存为 keychain.jpg。</p>
<p>raspiyuv 工具用法差不多，只不过拍摄得到的是一张未处理过的raw图像。</p>
<h3 id="摄像"><a href="#摄像" class="headerlink" title="摄像"></a>摄像</h3><p>想要用摄像头模块拍一段视频的话，可以从命令行运行 raspivid 工具。下面这句命令会按照默认配置(长度5秒，分辨率1920x1080，比特率 17Mbps)拍摄一段视频。</p>
<p><code>$ raspivid -o mykeychain.h264</code></p>
<p>如果你想改变拍摄时长，只要通过 “-t” 选项来设置你想要的长度就行了（单位是毫秒）。</p>
<p><code>$ raspivid -o mykeychain.h264 -t 10000</code></p>
<p>使用 “-w” 和 “-h” 选项将分辨率降为 1280x720…</p>
<p><code>$ raspivid -o mykeychain.h264 -t 10000 -w 1280 -h 720</code></p>
<p>raspivid 的输出是一段未压缩的 H.264 视频流，而且这段视频不含声音。为了能被通常的视频播放器所播放，这个 raw 的 H.264 视频还需要转换。可以使用 gpac 包中所带有的 MP4Box 应用。</p>
<p>在 Raspbian 上安装 gpac，输入命令：</p>
<p><code>$ sudo apt-get install -y gpac</code> </p>
<p>然后将这段 raw 的 H.264 格式的视频流转换为每秒30帧的 .mp4 格式视频：</p>
<p><code>$ MP4Box -fps 30 -add keychain.h264 keychain.mp4</code> </p>
<h2 id="防火墙的使用"><a href="#防火墙的使用" class="headerlink" title="防火墙的使用"></a>防火墙的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 启动防火墙</span><br><span class="line">systemctl start firewalld </span><br><span class="line"></span><br><span class="line">2. 禁用防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">3. 设置开机启动</span><br><span class="line">systemctl enable firewalld</span><br><span class="line"></span><br><span class="line">4. 停止并禁用开机启动</span><br><span class="line">sytemctl disable firewalld</span><br><span class="line"></span><br><span class="line">5. 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">6.查看指定区域所有打开的端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --list-ports</span><br><span class="line"></span><br><span class="line">7.在指定区域打开端口（记得重启防火墙）</span><br><span class="line">firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;80&#x2F;tcp</span><br><span class="line">or </span><br><span class="line">firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;80&#x2F;udp</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="端口占用及解除"><a href="#端口占用及解除" class="headerlink" title="端口占用及解除"></a>端口占用及解除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看端口占用：</span><br><span class="line"></span><br><span class="line">(1) netstat -an|grep 8080  &#x2F;&#x2F; </span><br><span class="line">   netstat -tln | grep 8000</span><br><span class="line">(2) lsof -i:8080</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">1.netstat无权限控制，lsof有权限控制，只能看到本用户</span><br><span class="line">2.losf能看到pid和用户，可以找到哪个进程占用了这个端口</span><br><span class="line"></span><br><span class="line">关闭进程：</span><br><span class="line"></span><br><span class="line">1: kill 进程号  会给进程发送一个SIGTERM信号，使进程先释放自己资源，然后停止，但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应，</span><br><span class="line"></span><br><span class="line">2:kill -9 进程号  会给进程发送一个SIGKILL信号，使该进程执行exit，不会被阻塞，所以可以有效的杀掉进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>不备案建站</title>
    <url>/2019/09/05/notepad/others/%E7%BB%95%E8%BF%87%E7%BD%91%E7%AB%99%E5%A4%87%E6%A1%88%E5%BB%BA%E7%AB%99/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p> 这个Blog建好的时候， 每次打开查看我写的都要输入一串数字ip，浏览器有记录还好，要是没有记录，真的是太麻烦了，鬼才能记住这么一长串数字，终于感受到为什么要发明域名这种东西了</p>
<p> 于是，毅然在阿里买下了一个域名， 10rmb一年，没想到这么挺便宜，解析到我的这个BLog的的服务器，这个服务器是我一个大学同学的，没有备案，弄了一个小时，终于可以访问， 吼吼吼，真的舒服，浏览器输入 fireflying.top 就可以访问，不用看到一串数字，一串记不住的数字</p>
<p> <strong>结果是</strong> ——&gt;   第二天，域名就被， 腾讯，拦截了， 还有一个链接到腾讯， 刚开始想， 丢，还以为阿里的域名，腾讯拦截干什么！?（黑人问号）， 后来仔细想了一下，原来服务器是腾讯的， 有域名解析到腾讯的服务器上，所以腾旭就给拦截了。现在为难我了，这个服务器是我一个大学同学的，要他备案可能有点不好，该怎么办呢？</p>
<h2 id="折腾"><a href="#折腾" class="headerlink" title="折腾"></a>折腾</h2><p> 查了一下,如果<strong>国内</strong>网站要域名绑定的话，就必须备案，防止什么什么。。。但是国外可以不用。当我看到这条的时候感觉完了，域名可能白买了，但是过了几个小时发呆的时候灵光一现，想到两个合起来不就行了？</p>
<p>简单来书说就是，把域名绑定在我另一个国外服务器上（<strong>合法</strong>），通过访问这个国外服务器，帮我转到这个国内的服务器（<strong>没毛病</strong>）</p>
<p> 再一想，直接用Git不就行了，他是外国人的，平时访问这么慢，ping 一下Github的地址 在东京，git也用到了代理，但是Git提供了一个域名的绑定方案，通过CNAME连接到Git，再转发， 终于最后搞定。</p>
<p> 但是存在的一个问题是，访问域名的时候，显示的是ip。</p>
<p> 使用 document.title=”强行改标题”</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg</title>
    <url>/2019/10/22/notepad/others/%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6ffmpeg/</url>
    <content><![CDATA[<h1 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h1><p>转载</p>
<p>ffmpeg的使用方式：<br>ffmpeg [options] [[infile options] -i infile]… {[outfile options] outfile}…</p>
<p><strong>常用参数说明：</strong><br>主要参数：<br>-i 设定输入流<br>-f 设定输出格式<br>-ss 开始时间</p>
<a id="more"></a>
<p><strong>视频参数：</strong><br>-b 设定视频流量，默认为200Kbit/s<br>-r 设定帧速率，默认为25<br>-s 设定画面的宽与高<br>-aspect 设定画面的比例<br>-vn 不处理视频<br>-vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器</p>
<p><strong>音频参数：</strong><br>-ar 设定采样率<br>-ac 设定声音的Channel数<br>-acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器<br>-an 不处理音频</p>
<h3 id="1-视频格式转换"><a href="#1-视频格式转换" class="headerlink" title="1.视频格式转换"></a>1.视频格式转换</h3><p>（其实格式转换说法不太准确，但大家都这么叫，准确的说，应该是视频容器转换）<br>比如一个avi文件，想转为mp4，或者一个mp4想转为ts。<br>ffmpeg -i input.avi output.mp4<br>ffmpeg -i input.mp4 output.ts<br>我目测这个已经能满足很多人的需求了。</p>
<h3 id="2-提取音频"><a href="#2-提取音频" class="headerlink" title="2.提取音频"></a>2.提取音频</h3><p>比如我有一个“晓松奇谈”，可是我不想看到他的脸，我只想听声音， 地铁上可以听，咋办？<br>ffmpeg -i 晓松奇谈.mp4 -acodec copy -vn output.aac<br>上面的命令，默认mp4的audio codec是aac，如果不是会出错，咱可以暴力一点，不管什么音频，都转为最常见的aac。<br>ffmpeg -i 晓松奇谈.mp4 -acodec aac -vn output.aac</p>
<h3 id="3-提取视频"><a href="#3-提取视频" class="headerlink" title="3.提取视频"></a>3.提取视频</h3><p>我目测有些IT员工，特别是做嵌入式的，比如机顶盒，想debug一下，没有音频的情况下，播放一个视频几天几夜会不会crash，这时候你需要一个纯视频文件，可以这么干。<br>ffmpeg -i input.mp4 -vcodec copy -an output.mp4</p>
<h3 id="4-视频剪切"><a href="#4-视频剪切" class="headerlink" title="4.视频剪切"></a>4.视频剪切</h3><p>经常要测试视频，但是只需要测几秒钟，可是视频却有几个G，咋办？切啊！<br>下面的命令，就可以从时间为00:00:15开始，截取5秒钟的视频。<br>ffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4<br>-ss表示开始切割的时间，-t表示要切多少。上面就是从开始，切5秒钟出来。</p>
<h3 id="5-码率控制"><a href="#5-码率控制" class="headerlink" title="5.码率控制"></a>5.码率控制</h3><p>码率控制对于在线视频比较重要。因为在线视频需要考虑其能提供的带宽。</p>
<p>那么，什么是码率？很简单：<br>bitrate = file size / duration<br>比如一个文件20.8M，时长1分钟，那么，码率就是：<br>biterate = 20.8M bit/60s = 20.8<em>1024\</em>1024*8 bit/60s= 2831Kbps<br>一般音频的码率只有固定几种，比如是128Kbps，<br>那么，video的就是<br>video biterate = 2831Kbps -128Kbps = 2703Kbps。</p>
<p>说完背景了。好了，来说ffmpeg如何控制码率。<br>ffmpg控制码率有3种选择，-minrate -b:v -maxrate<br>-b:v主要是控制平均码率。<br>比如一个视频源的码率太高了，有10Mbps，文件太大，想把文件弄小一点，但是又不破坏分辨率。<br>ffmpeg -i input.mp4 -b:v 2000k output.mp4<br>上面把码率从原码率转成2Mbps码率，这样其实也间接让文件变小了。目测接近一半。<br>不过，ffmpeg官方wiki比较建议，设置b:v时，同时加上 -bufsize<br>-bufsize 用于设置码率控制缓冲器的大小，设置的好处是，让整体的码率更趋近于希望的值，减少波动。（简单来说，比如1 2的平均值是1.5， 1.49 1.51 也是1.5, 当然是第二种比较好）<br>ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4</p>
<p>-minrate -maxrate就简单了，在线视频有时候，希望码率波动，不要超过一个阈值，可以设置maxrate。<br>ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4</p>
<h3 id="6-视频编码格式转换"><a href="#6-视频编码格式转换" class="headerlink" title="6.视频编码格式转换"></a>6.视频编码格式转换</h3><p>比如一个视频的编码是MPEG4，想用H264编码，咋办？<br>ffmpeg -i input.mp4 -vcodec h264 output.mp4<br>相反也一样<br>ffmpeg -i input.mp4 -vcodec mpeg4 output.mp4</p>
<p>当然了，如果ffmpeg当时编译时，添加了外部的x265或者X264，那也可以用外部的编码器来编码。（不知道什么是X265，可以Google一下，简单的说，就是她不包含在ffmpeg的源码里，是独立的一个开源代码，用于编码HEVC，ffmpeg编码时可以调用它。当然了，ffmpeg自己也有编码器）<br>ffmpeg -i input.mp4 -c:v libx265 output.mp4<br>ffmpeg -i input.mp4 -c:v libx264 output.mp4</p>
<h3 id="7-只提取视频ES数据"><a href="#7-只提取视频ES数据" class="headerlink" title="7.只提取视频ES数据"></a>7.只提取视频ES数据</h3><p>这个可能做开发的人会用到，顺便提一下吧。<br>ffmpeg –i input.mp4 –vcodec copy –an –f m4v output.h264</p>
<h3 id="8-过滤器的使用"><a href="#8-过滤器的使用" class="headerlink" title="8.过滤器的使用"></a>8.过滤器的使用</h3><p>这个我在另一篇博客提到了，这里贴一下吧。</p>
<h4 id="8-1-将输入的1920x1080缩小到960x540输出"><a href="#8-1-将输入的1920x1080缩小到960x540输出" class="headerlink" title="8.1 将输入的1920x1080缩小到960x540输出:"></a>8.1 将输入的1920x1080缩小到960x540输出:</h4><p>ffmpeg -i input.mp4 -vf scale=960:540 output.mp4<br>//ps: 如果540不写，写成-1，即scale=960:-1, 那也是可以的，ffmpeg会通知缩放滤镜在输出时保持原始的宽高比。</p>
<h4 id="8-2-为视频添加logo"><a href="#8-2-为视频添加logo" class="headerlink" title="8.2 为视频添加logo"></a>8.2 为视频添加logo</h4><p>比如，我有这么一个图片</p>
<p>想要贴到一个视频上，那可以用如下命令：<br>./ffmpeg -i input.mp4 -i iQIYI_logo.png -filter_complex overlay output.mp4<br>结果如下所示：</p>
<p>要贴到其他地方？看下面：<br>右上角：<br>./ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4<br>左下角：<br>./ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4<br>右下角：<br>./ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4</p>
<h4 id="8-3-去掉视频的logo"><a href="#8-3-去掉视频的logo" class="headerlink" title="8.3 去掉视频的logo"></a>8.3 去掉视频的logo</h4><p>有时候，下载了某个网站的视频，但是有logo很烦，咋办？有办法，用ffmpeg的delogo过滤器。<br>语法：-vf delogo=x:y:w:h[:t[:show]]<br>x:y 离左上角的坐标<br>w:h logo的宽和高<br>t: 矩形边缘的厚度默认值4<br>show：若设置为1有一个绿色的矩形，默认值0。</p>
<p>ffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4<br>结果如下所示：</p>
<h3 id="9-抓取视频的一些帧，存为jpeg图片"><a href="#9-抓取视频的一些帧，存为jpeg图片" class="headerlink" title="9.抓取视频的一些帧，存为jpeg图片"></a>9.抓取视频的一些帧，存为jpeg图片</h3><p>比如，一个视频，我想提取一些帧，存为图片，咋办？<br>ffmpeg -i input.mp4 -r 1 -q:v 2 -f image2 pic-%03d.jpeg<br>-r 表示每一秒几帧<br>-q:v表示存储jpeg的图像质量，一般2是高质量。<br>如此，ffmpeg会把input.mp4，每隔一秒，存一张图片下来。假设有60s，那会有60张。</p>
<p>60张？什么？这么多？不要不要。。。。。不要咋办？？<br>可以设置开始的时间，和你想要截取的时间呀。<br>ffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg<br>-ss 表示开始时间<br>-t表示共要多少时间。<br>如此，ffmpeg会从input.mp4的第20s时间开始，往下10s，即20~30s这10秒钟之间，每隔1s就抓一帧，总共会抓10帧。</p>
<p>怎么样，好用吧。^^</p>
<h3 id="其他小众的用法"><a href="#其他小众的用法" class="headerlink" title="其他小众的用法"></a><strong>其他小众的用法</strong></h3><p>1.输出YUV420原始数据<br>对于一下做底层编解码的人来说，有时候常要提取视频的YUV原始数据。<br>怎么坐？很简答：<br>ffmpeg -i input.mp4 output.yuv<br>怎么样，是不是太简单啦？！！！哈哈</p>
<p>如果你想问yuv的数据，如何播放，我不会告诉你，RawPlayer挺好用的！！</p>
<p>那如果我只想要抽取某一帧YUV呢？<br>简单，你先用上面的方法，先抽出jpeg图片，然后把jpeg转为YUV。<br>比如：<br>你先抽取10帧图片。<br>ffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg<br>结果：</p>
<p><code>-rw-rw-r-- 1 chenxf chenxf    296254  7月 20 16:08 pic-001.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    300975  7月 20 16:08 pic-002.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    310130  7月 20 16:08 pic-003.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    268694  7月 20 16:08 pic-004.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    301056  7月 20 16:08 pic-005.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    293927  7月 20 16:08 pic-006.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    340295  7月 20 16:08 pic-007.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    430787  7月 20 16:08 pic-008.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    404552  7月 20 16:08 pic-009.jpeg</code><br><code>-rw-rw-r-- 1 chenxf chenxf    412691  7月 20 16:08 pic-010.jpeg</code></p>
<p>然后，你就随便挑一张，转为YUV:<br>ffmpeg -i pic-001.jpeg -s 1440x1440 -pix_fmt yuv420p xxx3.yuv<br>如果-s参数不写，则输出大小与输入一样。</p>
<p>当然了，YUV还有yuv422p啥的，你在-pix_fmt 换成yuv422p就行啦！</p>
<ol start="2">
<li>H264编码profile &amp; level控制<br>背景知识<br>先科普一下profile&amp;level吧，知道的请飘过。（这里讨论最常用的H264）<br>H.264有四种画质级别,分别是baseline, extended, main, high：<br>　　1、Baseline Profile：基本画质。支持I/P 帧，只支持无交错（Progressive）和CAVLC；<br>　　2、Extended profile：进阶画质。支持I/P/B/SP/SI 帧，只支持无交错（Progressive）和CAVLC；(用的少)<br>　　3、Main profile：主流画质。提供I/P/B 帧，支持无交错（Progressive）和交错（Interlaced），<br>　　　 也支持CAVLC 和CABAC 的支持；<br>　　4、High profile：高级画质。在main Profile 的基础上增加了8x8内部预测、自定义量化、 无损视频编码和更多的YUV 格式；<br>H.264 Baseline profile、Extended profile和Main profile都是针对8位样本数据、4:2:0格式(YUV)的视频序列。在相同配置情况下，High profile（HP）可以比Main profile（MP）降低10%的码率。<br>根据应用领域的不同，Baseline profile多应用于实时通信领域，Main profile多应用于流媒体领域，High profile则多应用于广电和存储领域。</li>
</ol>
<p>下图清楚的给出不同的profile&amp;level的性能区别。<br>profile</p>
<p>level</p>
<p>2.1 ffmpeg如何控制profile&amp;level<br>举3个例子吧<br>ffmpeg -i input.mp4 -profile:v baseline -level 3.0 output.mp4</p>
<p>ffmpeg -i input.mp4 -profile:v main -level 4.2 output.mp4</p>
<p>ffmpeg -i input.mp4 -profile:v high -level 5.1 output.mp4</p>
<p>如果ffmpeg编译时加了external的libx264，那就这么写：<br>ffmpeg -i input.mp4 -c:v libx264 -x264-params “profile=high:level=3.0” output.mp4</p>
<p>从压缩比例来说，baseline&lt; main &lt; high，对于带宽比较局限的在线视频，可能会选择high，但有些时候，做个小视频，希望所有的设备基本都能解码（有些低端设备或早期的设备只能解码baseline），那就牺牲文件大小吧，用baseline。自己取舍吧！</p>
<p>苹果的设备对不同profile的支持。</p>
<p>2.2. 编码效率和视频质量的取舍(preset, crf)<br>除了上面提到的，强行配置biterate，或者强行配置profile/level，还有2个参数可以控制编码效率。<br>一个是preset，一个是crf。<br>preset也挺粗暴，基本原则就是，如果你觉得编码太快或太慢了，想改改，可以用profile。<br>preset有如下参数可用：</p>
<p>ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow and placebo.<br>编码加快，意味着信息丢失越严重，输出图像质量越差。</p>
<p>CRF(Constant Rate Factor): 范围 0-51: 0是编码毫无丢失信息, 23 is 默认, 51 是最差的情况。相对合理的区间是18-28.<br>值越大，压缩效率越高，但也意味着信息丢失越严重，输出图像质量越差。</p>
<p>举个例子吧。<br>ffmpeg -i input -c:v libx264 -profile:v main -preset:v fast -level 3.1 -x264opts crf=18<br>(参考自：<a class="link"   href="https://trac.ffmpeg.org/wiki/Encode/H.264" >https://trac.ffmpeg.org/wiki/Encode/H.264<i class="fas fa-external-link-alt"></i></a>)</p>
<p>2.3. H265 (HEVC)编码tile&amp;level控制<br>背景知识<br>和H264的profile&amp;level一样，为了应对不同应用的需求，HEVC制定了“层级”(tier) 和“等级”(level)。<br>tier只有main和high。<br>level有13级，如下所示：</p>
<p>不多说，直接给出怎么用。（supposed你用libx265编码）<br>ffmpeg -i input.mp4 -c:v libx265 -x265-params “profile=high:level=3.0” output.mp4</p>
<p>原文链接：<a class="link"   href="https://blog.csdn.net/newchenxf/article/details/51384360" >https://blog.csdn.net/newchenxf/article/details/51384360<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 学习笔记</title>
    <url>/2020/11/04/notepad/read/Tomcat/</url>
    <content><![CDATA[<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="connector"><a href="#connector" class="headerlink" title="connector"></a>connector</h3><p>connector 在解析完了http 协议之后会调用 containner 的 invoke 方法！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connector.getContainer().invoke(request, response);</span><br></pre></td></tr></table></figure>

<p>接下来看是 container 容器的 invoke 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    pipeline.invoke(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看容器的实现方法！</p>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>servlet 容器是用来处理请求servlet 资源，并为Web 客户端填充response 对象的模块。<br>servlet 容器是org.apache.catalina.Container 接口的实例。</p>
<h4 id="Container-接口"><a href="#Container-接口" class="headerlink" title="Container 接口"></a>Container 接口</h4><p>在Tomcat 中，共有4 种类型的容器，分别是： Engine 、Host 、Context 和Wrapper</p>
<ul>
<li>Engine, 表示整个Catalina servlet 引擎</li>
<li>Host: 表示包含有一个或多个Context 容器的虚拟主机</li>
<li>Context: 表示一个Web 应用程序。一个Contex t 可以有多个Wrapper</li>
<li>Wrapper: 表示一个独立的servlet </li>
</ul>
<p>Tomcat 中的servlet 容器必须要实现org.apache.catalina.Container 接口。</p>
<h4 id="管道任务"><a href="#管道任务" class="headerlink" title="管道任务"></a>管道任务</h4><p>管道包含该servlet 容器将要调用的任务。一个阀表示一个具体的执行任务。在servlet 容器<br>的管道中，有一个基础阀，但是，可以添加任意数量的阀。阀的数量指的是额外添加的阀数量，<br>即，不包括基础阀。</p>
<p>Tomcat 中使用内部类来实现遍历管道， 引人接口org.apache.catalina.ValveContext。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePipeline</span> <span class="keyword">implements</span> <span class="title">Pipeline</span>, <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The basic Valve (if any) associated with this Pipeline.</span></span><br><span class="line">  <span class="keyword">protected</span> Valve basic = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// The Container with which this Pipeline is associated.</span></span><br><span class="line">  <span class="keyword">protected</span> Container container = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// the array of Valves</span></span><br><span class="line">  <span class="keyword">protected</span> Valve valves[] = <span class="keyword">new</span> Valve[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// Invoke the first Valve in this pipeline for this request</span></span><br><span class="line">   (<span class="keyword">new</span> StandardPipelineValveContext()).invokeNext(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// this class is copied from org.apache.catalina.core.StandardPipeline class&#x27;s</span></span><br><span class="line">  <span class="comment">// StandardPipelineValveContext inner class.</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardPipelineValveContext</span> <span class="keyword">implements</span> <span class="title">ValveContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> stage = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeNext</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> subscript = stage;</span><br><span class="line">      stage = stage + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// Invoke the requested Valve for the current request thread</span></span><br><span class="line">      <span class="keyword">if</span> (subscript &lt; valves.length) &#123;</span><br><span class="line">        valves[subscript].invoke(request, response, <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((subscript == valves.length) &amp;&amp; (basic != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        basic.invoke(request, response, <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">&quot;No valve&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// end of inner class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stage 会不断增加，调用所有的value，每个 value调用 invokeNext即可</p>
<p>先看看各个接口：</p>
<h5 id="Pipline"><a href="#Pipline" class="headerlink" title="Pipline"></a>Pipline</h5><p>对于 Pipeline 接口，首先要提到的一个方法是invoke() 方法， servlet 容器调用invoke(）方法<br>来开始调用管道中的阀和基础阀。通过调用Pipeline 接口的addValve(）方法，可以向管道中添加<br>新的阀，同样，也可以调用removeValve(）方法从管道中删除某个阀。最后，调用setBasic(）方法<br>将基础阀设置到管道中，调用其getBasic(）方法则可以获取基础阀。基础阀是最后调用的阀，负<br>责处理request 对象及其对应的response 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">Pipeline</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">public</span> Valve getBasic()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBasic</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> addVa l <span class="title">ve</span><span class="params">(Valve val ve)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> Valve [ <span class="function">J get <span class="title">Valves</span> <span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> voi d <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeValve</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h5><p>阀是Valve 接口的实例，用来处理接收到的请求。该接口有两个方法， invoke(）方法和  getlnfo(）方法。invoke(）方法已经在前面讨论过了， getlnfo(）方法返回阀的实现信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.catalina;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Valve</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response,</span></span></span><br><span class="line"><span class="function"><span class="params">                       ValveContext context)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ValveContext"><a href="#ValveContext" class="headerlink" title="ValveContext"></a>ValveContext</h5><p>该接口有两个方法， invokeNext(）和getlnfo(）。invokeNext(）方法已经在前面讨论过了,getlnfo(）方法会返回ValveContext 的实现信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValveContext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getlnfo</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeNext</span><span class="params">(Request request, Response r esponse)</span></span></span><br><span class="line"><span class="function">	 <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Contained"><a href="#Contained" class="headerlink" title="Contained"></a>Contained</h5><p>阀可以选择是否实现org.apache.catalina.Contained 接口，该接口的实现类可以通过接口中的<br>方法至多与一个servlet 容器相关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.catalina ;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Contained</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span> <span class="params">(Container container)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h4><p>Wrapper 级的servlet 容器是一个org.apache. catalina.Wrapper 接口的实例，<strong>表示一个独立的servlet 定义</strong>。</p>
<p>Wrapper 接口继承自Container 接口，又添加了一些额外的方法。</p>
<p>Wrapper 接口的实现类要负责管理其基础servlet 类的servlet 生命周期，即调用servlet 的init(）、service(）、destroy(）等方法。由千Wrapper 已经是最低级的servlet 容器了，因此不能再向其中添加子容器。若是Wrapper 的addChild(）方法被调用，则抛出IllegalArgumantException 异常。</p>
<p>Wrapper 接口中比较重要的方法是load(） 和allocate(）方法。allocate(）方法会分配一个已<br>经初始化的servlet 实例， 而且 allocate(）方法还要考虑下该servlet 类是否实现了javax .servlet.<br>SingleThreadModel 接口。load(）方法载人并初始化servlet 类。</p>
<h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3>]]></content>
      <categories>
        <category>read</category>
      </categories>
  </entry>
  <entry>
    <title>dubbo</title>
    <url>/2019/05/01/notepad/read/dubbo/</url>
    <content><![CDATA[<h1 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h1><p>[toc]</p>
<h2 id="RPC-基础概念"><a href="#RPC-基础概念" class="headerlink" title="RPC 基础概念"></a>RPC 基础概念</h2><h3 id="基础概念："><a href="#基础概念：" class="headerlink" title="基础概念："></a>基础概念：</h3><h5 id="响应时间-RT"><a href="#响应时间-RT" class="headerlink" title="响应时间(RT)"></a>响应时间(RT)</h5><p>响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。</p>
<p>对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个<strong>游戏软件来说，响应时间小于100毫秒应该是不错的</strong>，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。　</p>
<h5 id="吞吐量-Throughput"><a href="#吞吐量-Throughput" class="headerlink" title="吞吐量(Throughput)"></a>吞吐量(Throughput)</h5><p>​    吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。</p>
<p>​    对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。</p>
<h5 id="QPS每秒查询率-Query-Per-Second"><a href="#QPS每秒查询率-Query-Per-Second" class="headerlink" title="QPS每秒查询率(Query Per Second)"></a>QPS每秒查询率(Query Per Second)</h5><p>　每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）</p>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><h4 id="动态均衡算法："><a href="#动态均衡算法：" class="headerlink" title="动态均衡算法："></a>动态均衡算法：</h4><p>1、<strong>轮询法</strong></p>
<p>将请求按<strong>顺序轮流地分配到每个节点上</strong>，不关心每个节点实际的连接数和当前的系统负载。</p>
<p>优点：简单高效，易于水平扩展，每个节点满足字面意义上的均衡；</p>
<p>缺点：没有考虑机器的性能问题，根据木桶最短木板理论，集群性能瓶颈更多的会受性能差的服务器影响。</p>
<p> <strong>2、随机法</strong></p>
<p>将请求随机分配到各个节点。由概率统计理论得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配，也就是轮询的结果。</p>
<p>优缺点和轮询相似。</p>
<p><strong>3、源地址哈希法</strong></p>
<p>   源地址哈希的思想是根据<strong>客户端的IP地址</strong>，通过<strong>哈希函数</strong>计算得到一个数值，用该数值对服务器节点数进行取模，得到的结果便是要访问节点序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会落到到同一台服务器进行访问。</p>
<p>优点：相同的IP每次落在同一个节点，可以人为干预客户端请求方向，例如灰度发布；</p>
<p>缺点：如果某个节点出现故障，会导致这个节点上的客户端无法使用，<strong>无法保证高可用。</strong>当某一用户成为热点用户，那么会有巨大的流量涌向这个节点，导致冷热分布不均衡，无法有效利用起集群的性能。<strong>所以当热点事件出现时，一般会将源地址哈希法切换成轮询法。</strong></p>
<p><strong>4、加权轮询法</strong></p>
<p>   不同的后端服务器可能机器的配置和当前系统的<strong>负载并不相同，因此它们的抗压能力也不相同</strong>。<strong>给配置高、负载低的机器配置更高的权重</strong>，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
<p>加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。</p>
<p>优点：可以将不同机器的性能问题纳入到考量范围，集群性能最优最大化；</p>
<p>缺点：生产环境复杂多变，服务器抗压能力也无法精确估算，静态算法导致无法实时动态调整节点权重，只能粗糙优化。</p>
<p><strong>5、加权随机法</strong></p>
<p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
<p><strong>6、键值范围法</strong></p>
<p>根据键的范围进行负债，<strong>比如0到10万的用户请求走第一个节点服务器</strong>，10万到20万的用户请求走第二个节点服务器……以此类推。</p>
<p>优点：容易水平扩展，随着用户量增加，可以增加节点而不影响旧数据；</p>
<p>缺点：容易负债不均衡，比如新注册的用户活跃度高，旧用户活跃度低，那么压力就全在新增的服务节点上，旧服务节点性能浪费。而且也容易单点故障，无法满足高可用。</p>
<h4 id="动态均衡算法：-1"><a href="#动态均衡算法：-1" class="headerlink" title="动态均衡算法："></a>动态均衡算法：</h4><p><strong>1、最小连接数法</strong></p>
<p>根据每个节点当前的连接情况，动态地选取其中<strong>当前积压连接数最少的一个节点处理当前请求</strong>，尽可能地提高后端服务的利用效率，将请求合理地分流到每一台服务器。俗称闲的人不能闲着，大家一起动起来。</p>
<p>优点：动态，根据节点状况实时变化；</p>
<p>缺点：提高了复杂度，每次连接断开需要进行计数；</p>
<p>实现：将连接数的倒数当权重值。</p>
<p><strong>2、最快响应速度法</strong></p>
<p>根据请求的响应时间，来动态调整每个节点的权重，将<strong>响应速度快的服务节点分配更多的请求</strong>，响应速度慢的服务节点分配更少的请求，俗称能者多劳，扶贫救弱。</p>
<p>优点：动态，实时变化，控制的粒度更细，跟灵敏；</p>
<p>缺点：复杂度更高，每次需要计算请求的响应速度；</p>
<p>实现：可以根据响应时间进行打分，计算权重。</p>
<p><strong>3、观察模式法</strong></p>
<p>观察者模式是综合了<strong>最小连接数和最快响应度</strong>，同时考量这两个指标数，进行一个权重的分配。</p>
]]></content>
      <categories>
        <category>read</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>tinhttpd</title>
    <url>/2019/05/18/notepad/read/tinhttpd/</url>
    <content><![CDATA[<h1 id="tinhttpd"><a href="#tinhttpd" class="headerlink" title="tinhttpd"></a>tinhttpd</h1><p><a class="link"   href="https://www.cnblogs.com/nengm1988/p/7816618.html" >https://www.cnblogs.com/nengm1988/p/7816618.html<i class="fas fa-external-link-alt"></i></a></p>
<p>不断创建线程接受连接， 并解析http，解析完了之后，创建多个进程处理，每个子进程处理然后发送给父进程， 这里把处理和回复解耦， 处理的子进程可以调用其它的服务器，然后接受数据通过管道发给父进程， 父进程再返回给浏览器</p>
<p><img src="C:%5CUsers%5CFirefly%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200426210029601.png" alt="image-20200426210029601"></p>
]]></content>
      <categories>
        <category>read</category>
      </categories>
  </entry>
  <entry>
    <title>语言特性</title>
    <url>/2019/03/09/notepad/read/%E5%8A%A8%E6%80%81%E6%80%A7%E4%B8%8E%E9%9D%99%E6%80%81%E6%80%A7%E3%80%81%E5%BC%BA%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%B1%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a><center>语言特性</center></h2><p>关于语言特性的定义总是弄混，写篇博客记录一下！  彻底理清！</p>
<h3 id="强类型与弱类型"><a href="#强类型与弱类型" class="headerlink" title="强类型与弱类型"></a>强类型与弱类型</h3><ul>
<li>强类型：</li>
</ul>
<p>每个变量和对象都必须声明类型，在编译时确定好类型了，执行时不能更改。</p>
<p>偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double。</p>
<ul>
<li>弱类型：</li>
</ul>
<p>编译时不确定类型，执行时根据语义确定是哪种类型。通俗地说，弱类型偏向于容忍<strong>隐式转换</strong>，把不同类型的变量放在一起运算。</p>
<h3 id="动态性与静态性"><a href="#动态性与静态性" class="headerlink" title="动态性与静态性"></a>动态性与静态性</h3><ul>
<li>静态类型：</li>
</ul>
<p>编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。（编译不过）</p>
<ul>
<li>动态类型：</li>
</ul>
<p>编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。</p>
<p>一些编程语言的总结：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/f.png"></p>
<p>刚好每种类型的语言都有了解过！</p>
<ul>
<li>c / c ++  (弱类型和静态)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">1.0</span>; <span class="comment">//(可以自动向下转型， 1.0 -&gt; 1)  弱类型</span></span><br><span class="line">a = <span class="number">1.0</span>         <span class="comment">//自动转型，a已经是int型的了， 已经确定了类型，上一句已经显示声明了</span></span><br><span class="line"><span class="comment">// 再来看看20世纪的c语言 -- go</span></span><br><span class="line">a := <span class="number">10</span>			<span class="comment">//隐式声明， 声明为int型的变量， 不能变成其它类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>java（强类型和静态）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">1.0</span> <span class="comment">// error！！！  java 是强类型，不支持自动隐式转型</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="keyword">int</span>(<span class="number">1.0</span>); <span class="comment">// 强类型， 不愿意自动转换， 强行给你转了</span></span><br><span class="line">a = <span class="keyword">float</span>(<span class="number">1</span>) <span class="comment">//error 静态的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>python（强类型和动态）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1.0</span> + <span class="number">1</span>		</span><br><span class="line">a = <span class="number">1</span>   + <span class="number">1.0</span>    <span class="comment"># 这两种python都把a当做  float， 这不是弱类型吗？？？</span></span><br><span class="line">a = <span class="string">&quot;1&quot;</span> + <span class="number">1.0</span>    <span class="comment"># 这可就不行了， 类型相差太大， 从图中也可以看出， python 放到了接近中线的地方</span></span><br><span class="line">a = <span class="number">1</span>            <span class="comment"># a 又可以换类型， 换成int型的了！！！   动态性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>js（弱类型和动态）</li>
</ul>
<p><strong>js是世界上最强大的语言！</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1.01123</span> + <span class="number">1</span>   		</span><br><span class="line">a  = <span class="number">1.0</span> + <span class="string">&quot;1&quot;</span>			<span class="comment">// 1.0 由于弱类型转成string， 然后a有动态性 number类型转成string了	</span></span><br></pre></td></tr></table></figure>



<p>总结： java是最垃圾的语言！</p>
<p>当然静态语言也有优势， 类型的检查由程序员来检查， 而不是运行时由解释器检查， 这样加快了运行的速度！ 上面我说谁最强谁最弱是针对语言特性来说的，静态语言还有一个好处就是更加地安全，当项目庞大的时候， 可能就不知道这个变量是哪来的，用来干什么的了， 容易混用。</p>
<p>强类型不容易混乱数据， 比如当式子复杂的时候，有可能隐式转换类型失败，类型不对，在c++ 会经常遇到！</p>
]]></content>
      <categories>
        <category>read</category>
      </categories>
  </entry>
  <entry>
    <title>conda</title>
    <url>/2018/03/28/notepad/tools/conda/</url>
    <content><![CDATA[<p>更换清华源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --append channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/fastai/</span><br><span class="line">conda config --append channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config --append channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索时显示通道地址</span></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate py37</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activate &#x2F;&#x2F; 切换到base环境</span><br><span class="line">activate name &#x2F;&#x2F; 切换到name环境</span><br><span class="line">conda create -n learn python&#x3D;3 &#x2F;&#x2F; 创建一个名为learn的环境并指定python版本为3(的最新版本)</span><br><span class="line">conda env list &#x2F;&#x2F; 列出conda管理的所有环境</span><br><span class="line">conda list &#x2F;&#x2F; 列出当前环境的所有包</span><br><span class="line">conda install requests 安装requests包</span><br><span class="line">conda remove requests 卸载requets包</span><br><span class="line">conda remove -n learn --all &#x2F;&#x2F; 删除learn环境及下属所有包</span><br><span class="line">conda update requests 更新requests包</span><br><span class="line">conda env export &gt; environment.yaml &#x2F;&#x2F; 导出当前环境的包信息</span><br><span class="line">conda env create -f environment.yaml &#x2F;&#x2F; 用配置文件创建新的虚拟环境</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2018/09/28/notepad/tools/docker/</url>
    <content><![CDATA[<p>docker的使用步骤：</p>
<ol>
<li>安装 Docker</li>
<li>去Docker仓库找到这个软件对应的镜像</li>
<li>使用Docker运行这个镜像，这个镜像就会生成一个Docker容器</li>
<li>对容器的启动停止就对软件启动和重启</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>内核版本： 3.10 以上</p>
<p><code>uname -r</code></p>
<p>安装Docker：</p>
<p>安装： <code>yum install docker</code></p>
<p>启动：<code>systemctl start docker</code> </p>
<p>查看版本：<code>docker -v</code></p>
<p>开机自启：<code>systemctl enable docker</code></p>
<p>停止：<code>systemctl stop docker</code></p>
<p>查找： <code>docker search name</code></p>
<p>下载：<code>docker pull mysql</code></p>
<p>查看所有镜像：  <code>docker images</code></p>
<p>删除：<code>docker rmi ID</code></p>
<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><p>软件镜像（QQ）&gt;&gt; 运行镜像 &gt;&gt; 产生一个容器（运行的QQ）</p>
<p>运行  <code>docker --name myname -d name(-d 后台)</code></p>
<p>查看已经运行  <code>docker ps</code></p>
<p>停止容器： <code>docker stop ID</code></p>
<p>启动容器： <code>docker start ID</code></p>
<p>映射端口：<code>docker run -d -p port:port   name</code></p>
<p>查看日志： <code>docker logs name</code></p>
<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p><code>docker pull mysql</code></p>
<p><code>docker run -p port:port --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql </code> </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2019/09/28/notepad/tools/git/</url>
    <content><![CDATA[<p>Git常用操作，一文打尽<br><img src="./../images/git_all_01.png"></p>
<h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><ul>
<li>git clone url 克隆远程版本库</li>
<li>git init 初始化本地版本库</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li>git config –global user.name ‘chengcp’ 配置global级别的用户名</li>
<li>git config –global user.email ‘1326895569@qq.com’ 配置global级别的邮箱</li>
<li>git config –global -l 查看global级别的配置列表</li>
<li>git config –global –unset user.name 删除用户名</li>
<li>git config –global alias.last ‘log -1 HEAD’ 配置last别名，使用git last将显示最近的一次提交记录</li>
</ul>
<h3 id="添加和删除文件"><a href="#添加和删除文件" class="headerlink" title="添加和删除文件"></a>添加和删除文件</h3><ul>
<li>git add file1 file2 添加指定文件到暂存区</li>
<li>git add dir 添加指定目录到暂存区</li>
<li>git add . 添加当前目录的所有文件到暂存区</li>
<li>git mv oldname newname 对一个已经追踪过的文件进行改名，同时加入暂存区</li>
<li>git rm file1 file2 删除工作区文件，同时将这次删除放入暂存区</li>
<li>git rm –cached file 停止追踪指定文件，但该文件会保留在工作区；tracked变成untracked</li>
</ul>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><ul>
<li>git commit file1 file 2 -m message 提交暂存区指定文件到本地仓库</li>
<li>git commit -m message 提交暂存区所有文件到本地仓库</li>
<li>git commit -a -m message 自动暂存所有已经追踪过的文件，且提交到本地仓库<br>git commit –amend -m message 使用一次新的提交，替代上次提交 </li>
</ul>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul>
<li>git branch 查看所有本地分支</li>
<li>git branch –r 查看所有远程分支</li>
<li>git branch –a 查看所有远程和本地分支</li>
<li>git branch –v 查看本地所有分支最新一次提交信息</li>
<li>git branch [branch] 新建分支</li>
<li>git checkout –b [branch] 新建一个分支，并且切换过去</li>
<li>git branch [branch] [commit] 基于某次提交，建立一个分支</li>
<li>git branch –track [branch] [remote-branch] 建立一个分支，并且与远程分支建立追踪关系</li>
<li>git branch –set-upstream [branch] [remote-branch] 在现有的本地分支和远程分支之间建立追踪关系</li>
<li>git branch –m [old-branch] [new-branch] 重命名分支</li>
<li>git merge [branch] 把指定分支合并到当前分支</li>
<li>git chery-pick [commit] [commit] 选择提交，合并进当前分支</li>
<li>git branch –d [branch] 删除本地分支</li>
<li>git push origin –d [branch] 删除远程分支</li>
<li>git checkout [branch] 切换分支</li>
<li>git checkout - 切换到上一个最近使用过的分支</li>
</ul>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul>
<li>git tag 列出所有标签</li>
<li>git show [tag] 查看指定标签信息</li>
<li>git tag [tag] 给最近一次提交打一个标签</li>
<li>git tag [tag] [commit] 在某次提交上打一个标签</li>
<li>git tag –d [tag] 删除本地指定标签</li>
<li>git push origin –d tag [tag] 删除远程的标签</li>
<li>git push origin [tag] 推送指定标签</li>
<li>git push origin –tags 推送所有标签</li>
</ul>
<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><ul>
<li>git status 查看文件状态</li>
<li>git help [command] 获取帮助文档</li>
<li>git [command] –help 获取帮助文档</li>
<li>git log 查看当前分支的提交记录</li>
<li>git log –all 查看所有分支的提交记录</li>
<li>git log -5 –oneline –graph 查看最近5次提交记录，以单行、树状图形式显示</li>
<li>git reflog 查看本地所有变更记录</li>
<li>git diff 查看工作区和暂存区的差异</li>
<li>git diff – file 某个文件在工作区和暂存区的差异</li>
<li>git diff HEAD 工作区和最新一次提交的差异</li>
<li>git diff –cached 暂存区和HEAD的差异</li>
<li>git diff branch_a branch_b – file 某文件在两个分支间的差异</li>
</ul>
<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><ul>
<li>git remote -v 查看所有远程仓库</li>
<li>git ls-remote origin 查看远程仓库引用列表</li>
<li>git remote show origin 查看远程仓库信息</li>
<li>git fetch origin 拉取远程仓库最新提交</li>
<li>git pull origin master 拉取远程master，并且合并到本地当前分支</li>
<li>git remote add upstream url 添加一个新的远程仓库，命名为upstream</li>
<li>git push origin master 推送到远程origin的master分支</li>
<li>git push origin –all 推送所有分支到远程仓库</li>
<li>git remote prune origin 删除远程仓库中不存在的分支</li>
</ul>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul>
<li>git reset –soft HEAD 回滚到指定版本，保留工作区和暂存区</li>
<li>git reset –mixed HEAD 回滚到指定版本，保留工作区，清空暂存区；–mixed是默认参数，即等同于git reset HEAD</li>
<li>git reset –hard HEAD 回滚到指定版本，清空工作区和暂存区</li>
<li>git reset HEAD – file 清空暂存区中某个文件的修改</li>
<li>git checkout – file 检出暂存区的文件到工作目录</li>
<li>git checkout . 检出暂存区的所有文件到工作目录</li>
<li>git revert HEAD~ 2 回滚到2个祖先提交的版本，同时产生新的提交记录</li>
<li>git revert –continue 冲突解决，且把修改提交到暂存区后执行回滚，生成一个新的提交</li>
<li>git revert –abort 取消回滚，回到之前的状态</li>
</ul>
<h3 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h3><ul>
<li>git stash 将工作区和暂存区的变更保存到储藏堆栈中，同时工作区和暂存区恢复到HEAD一样</li>
<li>git stash list 查看储藏列表</li>
<li>git stash pop 应用最近的一次储藏，并且从储藏栈中移除该条记录</li>
<li>git stash apply stash@{0} 应用最近的一次储藏，不移除记录；等同于 git stash apply</li>
<li>git stash pop –index 应用最近一次储藏，–index表示暂存区的变更也会更新，否则只更新工作区变更</li>
<li>git stash drop stash@{0} 移除储藏记录</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2018/02/28/notepad/tools/maven/</url>
    <content><![CDATA[<h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><p>以下的命令会按顺序执行，后面命令会调用前面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure>

<p>把编译好的类清除掉， 因为每个开发环境不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure>

<p>编译主要的类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure>

<p>编译测试的类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure>

<p>把工程打包成jar 包</p>
<p>编译测试类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>

<p>执行上面的所有命令， 并且放入本地仓库中</p>
<p>maven工程可以直接使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tomcat:run </span><br></pre></td></tr></table></figure>

<p>直接使用tomcat 运行项目</p>
<p>windows安装：</p>
<p>首先， 下载可执行文件：<a class="link"   href="http://maven.apache.org/download.cgi" >http://maven.apache.org/download.cgi<i class="fas fa-external-link-alt"></i></a></p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209203336.png"></p>
<p> 下载后解压记住路径， 然后添加系统变量和环境变量。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209203517.png"></p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209203615.png"></p>
<p>最后测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn -version</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209203655.png"></p>
<p><strong>本地仓库</strong>:  使用时先在本地找依赖， 如果没有就去网络找！网络找到后会放在这里</p>
<p>默认在： users / {username}  / .m2</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209204252.png"></p>
<p>在目录下更改 <strong>本地仓库</strong> 的位置: <code>&#123;M2_HOME&#125;\conf\setting.xml</code>, 搜索 LocalResposity，把注释取消掉</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200209204658.png"></p>
<p>maven 在本地的找不到依赖就去网络找。</p>
<ul>
<li>首先,去自定义的远程仓库找,  在 pom.xml 定义自己公司的仓库：</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;mirrors&gt;</span></span><br><span class="line">    <span class="attr">&lt;mirror&gt;</span></span><br><span class="line">        <span class="attr">&lt;id&gt;nexus-aliyun&lt;/id&gt;</span></span><br><span class="line">        <span class="attr">&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span></span><br><span class="line">        <span class="meta">&lt;name&gt;Nexus</span> <span class="string">aliyun&lt;/name&gt;</span></span><br><span class="line">        <span class="meta">&lt;url&gt;</span> <span class="string">｛url｝&lt;/url&gt;</span></span><br><span class="line">    <span class="meta">&lt;/mirror&gt;</span> <span class="string"></span></span><br><span class="line">  <span class="attr">&lt;/mirrors&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>然后，自定义的远程仓库没有，最后maven 会在中心远程仓库找，仓库在国外， 更换阿里的！<code>.\conf\setting.xml</code></li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;mirrors&gt;</span></span><br><span class="line">    <span class="attr">&lt;mirror&gt;</span></span><br><span class="line">        <span class="attr">&lt;id&gt;nexus-aliyun&lt;/id&gt;</span></span><br><span class="line">        <span class="attr">&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span></span><br><span class="line">        <span class="meta">&lt;name&gt;Nexus</span> <span class="string">aliyun&lt;/name&gt;</span></span><br><span class="line">        <span class="meta">&lt;url&gt;http</span>:<span class="string">//maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line">    <span class="meta">&lt;/mirror&gt;</span> <span class="string"></span></span><br><span class="line">  <span class="attr">&lt;/mirrors&gt;</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯</title>
    <url>/2019/12/28/notepad/algorithm/exercise/Backtracking/</url>
    <content><![CDATA[<h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><h4 id="面试题-08-04-幂集"><a href="#面试题-08-04-幂集" class="headerlink" title="面试题 08.04. 幂集"></a><a class="link"   href="https://leetcode-cn.com/problems/power-set-lcci/" >面试题 08.04. 幂集<i class="fas fa-external-link-alt"></i></a></h4><p>幂集。编写一种方法，返回某集合的所有子集。集合中<strong>不包含重复的元素</strong>。</p>
<p>说明：解集不能包含重复的子集。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入： nums &#x3D; [1,2,3]</span><br><span class="line"> 输出：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>分析： 经典双 DFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> vint = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> vvint = <span class="built_in">vector</span>&lt;vint&gt;;</span><br><span class="line">    vvint ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        dfs(vint&#123;&#125;,<span class="number">0</span>,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vint cur, <span class="keyword">int</span> curi, vint&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curi &gt;= nums.size())&#123;</span><br><span class="line">            ans.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(cur,curi + <span class="number">1</span>,nums);</span><br><span class="line">        cur.push_back(nums[curi]);</span><br><span class="line">        dfs(cur,curi + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a><a class="link"   href="https://leetcode-cn.com/problems/restore-ip-addresses/" >93. 复原IP地址<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 <code>&#39;.&#39; </code>分隔。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;25525511135&quot;</span><br><span class="line">输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> ip)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = stoi(ip);</span><br><span class="line">        <span class="keyword">if</span> (val &gt; <span class="number">255</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ip.size() &gt;= <span class="number">2</span> &amp;&amp; ip[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="comment">//首先判断剩余的位数，是不是还能满足要求，比如25525511135，若2.5.5.25511135显然不满足，这可以预判</span></span><br><span class="line">    <span class="comment">//4组，每组最多3位数字</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = (<span class="number">4</span> - path.size()) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.size() - pos &gt; maxLen)    <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == <span class="number">4</span> &amp;&amp; pos == s.size()) &#123;</span><br><span class="line">            <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                ans += path[i];</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">3</span>)    ans += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯算法的典型模式，循环递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; s.size() &amp;&amp; i &lt;= pos + <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> ip = s.substr(pos, i - pos+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!isValid(ip))    <span class="keyword">continue</span>;</span><br><span class="line">            path.push_back(ip);</span><br><span class="line">            dfs(s, i + <span class="number">1</span>, path, res);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找3个.的位置,每个.之前组成的的数值必须要小于255，且以0开头的除非数字是0本身，否则也是非法</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (s.size() == <span class="number">0</span> || s.size() &lt; <span class="number">4</span>)    <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;<span class="comment">//存储从根开始的到叶子节点的满足条件的路径,因为最多3位数字一组，所以同一层横向循环时尝试最多3个位的长度</span></span><br><span class="line">        dfs(s, <span class="number">0</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="面试题-08-08-有重复字符串的排列组合"><a href="#面试题-08-08-有重复字符串的排列组合" class="headerlink" title="面试题 08.08. 有重复字符串的排列组合"></a><a class="link"   href="https://leetcode-cn.com/problems/permutation-ii-lcci/" >面试题 08.08. 有重复字符串的排列组合<i class="fas fa-external-link-alt"></i></a></h4><p>有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;qqe&quot;</span><br><span class="line">输出：[&quot;eqq&quot;,&quot;qeq&quot;,&quot;qqe&quot;]</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> vstr = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">    vstr ans;</span><br><span class="line">    <span class="built_in">string</span> S;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sort(S.begin(), S.end());</span><br><span class="line">        <span class="keyword">this</span>-&gt;S = S;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> size = S.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(size,<span class="number">0</span>)</span></span>;</span><br><span class="line">        search(S.size(),  <span class="built_in">string</span>&#123;&#125;, visited);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> len, <span class="built_in">string</span> cstr, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cstr.size()  &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; cstr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(cstr.size() == len)&#123;</span><br><span class="line">            ans.push_back(cstr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>((i &gt; <span class="number">0</span>) &amp;&amp; S[i] == S[i - <span class="number">1</span>] &amp;&amp; visited[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                cstr+=S[i];</span><br><span class="line">                search(len, cstr , visited);</span><br><span class="line">                cstr.pop_back();</span><br><span class="line">                visited[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a class="link"   href="https://leetcode-cn.com/problems/combination-sum-ii/" >40. 组合总和 II<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        helper(candidates, target, <span class="number">0</span>, v);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.emplace_back(now); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 无解</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 相同层数相同数字只用一次</span></span><br><span class="line">            now.emplace_back(candidates[i]);</span><br><span class="line">            helper(candidates, target-candidates[i], i+<span class="number">1</span>, now);</span><br><span class="line">            now.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a class="link"   href="https://leetcode-cn.com/problems/permutations-ii/" >47. 全排列 II<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sol;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dfs(used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sol.size() == nums.size())&#123;</span><br><span class="line">            res.push_back(sol);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//当前值用过了 或 </span></span><br><span class="line">            <span class="comment">//当前值等于前一个值： 两种情况：</span></span><br><span class="line">            <span class="comment">//1 nums[i-1] 没用过 说明回溯到了同一层 此时接着用num[i] 则会与 同层用num[i-1] 重复</span></span><br><span class="line">            <span class="comment">//2 nums[i-1] 用过了 说明此时在num[i-1]的下一层 相等不会重复</span></span><br><span class="line">            <span class="keyword">if</span>(used[i] || (i&gt;<span class="number">0</span> &amp;&amp; !used[i<span class="number">-1</span>] &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]))&#123;<span class="comment">//用过了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sol.push_back(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(used);</span><br><span class="line">            sol.pop_back();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;<span class="comment">//记录每一次选择后数组状态，包括最终答案</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;<span class="comment">//选择完每一个数组后并入答案集</span></span><br><span class="line">    <span class="keyword">int</span> len;<span class="comment">//输入数组元素数量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        len=nums.size();<span class="comment">//更新len</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;nums=nums;<span class="comment">//更新nums</span></span><br><span class="line">        dfs(<span class="number">0</span>);<span class="comment">//开始回溯</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==len)&#123;</span><br><span class="line">            ans.push_back(nums);<span class="comment">//已经排列到len位置，即超出数组范围，这意味着已经完成了排列，将此排列并入答案集合</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp=&#123;&#125;;<span class="comment">//记录该位选择过的元素值，已经选择过的值不再选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;len;++i)&#123;<span class="comment">//n为当前正在选择的位，i为准备要作为n位元素目前的位置</span></span><br><span class="line">            <span class="keyword">if</span>(find(temp.begin(),temp.end(),nums[i])!=temp.end())<span class="keyword">continue</span>;<span class="comment">//已经选择过的值不再选择</span></span><br><span class="line">            swap(nums[n],nums[i]);<span class="comment">//将第i位数字移动到n位，完成该位选择</span></span><br><span class="line">            temp.push_back(nums[n]);<span class="comment">//记录选择，防止选择相等数字产生多余的解</span></span><br><span class="line">            dfs(n+<span class="number">1</span>);<span class="comment">//选择下一位数字</span></span><br><span class="line">            swap(nums[n],nums[i]);<span class="comment">//变为选择之前的状态，重新选择下一位数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a class="link"   href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" >剑指 Offer 38. 字符串的排列<i class="fas fa-external-link-alt"></i></a></h4><p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">permutation2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 去重处理</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; res;</span><br><span class="line">        backtrack2(s, <span class="number">0</span>, res);</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(res.begin(), res.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 回溯函数</span></span><br><span class="line"><span class="comment">     * 使用set函数对字符串字符进行去重，</span></span><br><span class="line"><span class="comment">     * 使用swap函数交换两个字符</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 回溯结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(start == s.size())&#123;</span><br><span class="line">            res.insert(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            <span class="built_in">std</span>::swap(s[i], s[start]);</span><br><span class="line">            <span class="comment">// 进入下一次决策树</span></span><br><span class="line">            backtrack2(s, start+<span class="number">1</span>, res);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            <span class="built_in">std</span>::swap(s[i], s[start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



































]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM_exercise</title>
    <url>/2019/12/28/notepad/algorithm/exercise/HNU_ACM/</url>
    <content><![CDATA[<h1 id="HNU-ACM"><a href="#HNU-ACM" class="headerlink" title="HNU ACM"></a>HNU ACM</h1><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><h3 id="1-Longest-Ordered-Subsequence"><a href="#1-Longest-Ordered-Subsequence" class="headerlink" title="1. Longest Ordered Subsequence"></a>1. Longest Ordered Subsequence</h3><table>
<thead>
<tr>
<th><strong>Problem description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>A numeric sequence of <em>ai</em> is ordered if <em>a1</em> &lt; <em>a2</em> &lt; … &lt; <em>aN</em>. Let the subsequence of the given numeric sequence (<em>a1</em>, <em>a2</em>, …, <em>aN</em>) be any sequence (<em>ai1</em>, <em>ai2</em>, …, <em>aiK</em>), where 1 &lt;= <em>i1</em> &lt; <em>i2</em> &lt; … &lt; <em>iK</em> &lt;= <em>N</em>. For example, sequence (1, 7, 3, 5, 9, 4, 8) has ordered subsequences, e. g., (1, 7), (3, 4, 8) and many others. All longest ordered subsequences are of length 4, e. g., (1, 3, 5, 8).  Your program, when given the numeric sequence, must find the length of its longest ordered subsequence.</td>
</tr>
<tr>
<td><strong>Input</strong></td>
</tr>
<tr>
<td>The first line of input contains the length of sequence N. The second line contains the elements of sequence - N integers in the range from 0 to 10000 each, separated by spaces. 1 &lt;= N &lt;= 1000</td>
</tr>
<tr>
<td><strong>Output</strong></td>
</tr>
<tr>
<td>Output must contain a single integer - the length of the longest ordered subsequence of the given sequence.</td>
</tr>
<tr>
<td><strong>Sample Input</strong></td>
</tr>
<tr>
<td>7</td>
</tr>
<tr>
<td>1 7 3 5 9 4 8</td>
</tr>
<tr>
<td><strong>Sample Output</strong></td>
</tr>
<tr>
<td><code>4 </code></td>
</tr>
<tr>
<td><strong>Problem Source</strong></td>
</tr>
<tr>
<td>HNU Contest</td>
</tr>
</tbody></table>
<p>思路：</p>
<p>dp[i] : 表示以第 i 个字符结尾的最长子上升子序列！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)   <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++)&#123;  <span class="comment">// 对于第 i 个 zifu</span></span><br><span class="line">        tmp  = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt;= a[j]) tmp = max(dp[j] + <span class="number">1</span>, tmp );</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = tmp;</span><br><span class="line">        ans = max(tmp,ans);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="2-Dissatisfying-Lift"><a href="#2-Dissatisfying-Lift" class="headerlink" title="2.Dissatisfying Lift"></a>2.<strong>Dissatisfying Lift</strong></h3><table>
<thead>
<tr>
<th><strong>Problem description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>There’s a building with M floors. The amounts of tenants of every floor are K1, K2, K3, …, Km. One day all the tenants went home together and they took the same lift (suppose the lift was large enough). Because of some reason the lift could only stop on one floor and the tenants must go upstairs or downstairs to their houses. Every tenant went up N floors would make the dissatisfied degree rise N * a + 0.5 * N * (N - 1) degrees, and every tenant went down N floors would make the dissatisfied degree rise N * b + 0.5 * N * (N - 1) degrees. Your task is to tell which floor the lift should stop, in order to make the dissatisfied degree as low as possible.</td>
</tr>
<tr>
<td><strong>Input</strong></td>
</tr>
<tr>
<td>The first line of the input contains a single integer T (1 &lt;= T &lt;= 20), the number of test cases. Then T cases follow. The first line of each test contains M (1 &lt;= M &lt;= 10000), a and b (0 &lt;= a, b &lt;= 100). The second line contains K1, K2, K3, …, Km(0 &lt;= Ki &lt;= 20, i = 1..M).</td>
</tr>
<tr>
<td><strong>Output</strong></td>
</tr>
<tr>
<td>For each test case, print a line containing a single integer, indicating which floor the lift should stop.</td>
</tr>
<tr>
<td><strong>Sample Input</strong></td>
</tr>
<tr>
<td>1</td>
</tr>
<tr>
<td>5 3 2</td>
</tr>
<tr>
<td>1 1 1 1 1</td>
</tr>
<tr>
<td><strong>Sample Output</strong></td>
</tr>
<tr>
<td><code>3</code></td>
</tr>
<tr>
<td><strong>Judge Tips</strong></td>
</tr>
<tr>
<td>Dynamic Programming</td>
</tr>
<tr>
<td><strong>Problem Source</strong></td>
</tr>
<tr>
<td>POJ Monthly</td>
</tr>
</tbody></table>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/2019/12/28/notepad/algorithm/exercise/exercise100/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashFunction</span><span class="params">( <span class="keyword">char</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (key[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	temp = ((temp &lt;&lt; SHIFT) + key[i]) % MAXTABLESIZE;</span><br><span class="line">	++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="101-删除排序数组中的重复项"><a href="#101-删除排序数组中的重复项" class="headerlink" title="101.删除排序数组中的重复项"></a>101.删除排序数组中的重复项</h4><blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
</blockquote>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p>思路： 使用双指针法， 前面的指针判断是否相等！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> guard, ans;</span><br><span class="line">        ans = guard  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(guard + <span class="number">1</span> &lt; nums.size() &amp;&amp; nums[guard] == nums[guard+<span class="number">1</span>])guard++;</span><br><span class="line">            nums[ans++] = nums[guard++];</span><br><span class="line">            <span class="keyword">if</span>(guard == nums.size()) <span class="keyword">break</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2019/12/28/notepad/algorithm/exercise/greedy/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a><center>贪心算法</center></h1><p>贪心方法的一般策略</p>
<p>   问题的一般特征：问题的解是由n个输入的、满足某些事先给定的条件的子集组成。</p>
<p>​    1）一般方法</p>
<p>​    根据题意，选取一种度量标准。然后按照这种度量标准对n个输入排序，并按序一次输入一个量。</p>
<p>​    如果这个输入和当前已构成在这种量度意义下的部分最优解加在一起不能产生一个可行解，则不把此输入加到这部分解中。否则，将当前输入合并到部分解中从而得到包含当前输入的新的部分解。</p>
<p>   2）贪心方法</p>
<p>   这种能够得到某种量度意义下的最优解的分级处理方法称为贪心方法</p>
<h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><blockquote>
<p>N个人在晚上想通过桥。每次最多过去2个人，需要有手电筒。现在只有1个手电筒。每个人过桥的速度都不一样，过桥的时间以慢的为准。<br>你的工作是找到最少的过桥的方法； </p>
<p>输入：<br>首先是n,然后n 行是过桥的时间。<br>人数不超过1000，而且没有人过桥的时间超过100秒；<br>输出：<br>首先输出总共所需最少时间；<br>下面表示过桥的过程（见样例），如果有多种过桥方案，输出其中一种。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每次过桥2个人，希望一起过去的人时间相差最小，所以采用贪心技术。</span><br><span class="line">而且返回的时间要少，所以用时间最少的人返回；</span><br><span class="line"></span><br><span class="line">对于样例 1	2	5	10</span><br><span class="line"></span><br><span class="line">每一组时间相差最小的数有两种选择：</span><br><span class="line">1、可以选择一个最小的1， 每次送每一个人过去再回来。</span><br><span class="line">	1 	10		1和10过去</span><br><span class="line">	1			1 回来</span><br><span class="line">	1 	5			1和5过去</span><br><span class="line">	1			1回来</span><br><span class="line">一共10 + 1 + 5 + 1 &#x3D; 17</span><br><span class="line">2、也可以选两个最小的数来送手电筒</span><br><span class="line">	1	2		1和2过去</span><br><span class="line">	1			1回来</span><br><span class="line">	5	10		5和10 过去</span><br><span class="line">	2			回来</span><br><span class="line">一共2 + 1 + 10 + 2 &#x3D; 15</span><br><span class="line"></span><br><span class="line">那么怎么选用送回手电筒的策略呢？</span><br><span class="line"></span><br><span class="line">结合下面代码看！</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">int</span> s[n];</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">  sort(s, s + n);<span class="comment">// 先排序</span></span><br><span class="line">  <span class="comment">// 选择第一种情况：</span></span><br><span class="line">  <span class="comment">//  s1 = s[i] + s[0] + s[i-1] + s[0]; // 相当于 上面的 10 + 1 + 5 + 1</span></span><br><span class="line">  <span class="comment">// 选择第二种情况</span></span><br><span class="line">  <span class="comment">//  s2 = s[1] + s[0] + s[i] + s[1];	//相当于上面的 2 + 1 + 10 + 2；</span></span><br><span class="line">  <span class="keyword">int</span> t = <span class="number">2</span> * s[<span class="number">1</span>] - s[<span class="number">0</span>];</span><br><span class="line">   <span class="comment">// 先考虑第一种情况  即: s1 &gt; s2, 化简为   s[i-1] &gt; t; </span></span><br><span class="line">  <span class="keyword">for</span> (i = n - <span class="number">1</span>; (i &gt; <span class="number">2</span>) &amp;&amp; (s[i - <span class="number">1</span>] &gt; t); i -= <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n%d\n%d %d\n%d\n&quot;</span>, s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">0</span>], s[i - <span class="number">1</span>], s[i], s[<span class="number">1</span>]);</span><br><span class="line">   <span class="comment">// 在考虑第二种情况</span></span><br><span class="line">  <span class="keyword">for</span> (j = i; j &gt; <span class="number">1</span>; --j) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n%d\n&quot;</span>, s[<span class="number">0</span>], s[j], s[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Radar-Installation"><a href="#Radar-Installation" class="headerlink" title="Radar Installation"></a>Radar Installation</h3><blockquote>
<p>在一个海边建一些雷达，雷达覆盖范围为d为半径的一个圆，所有海岛都需要覆盖在雷达范围内。问题是最少需要建多少雷达站，使得所有的海岛都被覆盖。</p>
<p><strong>Input</strong></p>
<p>The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. </p>
<p> The input is terminated by a line containing pair of zeros </p>
<p><strong>Output</strong></p>
<p>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200502185142.png" alt="image-20200502185150700"></p>
<p>解题思路：</p>
<ul>
<li><p>一、从左往右考虑建雷达站，首先第一个雷达尽量往右建（贪心）以期能覆盖尽可能多的海岛。</p>
</li>
<li><p>二、重复一，一直到所有的海岛都被覆盖到。</p>
</li>
<li><p>三、怎么确定圆心位置。对于每个海岛来说，以海岛为中心，以d为半径画圆，在海岸线上有2个交点。那么第一个右交点就是第一个雷达站位置。</p>
</li>
<li><p>四、解题步骤：首先对于每个海岛，求出它的左右交点，按照右交点、左交点的顺序排序。依次找到最小的右交点，只要左交点比该右交点小，就被该圆覆盖。找到下一个不能被覆盖的左交点。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> left, right;</span><br><span class="line">&#125; Interval;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *c, <span class="keyword">const</span> <span class="keyword">void</span> *d)</span> </span>&#123;  <span class="comment">// 万能指针， c语言的</span></span><br><span class="line">  Interval *a, *b;</span><br><span class="line">  a = (Interval *)c;</span><br><span class="line">  b = (Interval *)d;</span><br><span class="line">  <span class="keyword">if</span> ((*a).right &lt; (*b).right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ((*a).right &gt; (*b).right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ((*a).left &lt; (*b).left) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ((*a).left &gt; (*b).left) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Interval island[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, x, y, dd, m = <span class="number">0</span>, n, d;</span><br><span class="line">  <span class="keyword">double</span> t;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;d), n) &#123;</span><br><span class="line">    dd = d * d;</span><br><span class="line">    <span class="keyword">for</span> (i = j = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="keyword">if</span> (y &gt; d) j = <span class="number">-1</span>;  <span class="comment">// 输入点的y 大于雷达的半径一定无解， 雷达覆盖不到</span></span><br><span class="line">      <span class="keyword">if</span> (j == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      t = <span class="built_in">sqrt</span>(dd - y * y);</span><br><span class="line">      island[i].left = x - t;  <span class="comment">//左右交点， 这一步转换是核心， 大多数这一步想不到</span></span><br><span class="line">      island[i].right = x + t;  <span class="comment">// 转换成一个合适的数据结构来计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/* Sort NMEMB elements of BASE, of SIZE bytes each,</span></span><br><span class="line"><span class="comment">     using COMPAR to perform the comparisons.  */</span></span><br><span class="line">      qsort(island, n, <span class="keyword">sizeof</span>(island[<span class="number">0</span>]), cmp);</span><br><span class="line">      <span class="keyword">for</span> (i = j = <span class="number">1</span>, t = island[<span class="number">0</span>].right; i &lt; n; ++i)<span class="comment">// 贪心， 核心代码</span></span><br><span class="line">        <span class="keyword">if</span> (island[i].left &gt; t) &#123; <span class="comment">// 尽可能往右边建， j 表示个数</span></span><br><span class="line">          t = island[i].right;      <span class="comment">// 不能建了， 只能新开一个</span></span><br><span class="line">          ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, ++m, j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="合并石头"><a href="#合并石头" class="headerlink" title="合并石头"></a>合并石头</h3><blockquote>
<p>有n堆石头， 只能两两合并， 求合成一堆的最小花费。</p>
<p>input</p>
<p>第一行输入 n， 接下来n 行输入每堆石头的重量</p>
</blockquote>
<p>解题思路：</p>
<p>每次选择，最小的两堆合并！ haffman 算法。</p>
<p>极致效率：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// int cmp(const void* a, const void* b) &#123; return (int)(a) - (int)(b); &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 为了不要每次选择 最小的两堆 合并后再次排序， 可以选择两个数组</span></span><br><span class="line"><span class="comment">   * a 存储输入的数据，</span></span><br><span class="line"><span class="comment">   * b  存储合并后的数据</span></span><br><span class="line"><span class="comment">   * 分别用一个标记记录边界</span></span><br><span class="line"><span class="comment">   * haffman 算法的最优求解方法！！！</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">int</span> n, a[<span class="number">10003</span>], b[<span class="number">10000</span>];</span><br><span class="line">  sort(a, a + n);</span><br><span class="line">  <span class="comment">// qsort(a, n, sizeof(a[0]), cmp);</span></span><br><span class="line">  a[n] = a[n + <span class="number">1</span>] = <span class="number">1073741800</span>;   <span class="comment">// 为最后的判断设置的一个最大的数</span></span><br><span class="line">  <span class="keyword">int</span> i, j, k, r, m, c, t;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n;) b[i++] = <span class="number">20001</span>;</span><br><span class="line">  n--;</span><br><span class="line">  <span class="keyword">for</span> (i = j = k = r = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    m = a[j] + a[j + <span class="number">1</span>]; <span class="comment">// 选取原来数组的两个值相加</span></span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; (t = a[j] + b[k])) &#123;   <span class="comment">// 原来数组和合并之后的各选一个</span></span><br><span class="line">      m = t;</span><br><span class="line">      c = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; (t = b[k] + b[k + <span class="number">1</span>])) &#123;<span class="comment">// 都选合并之后的石头堆， k 越大b[k] 一定是递增的</span></span><br><span class="line">      m = t;</span><br><span class="line">      c = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r += b[i] = m;      <span class="comment">// 合并后的记录在 b， 总的花费加上1</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)         <span class="comment">// 移动标记 j -&gt; a,    k -&gt; b;</span></span><br><span class="line">      j += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">1</span>)</span><br><span class="line">      j++, k++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      k += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Sum-of-Factorials"><a href="#Sum-of-Factorials" class="headerlink" title="Sum of Factorials"></a><strong>Sum of Factorials</strong></h3><blockquote>
<p>一个数是否可以表示为阶乘之和</p>
<p>input</p>
<p>9</p>
<p>output</p>
<p>yes</p>
<p>example</p>
<p>9=1!+2!+3!</p>
</blockquote>
<p>因为是超递增序列，所以可以贪心。</p>
<blockquote>
<p>超递增序列： 第n个数 大于 前n - 1个数之和</p>
<p>n! , n^2, 都是超递增序列</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> fact[<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jud</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt;= fact[<span class="number">10</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (n &gt; fact[i])  <span class="comment">// 9的阶乘已经很大了， 从大到小， 只要可以放就放进去</span></span><br><span class="line">      n -= fact[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == fact[i])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; <span class="number">11</span>; ++n)</span><br><span class="line">    fact[n] = n * fact[n - <span class="number">1</span>];  <span class="comment">// 提前计算好每一个数的阶乘</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n &gt;= <span class="number">0</span>) <span class="built_in">printf</span>(jud(n) ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>面试算法题</title>
    <url>/2020/02/28/notepad/algorithm/exercise/interview/</url>
    <content><![CDATA[<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h4 id="面试题-04-10-检查子树"><a href="#面试题-04-10-检查子树" class="headerlink" title="面试题 04.10. 检查子树"></a><a class="link"   href="https://leetcode-cn.com/problems/check-subtree-lcci/" >面试题 04.10. 检查子树<i class="fas fa-external-link-alt"></i></a></h4><p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。</p>
<p>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：t1 &#x3D; [1, 2, 3], t2 &#x3D; [2]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>经典的双递归。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span>     </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t2==<span class="literal">nullptr</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">nullptr</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val) </span><br><span class="line">            <span class="keyword">return</span> (checkSubTree(t1-&gt;left,t2) || checkSubTree(t1-&gt;right,t2));</span><br><span class="line">        <span class="keyword">return</span> (checkSubTree(t1-&gt;left,t2-&gt;left) &amp;&amp; checkSubTree(t1-&gt;right,t2-&gt;right));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="面试题-05-02-二进制数转字符串"><a href="#面试题-05-02-二进制数转字符串" class="headerlink" title="面试题 05.02. 二进制数转字符串"></a><a class="link"   href="https://leetcode-cn.com/problems/bianry-number-to-string-lcci/" >面试题 05.02. 二进制数转字符串<i class="fas fa-external-link-alt"></i></a></h4><p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字不在0和1之间，<strong>或者</strong>无法精确地用32位以内的二进制表示，则打印“ERROR”。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：0.625</span><br><span class="line">输出：&quot;0.101&quot;</span><br></pre></td></tr></table></figure>

<p>计组知识！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">printBin</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;0.&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">30</span>;  <span class="comment">// 若 &quot;0.&quot; 计为两位，i 初始化为 30，若计为 1 位，初始化为 31</span></span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span> &amp;&amp; i--) &#123;</span><br><span class="line">            num *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                res.push_back(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                --num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> res.push_back(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num != <span class="number">0</span> ? <span class="string">&quot;ERROR&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="面试题-02-08-环路检测"><a href="#面试题-02-08-环路检测" class="headerlink" title="面试题 02.08. 环路检测"></a><a class="link"   href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/" >面试题 02.08. 环路检测<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *fir = <span class="keyword">new</span> ListNode(<span class="number">0</span>), *sec = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">delete</span> fir, sec;</span><br><span class="line">        fir = sec = head;</span><br><span class="line">        <span class="keyword">while</span>(sec != <span class="literal">nullptr</span> &amp;&amp; sec-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fir = fir-&gt;next;</span><br><span class="line">            sec = sec-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fir == sec)  <span class="keyword">break</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sec != fir) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        fir = head;</span><br><span class="line">        <span class="keyword">while</span>(fir != sec)&#123;</span><br><span class="line">            fir = fir-&gt;next;</span><br><span class="line">            sec = sec-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="面试题-08-09-括号"><a href="#面试题-08-09-括号" class="headerlink" title="面试题 08.09. 括号"></a><a class="link"   href="https://leetcode-cn.com/problems/bracket-lcci/" >面试题 08.09. 括号<i class="fas fa-external-link-alt"></i></a></h4><p>设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>经典递归题目。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> vstr = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    vstr ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        search(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">string</span>&#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">string</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right || left &gt; n || right &gt; n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == right &amp;&amp; left == n)&#123;</span><br><span class="line">            ans.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        search(left + <span class="number">1</span>, right, cur + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        search(left, right + <span class="number">1</span>, cur + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="面试题-08-05-递归乘法"><a href="#面试题-08-05-递归乘法" class="headerlink" title="面试题 08.05. 递归乘法"></a><a class="link"   href="https://leetcode-cn.com/problems/recursive-mulitply-lcci/" >面试题 08.05. 递归乘法<i class="fas fa-external-link-alt"></i></a></h4><p>递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; 1, B &#x3D; 10</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure>

<p>大的记得放后面， 小的放前面， 不然会 StackOverflow</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A &gt; B) <span class="keyword">return</span> multiply(B, A);</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> B + multiply(A - <span class="number">1</span>, B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="面试题-02-05-链表求和"><a href="#面试题-02-05-链表求和" class="headerlink" title="面试题 02.05. 链表求和"></a><a class="link"   href="https://leetcode-cn.com/problems/sum-lists-lcci/" >面试题 02.05. 链表求和<i class="fas fa-external-link-alt"></i></a></h4><p>给定两个用链表表示的整数，每个节点包含一个数位。 </p>
<p>强行模拟！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carray = <span class="number">0</span>;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* index = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = l1-&gt;val + l2-&gt;val + carray;</span><br><span class="line">            index-&gt;next = <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">            index = index-&gt;next;</span><br><span class="line">            l1 = l1-&gt;next, l2 = l2-&gt;next;</span><br><span class="line">            carray = tmp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = carray + l1-&gt;val;</span><br><span class="line">            index-&gt;next = <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">            index = index-&gt;next;</span><br><span class="line">            carray = tmp / <span class="number">10</span>;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = carray + l2-&gt;val;</span><br><span class="line">            index-&gt;next = <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">            index = index-&gt;next;</span><br><span class="line">            carray = tmp / <span class="number">10</span>;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carray)&#123;</span><br><span class="line">            index-&gt;next = <span class="keyword">new</span> ListNode(carray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a><a class="link"   href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" >面试题 01.07. 旋转矩阵<i class="fas fa-external-link-alt"></i></a></h4><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>上下翻转， 对角线翻转</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 左右交换， 上下交换</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> y = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (y &gt;&gt; <span class="number">1</span>); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; j++)&#123;</span><br><span class="line">                swap(matrix[i][j],matrix[y - i - <span class="number">1</span>][ j ]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                swap(matrix[i][j],matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="面试题-04-05-合法二叉搜索树"><a href="#面试题-04-05-合法二叉搜索树" class="headerlink" title="面试题 04.05. 合法二叉搜索树"></a><a class="link"   href="https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/" >面试题 04.05. 合法二叉搜索树<i class="fas fa-external-link-alt"></i></a></h4><p>实现一个函数，检查一棵二叉树是否为二叉搜索树。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  helper(((<span class="keyword">long</span> <span class="keyword">int</span>)<span class="number">1</span>&lt;&lt;<span class="number">63</span>),~((<span class="keyword">long</span> <span class="keyword">int</span>)<span class="number">1</span>&lt;&lt;<span class="number">63</span>),root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">long</span> mini, <span class="keyword">long</span> maxi, TreeNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val &gt;= maxi || cur-&gt;val &lt;= mini) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(mini,cur-&gt;val,cur-&gt;left) &amp;&amp; helper(cur-&gt;val,maxi, cur-&gt;right);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2019/12/28/notepad/algorithm/exercise/sorting/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>[toc]</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200327222126.png"></p>
<h3 id="insertSort"><a href="#insertSort" class="headerlink" title="insertSort"></a>insertSort</h3><p>将数插到正确的地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> le, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = le; i &lt;= ri; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num[j] &gt; num[i]) &#123;</span><br><span class="line">        index = j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = num[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= index; j--) num[j + <span class="number">1</span>] = num[j];</span><br><span class="line">    num[index] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="selectSort"><a href="#selectSort" class="headerlink" title="selectSort"></a>selectSort</h3><p>选择一个最小的放到前面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> le, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = le; i &lt;= ri; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= ri; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (index == <span class="number">-1</span> || num[j] &lt; num[i]) &#123;</span><br><span class="line">        index = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(num, i, index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="quickSort"><a href="#quickSort" class="headerlink" title="quickSort"></a>quickSort</h3><p>选择一个key ， 把大于key的都放到右边，小于key的放到左边， 递归求解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = num[a];</span><br><span class="line">  num[a] = num[b];</span><br><span class="line">  num[b] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span> *num, <span class="keyword">int</span> le, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (le &gt;= ri) <span class="keyword">return</span>; </span><br><span class="line">  <span class="keyword">int</span> start = le;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = le; i &lt; ri; i++)</span><br><span class="line">    <span class="keyword">if</span> (num[i] &lt; num[ri]) swap(num, i, start++);</span><br><span class="line">  swap(num, start, ri);</span><br><span class="line">  quickSort1(num, le, start - <span class="number">1</span>);</span><br><span class="line">  quickSort1(num, start + <span class="number">1</span>, ri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="mergeSort"><a href="#mergeSort" class="headerlink" title="mergeSort"></a>mergeSort</h3><p>一直拆分， 然后有序合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void mergeSort(int *num, int le, int ri) &#123;</span><br><span class="line">  if (le &gt;&#x3D; ri) return;</span><br><span class="line">  int mid &#x3D; le + ((ri - le) &gt;&gt; 1);</span><br><span class="line">  mergeSort(num, le, mid);</span><br><span class="line">  mergeSort(num, mid + 1, ri);</span><br><span class="line">  int tmp[ri - le + 1];</span><br><span class="line">  int start &#x3D; 0, l &#x3D; le, r &#x3D; mid + 1;</span><br><span class="line">  while (l &lt;&#x3D; mid &amp;&amp; r &lt;&#x3D; ri) &#123;</span><br><span class="line">    if (num[l] &lt; num[r]) tmp[start++] &#x3D; num[l++];</span><br><span class="line">    else tmp[start++] &#x3D; num[r++];</span><br><span class="line">  &#125;</span><br><span class="line">  while (l &lt;&#x3D; mid) tmp[start++] &#x3D; num[l++];</span><br><span class="line">  while (r &lt;&#x3D; ri) tmp[start++] &#x3D; num[r++];</span><br><span class="line">  start &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; le; i &lt;&#x3D; ri; i++) num[i] &#x3D; tmp[start++];  &#x2F;&#x2F; 拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2020/02/24/notepad/algorithm/exercise/string/</url>
    <content><![CDATA[<h1 id="string处理"><a href="#string处理" class="headerlink" title=" string处理 "></a><center> string处理 </center></h1><p>[toc]</p>
<h3 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h3><p>字符串可以看做是一个n进制的表示方式： </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ABC =   A * <span class="number">26</span>^<span class="number">2</span> + B * <span class="number">26</span>^<span class="number">1</span> + C * <span class="number">26</span>^<span class="number">0</span>; </span><br></pre></td></tr></table></figure>

<p>这就简单地转成 10 进制了， 然后在 取余， 让它在整数范围内就ok， 但取余后就会有冲突！</p>
<p>把进制 换为一个 10^7 级别的质数， 和mod 设为 10^9 的一个质素冲突就很小！</p>
<p>首先进制转为很大了， 足以让每一种字符都有一份， mod 也足够大防止取余后的冲突！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">H[i]  = (H[i<span class="number">-1</span>] * p + index(str[i]))% mod</span><br></pre></td></tr></table></figure>

<p>假设 p = 10000019；   mod =1000000007</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">10000019</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashStr</span><span class="params">(<span class="built_in">string</span>&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; a.length(); i++)&#123;</span><br><span class="line">        sum  = (sum * P + a[i] - <span class="string">&#x27;a&#x27;</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; hash num is : &quot;</span> &lt;&lt; hashStr(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="kmp算法（字符串匹配）"><a href="#kmp算法（字符串匹配）" class="headerlink" title="kmp算法（字符串匹配）"></a>kmp算法（字符串匹配）</h3><p>这个算法最大的难点在于next数组的求解， 求解出了next数组，剩下就容易了！</p>
<p>关于next的介绍，看了好久才懂， 看懂了，算法又实现半天也没有实现出来！</p>
<p><a class="link"   href="https://www.cnblogs.com/zhangtianq/p/5839909.html" >https://www.cnblogs.com/zhangtianq/p/5839909.html<i class="fas fa-external-link-alt"></i></a> （这是介绍最完整的一篇，花了几个小时）</p>
<p>代码的逻辑真的是太绕了， 有点难理解！ 理解了next的原理，再写代码，也有点想象不来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Firefly</span></span><br><span class="line"><span class="comment"> * @Date: 2020-03-15 15:20:41</span></span><br><span class="line"><span class="comment"> * @Descripttion:</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2020-03-15 16:08:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="keyword">int</span> nextState[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">-1</span>;     <span class="comment">// 第二行的pattern 从 -1 开始</span></span><br><span class="line">  nextState[<span class="number">0</span>] = <span class="number">-1</span>;  <span class="comment">// 第一个字母肯定没有相同的序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length(); i++) &#123;  <span class="comment">// 对于后面的每一个字母</span></span><br><span class="line">    <span class="comment">//跳转到开始的索引， 到前面的索引</span></span><br><span class="line">    <span class="keyword">while</span> (start != <span class="number">-1</span> &amp;&amp; str[i] != str[start + <span class="number">1</span>]) start = nextState[start];</span><br><span class="line">    <span class="comment">// 写代码时，想像第一个字母的情况，</span></span><br><span class="line">    <span class="comment">//如果第二个（i） 等于 第一个（start +1）  第一二个相同，</span></span><br><span class="line">    <span class="keyword">if</span> (str[i] == str[start + <span class="number">1</span>]) start++;</span><br><span class="line">    nextState[i] = start;  <span class="comment">//设置第二行 start 的长度</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> text, pattern;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; text &gt;&gt; pattern;</span><br><span class="line">  getNext(pattern);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++) <span class="built_in">cout</span> &lt;&lt; nextState[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">-1</span>;  <span class="comment">// j 表示pattern 的索引</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; text[i] != pattern[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      j = nextState[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (text[i] == pattern[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == pattern.length() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;find at &quot;</span> &lt;&lt; i - j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>大数运算</title>
    <url>/2020/04/06/notepad/algorithm/exercise/tree/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h5 id="面试题-04-06-后继者"><a href="#面试题-04-06-后继者" class="headerlink" title="面试题 04.06. 后继者"></a>面试题 04.06. 后继者</h5><blockquote>
<p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">    TreeNode * ans =<span class="literal">nullptr</span>;     </span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= p-&gt;val) root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span>  ans = root,root = root-&gt;left; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a>173. 二叉搜索树迭代器</h5><blockquote>
<p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p>
<p>调用 <code>next()</code> 将返回二叉搜索树中的下一个最小的数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        ldfs(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ldfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        st.emplace(root);</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode* root = st.top(); st.pop();</span><br><span class="line">    ldfs(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题就是前序和中序遍历二叉树的非递归版本的差分版。</p>
<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a class="link"   href="https://leetcode-cn.com/problems/symmetric-tree/" >101. 对称二叉树<i class="fas fa-external-link-alt"></i></a></h4><blockquote>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
</blockquote>
<p>递归和非递归, 非递归都是使用一个stack 来模拟出这个栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(root-&gt;left,root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* left, TreeNode* right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(left-&gt;left, right-&gt;right) &amp;&amp; helper(left-&gt;right, right-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; le, ri;</span><br><span class="line">    le.push(root-&gt;left);</span><br><span class="line">    ri.push(root-&gt;right);</span><br><span class="line">    TreeNode * t1, * t2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(le.empty() &amp;&amp; ri.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(le.empty() || ri.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t1 = le.top(); t2 = ri.top();</span><br><span class="line">        le.pop(); ri.pop();</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(t1== <span class="literal">NULL</span> || t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        le.push(t1-&gt;right);ri.push(t2-&gt;left);</span><br><span class="line">        le.push(t1-&gt;left); ri.push(t2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a class="link"   href="https://leetcode-cn.com/problems/path-sum-iii/" >437. 路径总和 III<i class="fas fa-external-link-alt"></i></a></h4><blockquote>
<p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root ==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans += pathSum(root-&gt;left,sum);</span><br><span class="line">    ans += pathSum(root-&gt;right,sum);</span><br><span class="line">    sumHelper(<span class="number">0</span>,root,ans,sum);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sumHelper</span><span class="params">(<span class="keyword">int</span> cur, TreeNode* root,<span class="keyword">int</span> &amp;ans, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    cur += root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(cur == sum) ans++;</span><br><span class="line">    sumHelper(cur,root-&gt;left,ans,sum);</span><br><span class="line">    sumHelper(cur,root-&gt;right,ans,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一道双递归的题目， 在父类一个递归， 子类一个递归！！</p>
<h4 id="面试题-04-04-检查平衡性"><a href="#面试题-04-04-检查平衡性" class="headerlink" title="面试题 04.04. 检查平衡性"></a><a class="link"   href="https://leetcode-cn.com/problems/check-balance-lcci/" >面试题 04.04. 检查平衡性<i class="fas fa-external-link-alt"></i></a></h4><blockquote>
<p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLeft = <span class="number">0</span>, maxRight = <span class="number">0</span>;</span><br><span class="line">    search(root-&gt;left,<span class="number">0</span>,maxLeft), search(root-&gt;right,<span class="number">0</span>,maxRight);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(maxRight - maxLeft) &lt;= <span class="number">1</span> &amp;&amp; </span><br><span class="line">        isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode* root,<span class="keyword">int</span> cur, <span class="keyword">int</span> &amp;maxi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    cur += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right ==<span class="literal">nullptr</span>)    maxi = max(maxi,cur);   </span><br><span class="line">    search(root-&gt;left,cur,maxi), search(root-&gt;right,cur,maxi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单题</p>
<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" >94. 二叉树的中序遍历<i class="fas fa-external-link-alt"></i></a></h4><blockquote>
<p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">vint <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    vint ans;</span><br><span class="line">    TreeNode* index = root;</span><br><span class="line">    <span class="keyword">while</span>(index || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(index)&#123;</span><br><span class="line">            s.push(index);</span><br><span class="line">            <span class="comment">// ans.push_back(index-&gt;val); //前序遍历</span></span><br><span class="line">            index= index-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        index = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        ans.push_back(index-&gt;val);	<span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(index != <span class="literal">nullptr</span>)</span><br><span class="line">            index = index-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>难点在非递归用栈来模拟， 前序遍历只需要改一个位置即可</p>
<h4 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590. N叉树的后序遍历"></a><a class="link"   href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" >590. N叉树的后序遍历<i class="fas fa-external-link-alt"></i></a></h4><blockquote>
<p>给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="built_in">stack</span> &lt;Node*&gt; stk;</span><br><span class="line">    stk.push(root);</span><br><span class="line">    Node* top;</span><br><span class="line">    <span class="built_in">vector</span> &lt;Node*&gt;::iterator it;</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty())&#123;</span><br><span class="line">        top = stk.top();</span><br><span class="line">        a.push_back(top-&gt;val);</span><br><span class="line">        stk.pop();</span><br><span class="line">        <span class="keyword">for</span> (it = top-&gt;children.begin(); it != top-&gt;children.end() ; it++)&#123;</span><br><span class="line">            stk.push(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(a.begin(), a.end());</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107. 二叉树的层次遍历 II"></a><a class="link"   href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" >107. 二叉树的层次遍历 II<i class="fas fa-external-link-alt"></i></a></h4><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> vvint&#123;&#125;;</span><br><span class="line">    vvint ans;   </span><br><span class="line">    traver(<span class="built_in">vector</span>&lt;TreeNode*&gt;&#123;root&#125;,ans);</span><br><span class="line">    reverse(ans.begin(),ans.end());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traver</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">set</span>, vvint&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; tmp;</span><br><span class="line">    vint tmp1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; i : <span class="built_in">set</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i-&gt;left) tmp.push_back(i-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(i-&gt;right) tmp.push_back(i-&gt;right);</span><br><span class="line">        tmp1.push_back(i-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(tmp1);</span><br><span class="line">    traver(tmp,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打气题！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/03/14/notepad/algorithm/exercise/unionfind/</url>
    <content><![CDATA[<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a class="link"   href="https://leetcode-cn.com/problems/number-of-islands/" >200. 岛屿数量<i class="fas fa-external-link-alt"></i></a></h4><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>dfs， 只要相邻的是 1， 就把这个1 置为 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.size();</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].size();</span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">&#x27;1&#x27;</span>) dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>) dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;<span class="comment">// 只要是 1 的， 把周围的全都置为 0.          </span></span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>并查集</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    parent.push_back(i * n + j);</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.push_back(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                rank.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[i] != i) &#123;</span><br><span class="line">            parent[i] = find(parent[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootx = find(x);</span><br><span class="line">        <span class="keyword">int</span> rooty = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">            parent[rooty] = rootx;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rank.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; rank[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">          <span class="comment">//  if((i+1) %( rank.size()/ 4 ) == 0) cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(grid)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">&#x27;1&#x27;</span>) uf.unite(r * nc + c, (r<span class="number">-1</span>) * nc + c);</span><br><span class="line">                    <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>) uf.unite(r * nc + c, (r+<span class="number">1</span>) * nc + c);</span><br><span class="line">                    <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) uf.unite(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) uf.unite(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.getCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>分治法</title>
    <url>/2019/12/28/notepad/algorithm/exercise/%E5%88%86%E6%94%AF%E6%B3%95/</url>
    <content><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a><center>分治法</center></h1><p>一个大的问题分解为一些小的问题来求解</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20200501152619434.png"></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>* num, <span class="keyword">int</span> le, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (le &gt;= ri) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = le + ((ri - le) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  mergeSort(num, le, mid);</span><br><span class="line">  mergeSort(num, mid + <span class="number">1</span>, ri);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> tmp[ri - le + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>, l = le, r = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= ri) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num[l] &lt; num[r])  tmp[start++] = num[l++];</span><br><span class="line">    <span class="keyword">else</span>   tmp[start++] = num[r++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= mid) tmp[start++] = num[l++];</span><br><span class="line">  <span class="keyword">while</span> (r &lt;= ri) tmp[start++] = num[r++];</span><br><span class="line">  start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = le; i &lt;= ri; i++) num[i] = tmp[start++];  <span class="comment">// 拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><h3 id="非线性方程的运算"><a href="#非线性方程的运算" class="headerlink" title="非线性方程的运算"></a>非线性方程的运算</h3><h3 id="快速幂运算"><a href="#快速幂运算" class="headerlink" title="快速幂运算"></a>快速幂运算</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(a+b）%m&#x3D;a%m+b%m</span><br><span class="line">a*b%m&#x3D;(a%m)*(b%m)</span><br><span class="line">ab%m&#x3D;(a%m)b</span><br></pre></td></tr></table></figure>

<p>求 a ^ b?</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/1.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算a的2j次方对m取模的结果,用数组r保存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">long</span> *r, <span class="keyword">long</span> a, <span class="keyword">long</span> m)</span> </span>&#123;</span><br><span class="line">  r[<span class="number">0</span>] = a % m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; ++i) r[i] = (<span class="keyword">long</span>)r[i - <span class="number">1</span>] * r[i - <span class="number">1</span>] % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算a^b%m的值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">unsigned</span> m, <span class="keyword">long</span> <span class="keyword">unsigned</span> a, <span class="keyword">long</span> <span class="keyword">unsigned</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">long</span> bl[<span class="number">32</span>]&#123;<span class="number">0</span>&#125;, r[<span class="number">32</span>];  <span class="comment">// bl是b的二进制结果</span></span><br><span class="line">  cal(r, a, m);           <span class="comment">//计算ab%m的值</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    bl[i++] = b &amp; <span class="number">1</span>;  <span class="comment">// b拆分成二进制， &amp; 是求出b二进制的最后一位，一直右移</span></span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">    <span class="keyword">if</span> (bl[j]) ans = (ans * r[j]) % m;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2020/03/28/notepad/algorithm/exercise/%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="图论总结"><a href="#图论总结" class="headerlink" title="图论总结"></a><center>图论总结</center></h1><p>[toc]</p>
<p>算法这东西，容易忘记， 捡起来很快， 但也要时间， 因此，做一些简短的记录！</p>
<h3 id="图是什么？"><a href="#图是什么？" class="headerlink" title="图是什么？"></a>图是什么？</h3><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200219203748.png"></p>
<p>树可以存线， 图可以存树，树是一种无环图， 线是最简单的数据结构， 图是较为复杂的一种数据结构！</p>
<h3 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">有向</th>
<th align="center">无向</th>
</tr>
</thead>
<tbody><tr>
<td align="center">有权</td>
<td align="center">有向有权图</td>
<td align="center">无向有权图</td>
</tr>
<tr>
<td align="center">无权</td>
<td align="center">有向无权图</td>
<td align="center">无向无权图</td>
</tr>
</tbody></table>
<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><ul>
<li>邻接矩阵</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vaecotr&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Graph4;</span><br></pre></td></tr></table></figure>

<p>i点到j点的距离！ 空间复杂度： V^2 ,  求一个点的临接点:  V</p>
<ul>
<li>邻接表（链表）</li>
</ul>
<p>只存每个点能到达的点</p>
<p>空间复杂度： O（V+E  ），建图： O（E*V），求一个点的临接点：（O（V））</p>
<p>可以用 hash 或者 红黑树  替换 链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无向无权图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Graph1[maxn];</span><br><span class="line"><span class="comment">// 无向有权图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Graph2[maxn];</span><br><span class="line"><span class="comment">// hash 找很快！ 红黑树  to  cost  </span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;Graph3[maxn];  <span class="comment">// map 默认为0， </span></span><br></pre></td></tr></table></figure>



<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><ul>
<li>树</li>
</ul>
<p>分为 前序， （二叉树）中序， 后序， ==不用记录遍历过的点==！</p>
<ul>
<li>图</li>
</ul>
<p>分为 先序，后续（基本不用），要记录每一个每一个点是否遍历过， visited 记录</p>
<p>模版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs41</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">bool</span> *visited)</span> </span>&#123;</span><br><span class="line">  visited[index] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;  <span class="comment">// 前序遍历*************</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[i] &amp;&amp; Graph4[index][i] != <span class="number">0</span>) &#123;</span><br><span class="line">      dfs41(i, visited);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cout &lt;&lt; index &lt;&lt; &quot; -&gt; &quot;;后序遍历*****************</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs42</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">  <span class="built_in">stack</span>.push(start);</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="built_in">stack</span>.top();</span><br><span class="line">    <span class="built_in">stack</span>.pop();</span><br><span class="line">    visited[temp] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">      <span class="keyword">if</span> (!visited[i] &amp;&amp; Graph4[temp][i] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">stack</span>.push(i);</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>树的BFS和图的BFS是一样的！<br><strong>无权图的最短路径</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs4</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(start);</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    visited[temp] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">      <span class="keyword">if</span> (!visited[i] &amp;&amp; Graph4[temp][i]) &#123;</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        q.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>做题最好用dfs， 基于递归不用容器（自带的栈）存储太多东西！</p>
<p>栈（DFS），队列（BFS）， 随机容器（迷宫生成！）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vvint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">int</span> rs_len = <span class="number">2000</span>;</span><br><span class="line"><span class="function">vint <span class="title">cap</span><span class="params">(rs_len)</span></span>; <span class="comment">//容器</span></span><br><span class="line"><span class="keyword">int</span> cap_len = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//自己造一个随机容器！</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cap_empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cap_len == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cap_put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; cap[cap_len++] = value; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cap_get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cap_empty()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error: out of index!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  srand(time(<span class="literal">NULL</span>));  <span class="comment">// 随机获取一个数</span></span><br><span class="line">  <span class="keyword">int</span> index = rand() % cap_len;</span><br><span class="line">  <span class="comment">// cout &lt;&lt; &quot;random&quot; &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; cap_len &lt;&lt; endl;</span></span><br><span class="line">  <span class="keyword">int</span> ret = cap[index];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; cap_len - <span class="number">1</span>; i++) cap[i] = cap[i + <span class="number">1</span>];</span><br><span class="line">  cap_len--;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_map</span><span class="params">(vvint <span class="built_in">map</span>)</span></span>;</span><br><span class="line"><span class="comment">// @param 迷宫的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rs4</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  rs_len = len;</span><br><span class="line">  <span class="function">vvint <span class="title">map</span><span class="params">(rs_len * rs_len, vint(rs_len * rs_len))</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rs_len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rs_len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="built_in">map</span>[j + i * rs_len][j + i * rs_len + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">map</span>[j + i * rs_len + <span class="number">1</span>][j + i * rs_len] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">map</span>[j * rs_len + i][(j * rs_len + i) + rs_len] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">map</span>[j * rs_len + i + rs_len][j * rs_len + i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从 0 开始  随机搜索， 迷宫入口</span></span><br><span class="line">  cap_put(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">bool</span> visited[rs_len * rs_len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  visited[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!cap_empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = cap_get();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rs_len * rs_len; i++)</span><br><span class="line">      <span class="keyword">if</span> (!visited[i] &amp;&amp; <span class="built_in">map</span>[temp][i] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; temp &lt;&lt; &quot;  &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">map</span>[temp][i] = <span class="built_in">map</span>[i][temp] = <span class="number">2</span>;</span><br><span class="line">        cap_put(i);</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// traverse4(map);</span></span><br><span class="line">  gen_map(<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把遍历的经过转换成地图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_map</span><span class="params">(vvint <span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">  <span class="function">vvint <span class="title">temp</span><span class="params">(rs_len * <span class="number">2</span>, vint(rs_len * <span class="number">2</span>))</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rs_len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rs_len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">map</span>[j + i * rs_len][j + i * rs_len + <span class="number">1</span>] == <span class="number">2</span>) &#123;  <span class="comment">// 每一行</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; * &quot; &lt;&lt; j;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot; &quot; &lt;&lt; j + i * rs_len &lt;&lt; &quot; &quot; &lt;&lt; j + i * rs_len + 1 &lt;&lt; endl;</span></span><br><span class="line">        temp[i * <span class="number">2</span>][j * <span class="number">2</span>] = temp[i * <span class="number">2</span>][(j + <span class="number">1</span>) * <span class="number">2</span>] = temp[i * <span class="number">2</span>][j * <span class="number">2</span> + <span class="number">1</span>] =</span><br><span class="line">            <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">map</span>[j * rs_len + i][(j * rs_len + i) + rs_len] == <span class="number">2</span>) &#123;  <span class="comment">// 每一列</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; j &lt;&lt; &quot; / &quot; &lt;&lt; i;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot; &quot; &lt;&lt; j * rs_len + i &lt;&lt; &quot; &quot; &lt;&lt; j * rs_len + i + rs_len &lt;&lt; endl;</span></span><br><span class="line">        temp[j * <span class="number">2</span>][i * <span class="number">2</span>] = temp[(j + <span class="number">1</span>) * <span class="number">2</span>][i * <span class="number">2</span>] = temp[j * <span class="number">2</span> + <span class="number">1</span>][i * <span class="number">2</span>] =</span><br><span class="line">            <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rs_len * <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rs_len * <span class="number">2</span> - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> out = (temp[i][j] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; out &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>求联通分量（图分成了多少块！？）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">component</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) ans ++;      <span class="comment">// 只要有没有访问到的， 就计数加上一</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;				<span class="comment">// 其它 更遍历是一样的</span></span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">      <span class="keyword">int</span> temp = q.front();</span><br><span class="line">      q.pop();</span><br><span class="line">      visited[temp] = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//cout &lt;&lt; temp &lt;&lt; &quot; -&gt; &quot;;</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (!visited[i] &amp;&amp; Graph4[temp][i]) &#123;</span><br><span class="line">          visited[i] = <span class="number">1</span>;</span><br><span class="line">          q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unicom component is : &quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>路径问题（从一个点到另一个点是否通？）回溯（dfs）， 广搜</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_connected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(a);</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    visited[temp] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">      <span class="keyword">if</span> (Graph4[temp][i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == b)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">          visited[i] = <span class="number">1</span>;</span><br><span class="line">          q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>检测环</p>
</li>
<li><p>二分图检测</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200219211503.png"></p>
<p>定点V可以分为两部分， 所有边的两个顶点分别属于这两部分！ </p>
<h4 id="floodfill算法"><a href="#floodfill算法" class="headerlink" title="floodfill算法"></a>floodfill算法</h4><p>把图联通的某一部分填满！</p>
<p>算法思路：</p>
<p>​    直接遍历！</p>
<p>例题： 游戏开发 -&gt; 扫雷，   最大人工岛屿</p>
<h3 id="桥和隔点"><a href="#桥和隔点" class="headerlink" title="桥和隔点"></a>桥和隔点</h3><blockquote>
<p>桥： 删除了某一条边，联通分量发生改变！</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200219215253.png"></p>
<p>寻找所有桥！只有DFS可以求！(dfs遍历树)</p>
<p>对于每一条边 v - w ， 通过w， 能否通过另一条路回到v</p>
<blockquote>
<p>隔点： 删除隔点， 图的联通分量产生变化！</p>
</blockquote>
<p>类似寻找桥的算法！</p>
<h3 id="欧拉回路和欧拉路径"><a href="#欧拉回路和欧拉路径" class="headerlink" title="欧拉回路和欧拉路径"></a>欧拉回路和欧拉路径</h3><p>哈密尔顿回路</p>
<p>从一个点出发， 经过<strong>每个点一次</strong>，回到原点</p>
<p>欧拉回路</p>
<p>从一条点出发， 经过<strong>每一条边一次</strong>， 回到原点</p>
<p>// 离散数学知识， 不会考</p>
<h5 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h5><p> 无权图可以直接使用<strong>位</strong>来存储图</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>Kruskal 需要用到并查集判断有无环， 因此先列一下！ </p>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><blockquote>
<p>并查集是一种树型的数据结构，用于处理一些不相交<a class="link"   href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117" >集合<i class="fas fa-external-link-alt"></i></a>（Disjoint Sets）的<strong>合==并==**及</strong>==查==询**问题。</p>
</blockquote>
<p><strong>example:</strong></p>
<p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">测试输入包含若干测试用例。每个测试用例的第<span class="number">1</span>行给出两个正整数，分别是城镇数目N ( &lt; <span class="number">1000</span> )和道路数目M；</span><br><span class="line">随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。</span><br><span class="line">为简单起见，城镇从<span class="number">1</span>到N编号。</span><br><span class="line">注意:两个城市之间可以有多条道路相通,也就是说</span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line">这种输入也是合法的</span><br><span class="line">当N为<span class="number">0</span>时，输入结束，该用例不被处理。</span><br></pre></td></tr></table></figure>

<p><a class="link"   href="https://blog.csdn.net/niushuai666/article/details/6662911" >https://blog.csdn.net/niushuai666/article/details/6662911<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1010</span>];  <span class="comment">//里面全是掌门</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unionsearch</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> son, tmp;</span><br><span class="line">  son = root;</span><br><span class="line">  <span class="keyword">while</span> (root != pre[root])  <span class="comment">//寻找掌门ing……</span></span><br><span class="line">    root = pre[root];</span><br><span class="line">  <span class="keyword">while</span> (son != root) &#123;  <span class="comment">//路径压缩</span></span><br><span class="line">    tmp = pre[son];</span><br><span class="line">    pre[son] = root;</span><br><span class="line">    son = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;  <span class="comment">//掌门驾到~</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num, road, total, i, start, end, root1, root2;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;num, &amp;road) , num) &#123;</span><br><span class="line">    total = num - <span class="number">1</span>;            <span class="comment">//共num-1个门派</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; ++i)  <span class="comment">//每条路都是掌门</span></span><br><span class="line">      pre[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (road--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;start, &amp;end);  <span class="comment">//他俩要结拜</span></span><br><span class="line">      root1 = unionsearch(start);</span><br><span class="line">      root2 = unionsearch(end);</span><br><span class="line">      <span class="keyword">if</span> (root1 != root2) &#123;  <span class="comment">//掌门不同？踢馆！~</span></span><br><span class="line">        pre[root1] = root2;</span><br><span class="line">        total--;  <span class="comment">//门派少一个，敌人（要建的路）就少一个</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, total);  <span class="comment">//天下局势：还剩几个门派</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><p>首先排序， 从最小的<strong>边</strong>开始选取， 只要不构成环加入！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isCircle</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> pre[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp, son = root;</span><br><span class="line">  <span class="keyword">while</span> (pre[root] != root) root = pre[root];</span><br><span class="line">  <span class="keyword">while</span> (son != root) &#123;</span><br><span class="line">    tmp = pre[son];</span><br><span class="line">    pre[son] = root;</span><br><span class="line">    son = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;Edge *&gt; <span class="title">edge</span><span class="params">(edges)</span></span>;</span><br><span class="line">  sort(edge.begin(), edge.end(),</span><br><span class="line">       [](Edge *a, Edge *b) &#123; <span class="keyword">return</span> a-&gt;value &lt; b-&gt;value; &#125;);</span><br><span class="line">  <span class="keyword">int</span> pre[len] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//用作并查集的父节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) pre[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = isCircle(edge[i]-&gt;start, pre);</span><br><span class="line">    <span class="keyword">int</span> b = isCircle(edge[i]-&gt;end, pre);</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;  <span class="comment">// 不是环</span></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; edge[i]-&gt;start &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[i]-&gt;end &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      pre[b] = a;  <span class="comment">// 合并</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h4><p>选择离  已扩充节点集合 距离最小的<strong>点</strong>作为扩充点！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dis[len] = &#123;INF&#125;;  <span class="comment">// 关键 ！！！！！</span></span><br><span class="line">  <span class="keyword">int</span> p[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) dis[i] = INF;</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> index, min = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited[j] &amp;&amp; (min == <span class="number">-1</span> || dis[j] &lt; min)) &#123;</span><br><span class="line">        min = dis[j];</span><br><span class="line">        index = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[index] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p[index] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (Graph4[p[index]][index] != <span class="number">0</span>) addNode(root1, p[index], index);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Graph4[index][j] != <span class="number">0</span> &amp;&amp; dis[j] &gt; Graph4[index][j]) &#123;</span><br><span class="line">        dis[j] = Graph4[index][j];</span><br><span class="line">        p[j] = index;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;the tree is : \n&quot;</span>;</span><br><span class="line">  printTree();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="dijkstra和单源最短路径"><a href="#dijkstra和单源最短路径" class="headerlink" title="dijkstra和单源最短路径"></a>dijkstra和单源最短路径</h4><p>无负数, 一直选取当前未访问的最近的节点作为扩展！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> visited[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> dis[len];</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">  dis[start] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) </span><br><span class="line">        <span class="comment">//选取当前未访问的最近的点作为扩展</span></span><br><span class="line">      <span class="keyword">if</span> (!visited[j] &amp;&amp; (index == <span class="number">-1</span> || dis[index] &gt; dis[j])) </span><br><span class="line">        index = j;</span><br><span class="line">    visited[index] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) </span><br><span class="line">      <span class="keyword">if</span> (Graph4[index][j] != <span class="number">0</span> &amp;&amp; dis[index] + Graph4[index][j] &lt; dis[j]) </span><br><span class="line">        dis[j] = dis[index] + Graph4[index][j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dijkstra: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; INF &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; start &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; len: &quot;</span> &lt;&lt; ((dis[i] == INF)? <span class="number">-1</span> : dis[i]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><p>迭代n次， 每次按边来缩短dis， 如果某一次迭代没有变化，停止迭代！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ford</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dis[len];</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);</span><br><span class="line">  dis[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  <span class="comment">// 循环  len 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.size(); j++) &#123; <span class="comment">// 对于每一条边</span></span><br><span class="line">      <span class="keyword">if</span> (dis[edges[j]-&gt;start] + edges[j]-&gt;value &lt; dis[edges[j]-&gt;end]) &#123;</span><br><span class="line">        dis[edges[j]-&gt;end] = dis[edges[j]-&gt;start] + edges[j]-&gt;value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ford:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; start &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; len: &quot;</span> &lt;&lt; ((dis[i] == INF) ? <span class="number">-1</span> : dis[i])</span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Floyed-Warshall"><a href="#Floyed-Warshall" class="headerlink" title="Floyed-Warshall"></a>Floyed-Warshall</h4><p>所有点对最短路径， 动态规划， 子的状态直接用在</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dis[len][len];</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len * len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++)</span><br><span class="line">    dis[edges[i]-&gt;start][edges[i]-&gt;end] = dis[edges[i]-&gt;end][edges[i]-&gt;start] =</span><br><span class="line">        edges[i]-&gt;value;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != j &amp;&amp; i != k &amp;&amp; j != k) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;floyed:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dis[i][j] != INF)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; dis[i][j] &lt;&lt; <span class="string">&quot;;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><strong>一.定义</strong></p>
<p>对一个有向无环图(Directed Acyclic Graph, DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若&lt;u，v&gt; ∈E(G)，则u在线性序列中出现在v之前。</p>
<p>通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。</p>
<p>注意:</p>
<p>1)只有<strong>有向无环图</strong>才存在拓扑序列;</p>
<p>2)对于一个DAG,可能存在多个拓扑序列;</p>
<p><strong>二.拓扑序列算法思想</strong></p>
<p>(1)从有向图中选取一个没有前驱(即入度为0)的顶点，并输出之;</p>
<p>(2)从有向图中删去此顶点以及所有以它为尾的弧;</p>
<p>重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DAG</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printG2();</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    <span class="keyword">if</span> (in_cnt[i] == <span class="number">0</span> &amp;&amp; Graph2[i].size() != <span class="number">0</span>) q.push(i);</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;start topology:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Graph2[a].size(); i++)</span><br><span class="line">      <span class="keyword">if</span> (!--in_cnt[Graph2[a][i]-&gt;to]) q.push(Graph2[a][i]-&gt;to);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>以下用的比较少， 不做总结！</p>
<h3 id="网络流和最大流"><a href="#网络流和最大流" class="headerlink" title="网络流和最大流"></a>网络流和最大流</h3><h4 id="Ford-Fulkerson"><a href="#Ford-Fulkerson" class="headerlink" title="Ford-Fulkerson"></a>Ford-Fulkerson</h4><h4 id="Edmonds-Karp"><a href="#Edmonds-Karp" class="headerlink" title="Edmonds-Karp"></a>Edmonds-Karp</h4><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><p>BFS</p>
<p>DFS</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>大数运算</title>
    <url>/2019/12/28/notepad/algorithm/exercise/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="大数运算"><a href="#大数运算" class="headerlink" title="大数运算"></a>大数运算</h1><p>[toc]</p>
<h3 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a>大数加法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">intput:</span><br><span class="line">123456789012345678901234567890</span><br><span class="line">123456789012345678901234567890 </span><br><span class="line">123456789012345678901234567890</span><br><span class="line">0</span><br><span class="line">output:</span><br><span class="line">370370367037037036703703703670</span><br></pre></td></tr></table></figure>







<h3 id="大数乘法"><a href="#大数乘法" class="headerlink" title="大数乘法"></a>大数乘法</h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>limter</title>
    <url>/2020/08/01/notepad/algorithm/limter/README/</url>
    <content><![CDATA[<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p><img src="./assert/rate-limit1.png" alt="image"></p>
<p>生动形象，容易理解， 往桶里加水的速度大于漏水的速度就超速了， 桶大小表示最大速度大小</p>
<p>缺点： 只能匀速处理， 不能并发处理， 虽然可以一下往桶里加水， 但速度取决于漏水速度</p>
<h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><blockquote>
<ul>
<li>每秒会有 r 个令牌放入桶中，或者说，每过 1/r 秒桶中增加一个令牌</li>
<li>桶中最多存放 b 个令牌，如果桶满了，新放入的令牌会被丢弃</li>
<li>当一个 n 字节的数据包到达时，消耗 n 个令牌，然后发送该数据包</li>
<li>如果桶中可用令牌小于 n，则该数据包将被缓存或丢弃</li>
</ul>
</blockquote>
<p>缺点： 可能出现某一个时间段出现超频！（停止一段时间后突然拿掉桶里的所有token， 后面还会慢慢拿， 因此这里超速了）</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>在窗口内有固定的请求数， 可以处理并发。</p>
<p>缺点：<strong>速度最大时</strong> 不能处理高并发时的匀速请求， 都是像分批一样分发token的，有点像 tcp 一下分发出去很多包，这样对于不是临界的值不公平， 运行 <a class="link"   href="https://github.com/Fierygit/cxxstudy/blob/master/algorithm/limter/token_limter.cc" >code<i class="fas fa-external-link-alt"></i></a> 查看</p>
<h3 id="结合实现（-令牌桶-滑动窗口-）"><a href="#结合实现（-令牌桶-滑动窗口-）" class="headerlink" title="结合实现（ 令牌桶 + 滑动窗口 ）"></a>结合实现（ 令牌桶 + 滑动窗口 ）</h3><p>既可以处理并发， 又可以让任意一个时间段不超速！</p>
<p><a class="link"   href="https://github.com/Fierygit/cxxstudy/blob/master/algorithm/limter/rate_limter.cc" >code<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>problem</title>
    <url>/1899/11/30/notepad/cxx/grammar/class/README/</url>
    <content><![CDATA[<h1 id="problems"><a href="#problems" class="headerlink" title="problems:"></a>problems:</h1><h3 id="1、-含有继承的类的初始化顺序是什么？"><a href="#1、-含有继承的类的初始化顺序是什么？" class="headerlink" title="1、 含有继承的类的初始化顺序是什么？"></a>1、 含有继承的类的初始化顺序是什么？</h3><h3 id="2、-一个类的构建过程，-详细说？"><a href="#2、-一个类的构建过程，-详细说？" class="headerlink" title="2、 一个类的构建过程， 详细说？"></a>2、 一个类的构建过程， 详细说？</h3><h3 id="3、-为什么构造函数不能写成虚函数？"><a href="#3、-为什么构造函数不能写成虚函数？" class="headerlink" title="3、 为什么构造函数不能写成虚函数？"></a>3、 为什么构造函数不能写成虚函数？</h3><h3 id="4、-为什么析构函数要写成虚函数？"><a href="#4、-为什么析构函数要写成虚函数？" class="headerlink" title="4、 为什么析构函数要写成虚函数？"></a>4、 为什么析构函数要写成虚函数？</h3><h3 id="5、-早期绑定和后期绑定（java-中-静态分派（dispatch）和动态分配）"><a href="#5、-早期绑定和后期绑定（java-中-静态分派（dispatch）和动态分配）" class="headerlink" title="5、 早期绑定和后期绑定（java 中 静态分派（dispatch）和动态分配）"></a>5、 早期绑定和后期绑定（java 中 静态分派（dispatch）和动态分配）</h3><h3 id="6、-虚函数原理是什么，-为什么需要虚函数"><a href="#6、-虚函数原理是什么，-为什么需要虚函数" class="headerlink" title="6、 虚函数原理是什么， 为什么需要虚函数"></a>6、 虚函数原理是什么， 为什么需要虚函数</h3>]]></content>
  </entry>
  <entry>
    <title>STL 使用</title>
    <url>/2018/03/01/notepad/cxx/STL%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文来自CSDN博客，转载请标明出处：<a class="link"   href="http://blog.csdn.net/ciahi/archive/2009/08/09/4429103.aspx" >http://blog.csdn.net/ciahi/archive/2009/08/09/4429103.aspx<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="STL-的使用"><a href="#STL-的使用" class="headerlink" title="STL 的使用"></a>STL 的使用</h1><p>条款1：仔细选择你的容器</p>
<p>deque是唯一一个“在迭代器失效时不会使它的指针和引用失效”的标准STL容器。</p>
<p>条款2：小心对“容器无关代码”的幻想</p>
<p>既要和序列容器又要和关联容器一起工作的代码并没有什么意义。很多成员函数只存在于其中一类容器中，比如，只有序列容器支持push_front或push_back，只有关联容器支持count和lower_bound。 在不同的类中，相同的操作名称，但在意义上是天差地别的。</p>
<p>条款3：使容器里对象的拷贝操作轻量而正确</p>
<p>拷贝对象是STL的方式。即，比如向容器中添加对象，都是通过值来传递的，即都要对对象进行拷贝。</p>
<p>还有其它的操作，如排序算法，删除元素等，都要进行大量的拷贝动作。（通过容器里面的对象的拷贝构造函数和拷贝赋值操作符来完成的）</p>
<p>如果你以基类对象建立一个容器，而你试图插入派生类对象，那么当对象（通过基类的拷贝构造函数）拷入容器的时候对象的派生部分会被删除。</p>
<p>一个使拷贝更高效、正确而且对分割问题免疫的简单的方式是建立指针的容器而不是对象的容器。</p>
<p>（但指针的容器有它们自己STL相关的头疼问题。智能指针的容器是一个吸引人的选择）</p>
<p>条款4：用empty来代替检查size()是否为0</p>
<p>对于所有的标准容器，empty是一个常数时间的操作，但对于一些list实现，size花费线性时间。</p>
<p>条款5：尽量使用区间成员函数代替它们的单元素兄弟</p>
<p>因为区间成员函数一般针对特定的容器进行了优化，要比“通用”版本的操作效率高。</p>
<p>无论何时你必须完全代替一个容器的内容，你就应该想到赋值。</p>
<p>几乎所有目标区间被插入迭代器指定的copy的使用都可以用调用的区间成员函数的来代替。(尽量用成员函数来代替copy)</p>
<p>● 一般来说使用区间成员函数可以输入更少的代码。</p>
<p>● 区间成员函数会导致代码更清晰更直接了当。</p>
<p>条款6：警惕C++最令人恼怒的解析</p>
<p>ifstream dataFile(“ints.dat”);</p>
<p>list<int> data(istream_iterator<int>(dataFile), // 警告！这完成的并不</p>
<p>istream_iterator<int>()); // 是像你想象的那样</p>
<p>编译器可能会将它解析为一个函数的声明。</p>
<p>改用如下代码来代替：（即在第一个参数外面加上括号）</p>
<p>list<int> data((istream_iterator<int>(dataFile)),</p>
<p>istream_iterator<int>());</p>
<p>不过这种方法可能并不是所有编译器都支持的。</p>
<p>所以改成下面的方法可以保证所有编译器支持：</p>
<p>istream_iterator<int> dataBegin(dataFile);</p>
<p>istream_iterator<int> dataEnd;</p>
<p>list<int> data(dataBegin, dataEnd);</p>
<p>条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针</p>
<p>当你要删除指针的容器时要避免资源泄漏，你必须用智能引用计数指针对象（比如Boost的shared_ptr）来代替指针，或者你必须在容器销毁前手动删除容器中的每个指针。</p>
<p>条款8：永不建立auto_ptr的容器</p>
<p>auto_ptr的容器（COAPs）是禁止的。试图使用它们的代码都不能编译。</p>
<p>主要是因为auto_ptr会传递所有权，所以再对容器操作的时候，很可能产生一些非预期的行为。</p>
<p>条款9：在删除选项中仔细选择</p>
<p>● 去除一个容器中有特定值的所有对象：</p>
<p>如果容器是vector、string或deque，使用erase-remove惯用法。</p>
<p>如果容器是list，使用list::remove。</p>
<p>如果容器是标准关联容器，使用它的erase成员函数。</p>
<p>● 去除一个容器中满足一个特定判定式的所有对象：</p>
<p>如果容器是vector、string或deque，使用erase-remove_if惯用法。</p>
<p>如果容器是list，使用list::remove_if。</p>
<p>如果容器是标准关联容器，使用remove_copy_if和swap，或写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它。</p>
<p>● 在循环内做某些事情（除了删除对象之外）：</p>
<p>如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用erase时记得都用它的返回值更新你的迭代器。</p>
<p>如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它。</p>
<p>条款10：注意分配器的协定和约束</p>
<p>条款12：对STL容器线程安全性的期待现实一些</p>
<p>你能从已有的实现里确定的最多是下列内容：</p>
<p>● 多个读取者是安全的。多线程可能同时读取一个容器的内容，这将正确地执行。当然，在读取时不能有任何写入者操作这个容器。</p>
<p>● 对不同容器的多个写入者是安全的。多线程可以同时写不同的容器。</p>
<p>所以要实现线程安全，必须自己来处理代码，将要加锁部分的代码lock住。</p>
<p>条款13：尽量使用vector和string来代替动态分配的数组</p>
<p>无论何时，你发现你自己准备动态分配一个数组（也就是，企图写“new T[…]”），你应该首先考虑使用一个vector或一个string。(这样就可以避免管理资源,省去了new及delete所可能造成的资源泄漏)</p>
<p>如果你在多线程环境中使用引用计数字符串，就应该注意线程安全性支持所带来的的性能下降问题。</p>
<p>如果你用的string实现是引用计数的，而且要在多线程环境中使用，可以用如下的方法尝试：</p>
<p>一，看看库是否可以关闭引用计数。</p>
<p>二，寻找或开发一个不使用引用计数的string实现。</p>
<p>三，考虑使用vector<char>来代替string。</p>
<p>条款14：使用reserve来避免不必要的重新分配</p>
<p>因为vector和string空间不足时(且小于max_size)，每次会以2为因数增长。而且每次都会申请新内存，将旧数据拷贝到新内存，销毁旧内存的对象，释放旧内存。所以消耗很大。</p>
<p>用reserve来保存足够多的容量。如果确切的知道有多少元素，就可以使用reserve，或者保留你可能需要的最大空间。将数据全部添加完后，再修整掉多余的内容。</p>
<p>条款15：小心string实现的多样性</p>
<p>因为string的各实现不同，可能造成string特性的一些差异，如sizeof(string)就可能大小不一致。</p>
<p>新字符串值的建立可能需要0、1或2次动态分配。</p>
<p>string对象可能是或可能不共享字符串的大小和容量信息。</p>
<p>string可能是或可能不支持每对象配置器。</p>
<p>不同实现对于最小化字符缓冲区的配置器有不同策略。</p>
<p>条款16: 如何将vector和string的数据传给遗留的API</p>
<p>如果你有一个vector对象v，而你需要得到一个指向v中数据的指针，以使得它可以被当作一个数组，只要使用&amp;v[0]就可以了。</p>
<p>让C风格API把数据放入一个vector，然后拷到你实际想要的STL容器中的主意总是有效的。</p>
<p>条款17：使用“交换技巧”来修整过剩容量</p>
<p>当vector擦除了很多元素之后，想要把它的大小缩减，以节省空间。</p>
<p>reserve和resize都没法减少vector的占用空间。只能用swap来做。</p>
<p>如下：</p>
<p>vector<Contestant>(contestants).swap(contestants);</p>
<p>即，用目前contestants的有效元素来初始化一个临时vector，然后再将两个vector的内容互换。并且当这个临时对象消失的时候，那个vector的所有空间都被释放了。</p>
<p>string(s).swap(s); // 在s上进行“收缩到合适”</p>
<p>vector<Contestant>().swap(v); // 清除v而且最小化它的容量</p>
<p>string().swap(s); // 清除s而且最小化它的容量</p>
<p>条款18：避免使用vector<bool></p>
<p>第一，它不是一个STL容器。</p>
<p>第二，它并不容纳bool。</p>
<p>(虽然vector<bool>满足大部分STL容器的必要条件，但仍然不能完全满足。)</p>
<p>可以用deque<bool>来代替(deque<bool>的存储并不连续)。或者用bitset来代替。(bitset是标准库的一部分，但不是STL容器。)</p>
<p>bitset在编译期间固定大小，所以不支持插入和删除元素。也不支持iterator，使用一个压缩的表示法，使得它包含的每个值只占用一比特。它提供vector<bool>特有的flip成员函数及其它位集操作函数。</p>
<p>条款19：了解相等和等价的区别</p>
<p>a==b表示a和b相等。</p>
<p>!(a&lt;b) &amp;&amp; !(b&lt;a) 即，a&lt;b为假，且 b&lt;a 也为假，则a和b等价。</p>
<p>只所以在关联容器中使用等价，没有使用相等的原因是：</p>
<p>如果关联容器使用相等来决定两个对象是否有相同的值，但因为关联容器要决定元素间的顺序，所以还是要有用来比较元素大小的运算符，这样多个运算符，在关联容器中容易造成混乱。</p>
<p>通过只使用一个比较函数并使用等价作为两个值“相等”的意义的仲裁者，标准关联容器避开了很多会由允许两个比较函数而引发的困难。</p>
<p>条款20：为指针的关联容器指定比较类型</p>
<p>在对关联容器进行默认排序时，会默认采用指针的值来做为排序对象。所以此时要自定义排序规则。</p>
<p>条款21: 永远让比较函数对相等的值返回false</p>
<p>如果对相等的值返回true的时候，则在关联容器里面用operator &lt;= 来比较两个元素的时候，则会将两个不相等的元素判断为不相等。(因为!(a&lt;b) &amp;&amp; !(b&lt;a)为true才相等)</p>
<p>而且对multiset及multimap等，使用equal_range来得到等价的值的范围，a==b，但并不能得到a与b等价，所以它们两个不可能都在equal_range得到的范围内。</p>
<p>从技术上说，用于排序关联容器的比较函数必须在它们所比较的对象上定义一个“严格的弱序化(strict weak ordering)”。任何一个定义了严格的弱序化的函数都必须在传入相同的值的两个拷贝时返回false。</p>
<p>条款22：避免原地修改set和multiset的键</p>
<p>set和multiset保持它们的元素有序，这些容器的正确行为依赖于它们保持有序。</p>
<p>如果要修改的话，将原有元素拷贝出来，然后修改这个拷贝值。删除容器中的原元素，再将新的拷贝元素插入到容器里面。</p>
<p>条款23：考虑用有序vector代替关联容器</p>
<p>有序的vector与关联容器相比，从算法上来看，查找速度可能不会快，但会节省空间，因为关联容器要保存一些指针。</p>
<p>但实际上，因为关联容器存储元素的时候，元素是分散的，就可能存储在多个内存页面上，或者是存储在虚拟内存中，所以用到元素的时候，会经常发生缺页错误，从而导致页面更频繁的换入换出，影响查找速度。</p>
<p>用有序vector来模拟map或multimap时，map&lt;const K, Val&gt; 中的K不能为const，因为要对vector进行排序的时候，要改变K的值，来达到排序的效果。(模拟map的话，因为vector存储的是pair，所以要自定义排序函数)</p>
<p>条款24：当关乎效率时应该在map::operator[]和map-insert之间仔细选择</p>
<p>map::operator[]被设计为简化“添加或更新”功能，与vecotr、string等的operator[]无关，也与内建数组没有联系。</p>
<p>map&lt;int, Widget&gt; m;</p>
<p>m[1] = 1.50; //使用operator[]</p>
<p>m.insert(map&lt;int, Widget&gt;::value_type(1, 1.50)); //使用insert</p>
<p>使用：m[1] = 1.50; 时，如果1还未在map中出现，就会插入这个元素。</p>
<p>当插入元素的过程中(即1还未在map中出现)，第一种方法会比第二种方法多出如下的三步：</p>
<p>建立临时的默认构造Widget对象。</p>
<p>对Widget的赋值操作。</p>
<p>销毁这个临时Widget对象。</p>
<p>当1已经在map中出现，就会更新这个值。</p>
<p>这个时候，第一种方法反而会更高效。原因如下：</p>
<p>在insert方法中出现的map&lt;int, Widget&gt;是一个pair对象，在这个地方就会构造和析构pair，而且还会构造Widget，所以此时效率就比operator[]低。</p>
<p>不过我们自己可以实现一个算法，针对不同的情况调用不同的函数来提高效率，使其总是高效的。</p>
<p>条款25：熟悉非标准散列容器</p>
<p>散列容器是关联容器。</p>
<p>事实上的标准名字：hash_set、hash_multiset、hash_map和hash_multimap。(目前还未标准化，但下个版本会加入标准库。不同的厂家实现原理、细节可能会不同)</p>
<p>条款26：尽量用iterator代替const_iterator，reverse_iterator和const_reverse_iterator</p>
<p>有些函数只接受iterator类型的参数。</p>
<p>const_iterator不能隐式转换成iterator，即使用变通的办法，也不通用，且不能保证高效。</p>
<p>从reverse_iterator转换而来的iterator在转换之后可能需要相应的调整。</p>
<p>还有种情况，如果const_iterator将operator==实现为了成员函数的话，则在==的左边必须是const_iterator才能编译通过。</p>
<p>不过，const_iterator可以防止所指元素被改变，有时候也是有用的。</p>
<p>条款27：用distance和advance把const_iterator转化成iterator</p>
<p>//ci是const_iterator，Iter i是iterator</p>
<p>Iter i(const_cast<Iter>(ci)); // 错误！不能从const_iterator映射为iterator</p>
<p>只所以错误，是因为const_iterator与iterator是完全不同的类。(如果是vector和string容器的迭代器的话，有可能可以通过编译，因为这些容器通常用真实的指针作为它们的迭代器。)</p>
<p>用如下的方法来转换：</p>
<p>Iter i(d.begin()); // 初始化i为d.begin()</p>
<p>advance(i, distance<ConstIter>(i, ci)); // 把i移到指向ci位置</p>
<p>条款28：了解如何通过reverse_iterator的base得到iterator</p>
<p>vector<int>::reverse_iterator ri;</p>
<p>vector<int>::iterator i(ri.base());</p>
<p>实际上得到的i是指向ri的下一个位置的元素，而并不是ri所指的元素。</p>
<p>这样做的好处是在插入元素的时候，并不需要考虑它们的位置，不管用i还是ri来插入元素，都会插入到相同的位置。</p>
<p>但是，在擦除元素的时候就会出现问题。因为erase是插除迭代器本身所指的元素，所以i和ri会擦除不同的元素。</p>
<p>解决方法如下：</p>
<p>v.erase((++ri).base()); // 删除ri指向的元素；</p>
<p>条款29：需要一个一个字符输入时考虑使用istreambuf_iterator</p>
<p>istream_iterators所依靠的operator&gt;&gt;函数进行的是格式化输入，这意味着每次你调用的时候它们都必须做大量工作。如它们必须检查影响它们行为的流标志，读取错误检查等等。所以它的速度相对比较慢。</p>
<p>你可以像istream_iterator一样使用istreambuf_iterator，但istream_iterator<char>对象使用operator&gt;&gt;来从输入流中读取单个字符。，istreambuf_iterator不忽略任何字符。它们只简单地抓取流缓冲区的下一个字符。</p>
<p>条款30：确保目标区间足够大</p>
<p>如果目标区间并不足够大，用back_inserter或front_inserter或inserter来插入。</p>
<p>赋值只在两个对象之间操作时有意义，而不是在一个对象和一块原始的比特之间。</p>
<p>results.reserve(results.size() + values.size());</p>
<p>transform(values.begin(), values.end(),</p>
<p>results.end(), // 到未初始化的内存</p>
<p>transmogrify); // 行为未定义！</p>
<p>因为reserve出来的空间只是原始内存，里面并不包含对象。</p>
<p>条款31：了解你的排序选择</p>
<p>partial_sort只排序前N个元素。</p>
<p>nth_element本质上等价于partial_sort，但是它并不在这前N个元素内部排序。但前N个是所有元素里面N个最大的。 它也可以将指定位置的单一元素设成与相应位置相符的大小。</p>
<p>partition排序指定范围内的元素。</p>
<p>条款32：如果你真的想删除东西的话就在类似remove的算法后接上erase</p>
<p>唯一从容器中除去一个元素的方法是在那个容器上调用一个成员函数，而且因为remove无法知道它正在操作的容器，所以remove不可能从一个容器中除去元素。从一个容器中remove元素不会改变容器中元素的个数，它只是将相应位置后面的元素向前移，而且不删除最后面的元素。 用size()取得的大小也不会变化。</p>
<p>所以要想删除元素，调用完remove后一定要调用erase。</p>
<p>v.erase(remove(v.begin(), v.end(), 99), v.end()); // 真的删除所有等于99的元素。</p>
<p>(不过list的成员函数remove可以真正的删除元素。)</p>
<p>条款33：提防在指针的容器上使用类似remove的算法</p>
<p>容器存储的是指针的时候，调用remove的时候，会使一些内存空间不被指针所指向，从而无法再引用这段内存空间，从而造成内存泄漏。</p>
<p>如果你无法避免在那样的容器上使用remove，排除这个问题一种方法是在应用erase-remove惯用法之前先删除指针并设置它们为空，然后除去容器中的所有空指针。</p>
<p>条款34：注意哪个算法需要有序区间</p>
<p>binary_search</p>
<p>lower_bound</p>
<p>upper_bound</p>
<p>equal_range</p>
<p>set_union</p>
<p>set_intersection</p>
<p>set_difference</p>
<p>set_symmetric_difference</p>
<p>merge</p>
<p>inplace_merge</p>
<p>includes</p>
<p>要注意容器的排序方式与算法的排序方式是否一致，如果不一致，可能导致一些未定义的行为。</p>
<p>条款35：通过mismatch或lexicographical比较实现简单的忽略大小写字符串比较</p>
<p>mismatch，用来返回两个字符串第一个不匹配的位置。只要为它指定比较规则即可，第一个区间要小于第二个区间的长度。</p>
<p>lexicographical_compare用来进行字典排序。</p>
<p>条款36：了解copy_if的正确实现</p>
<p>条款37：用accumulate或for_each来统计区间</p>
<p>条款38：把仿函数类设计为用于值传递</p>
<p>c/c++准则：函数指针是值传递。</p>
<p>STL算法库一般要按值传递来接收函数对象。不过可以通过显示指定算法的模板参数类型，来传递引用。不过传递引用时，有时候会发生编译错误。</p>
<p>用值传递函数对象时，函数对象要尽可能的小，否则它们的拷贝会很昂贵。函数对象必须是单态的，不能用虚函数。因为派生类以值传递的时候可能造成切割问题。</p>
<p>如果要传递的函数对象很大，或者要使用到多态，用Bridge模式可以解决。 实现方式即：</p>
<p>带着你要放进你的仿函数类的数据和/或多态，把它们移到另一个类中（即实现类）。然后给你的仿函数一个指向这个新类的指针。建立一个包含一个指向实现类的指针的小而单态的类，然后把所有数据和虚函数放到实现类。</p>
<p>条款39：用纯函数做判断式</p>
<p>判断式是返回bool（或者其他可以隐式转化为bool的东西）。</p>
<p>纯函数是返回值只依赖于参数的函数。且它的内部不会改变参数的值，由纯函数引用的所有数据不是作为参数传进的就是在函数生存期内是常量。所以纯函数没有状态。</p>
<p>一个判断式类是一个仿函数类，它的operator()函数是一个判断式，也就是，它的operator()返回true或false（或其他可以隐式转换到true或false的东西）。</p>
<p>如果在判断式中改变了所引用的数据，即不是纯函数了，这时候，以值来传递判断式的时候，可能会出现问题，比如说判断式本应该只有一次返回true，但两次使用这个判断式时，两次被重新构造，有两次返回true了。结果就会有问题了。</p>
<p>最简单的使你自己不摔跟头而进入语言陷阱的方法是在判断式类中把你的operator()函数声明为const。这样，编译器不会让你在里面改变任何类数据成员。</p>
<p>不管怎么写判断式，他们都应该是纯函数。</p>
<p>条款40：使仿函数类可适配</p>
<p>提供必要的typedef的函数对象称为可适配的。(typedef是：argument_type、first_argument_type、second_argument_type和result_type)</p>
<p>ptr_fun做的唯一的事是使一些typedef有效。</p>
<p>只要使我们的类继承自std::unary_function或是std::binary_function模板类，就可以自动使这个函数对象变为可适配的。</p>
<p>在仿函数类中，只能提供一个operator()来适配一元或二元的仿函数，如果提供两个，它只能适配一个！</p>
<p>条款41：了解使用ptr_fun、mem_fun和mem_fun_ref的原因</p>
<p>这些函数的主要任务之一是覆盖C++固有的语法矛盾之一。</p>
<p>它们被称为函数对象适配器。</p>
<p>在将成员函数传递给STL组件时，一定得使用mem_fun和mem_fun_ref，否则不能通过编译。</p>
<p>ptr_fun是在函数对象没有提供一些typedef时，要使用的。(参看条款40)</p>
<p>条款42：确定less<T>表示operator&lt;</p>
<p>条款43：尽量用算法调用代替手写循环</p>
<p>调用算法通常比手写的循环更优越。原因：</p>
<p>● 效率：算法通常比程序员产生的循环更高效。</p>
<p>● 正确性：写循环时比调用算法更容易产生错误。</p>
<p>● 可维护性：算法通常使代码比相应的显式循环更干净、更直观。</p>
<p>条款44：尽量用成员函数代替同名的算法</p>
<p>首先，成员函数更快。其次，比起算法来，它们与容器结合得更好</p>
<p>因为成员函数就是针对某容器提供的特化版本算法。</p>
<p>list成员函数的行为和它们的算法兄弟的行为经常不相同。如调用通用的remove、remove_if和unique算法后，必须紧接着调用erase函数才能清除对象，但list的remove等成员函数后面并不需要erase函数，就能清除对象。</p>
<p>条款45：注意count、find、binary_search、lower_bound、upper_bound和equal_range的区别</p>
<p>如果迭代器定义了一个有序区间，则可以通过binary_search、lower_bound、upper_bound和equal_range来加速。如果没有有序区间，则只能用count、find线性时间的算法。count经常用来检查元素是否存在。但count找到存在的元素后，仍会继续查找，直到将所有元素遍历。但find找到后就会结束，所以find的效率可能略优一点。</p>
<p>要测试在有序区间中是否存在一个值，使用binary_search，但这个算法只返回一个bool值，表明是否找到了，要想得到更多的信息，则这个算法无能为力了。如果想知道存在的元素在哪儿，可以用equal_range。</p>
<p>条款46：考虑使用函数对象代替函数作算法的参数</p>
<p>函数作为算法的参数的时候，会传递函数的指针作为参数，而且函数指针会抑制内联。函数对象的operator()被声明为内联的时候，在速度上，会高于以函数作为算法的参数进行传递。</p>
<p>有时候，用函数作为参数的时候，可能会编译不过，但用函数对象，一般都不会出问题。</p>
<p>条款47：避免产生只写代码</p>
<p>此处的“只写”代码是指，容易写，但是不容易读和理解的代码。</p>
<p>代码的读比写更经常，这是软件工程的真理。</p>
<p>条款48：总是#include适当的头文件</p>
<p>条款49：学习破解有关STL的编译器诊断信息</p>
<p>条款50：让你自己熟悉有关STL的网站</p>
]]></content>
      <categories>
        <category>CXX</category>
      </categories>
      <tags>
        <tag>cxx</tag>
      </tags>
  </entry>
  <entry>
    <title>java 并发与实战</title>
    <url>/2018/05/27/notepad/java/java%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="java-并发与实战"><a href="#java-并发与实战" class="headerlink" title=" java 并发与实战"></a><center> java 并发与实战</center></h2><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="线程的安全性"><a href="#线程的安全性" class="headerlink" title="线程的安全性"></a>线程的安全性</h3><p><strong>安全的线程满足条件</strong>：</p>
<ul>
<li>不在线程之间共享变量</li>
<li>将变量置为不可变变量</li>
<li>访问变量时使用同步</li>
</ul>
<p><strong>原子性：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">value = value + <span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<p> 在 cpu  执行  最终的机器指令时， 分为两步， 首先获取value， 然后再加上一返回， 这两步一起执行叫做原子性。</p>
<p><strong>竞态条件：</strong></p>
<p>两个线程同时获取了， value， 同时加上了1， 导致，value 只加上了1，这种情况称为竟态条件。</p>
<p><strong>延时初始化的竟态条件：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Test <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(test == <span class="keyword">null</span>)</span><br><span class="line">            test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当两个线程调用这个获取对象的方法时， 一开始所有的 对象获取的都是null， 于是test被初始化了两次！ 存在竟态条件， 如果是单例模式， 那么返回的将不是单例！</p>
<p><strong>复合操作：</strong></p>
<p>相当于操作系统的硬件提供的支持， 让一个方法为原子执行， 如 TestAndSet 的函数等等！将数据的操作复合到一起， 保证原子性.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></figure>

<p>当使用上面的整数时，默认是原子操作的，由jvm虚拟机提供的方法！</p>
<p>操作系统中学的是硬件提供支持， 而 java虚拟机也可以提供支持！</p>
<p><strong>内置锁：</strong>（也称监视器锁 或 监视器）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="class"><span class="keyword">class</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 自动获取锁， 保证代码的原子性执行， 但是这样做， 性能低下！！！ 把并行的代码，变成了串行</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>静态的synchronized 方法以Class 对象作为锁！</p>
<p><strong>重入：</strong></p>
<p>一个线程可以重复获取锁， JVM 会记录线程获取锁的次数，直到所有的锁（重复获取的）都释放了才释放锁。</p>
<p><strong>多状态的保护：</strong></p>
<p>当有多个状态的时候， 要有一个锁来保护所有的状态！！</p>
<h3 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a><strong>对象的共享</strong></h3><p><strong>可见性：</strong></p>
<p>一个对象的发生了变化， 其它线程要能够第一时间得知， 变量发生了变化！</p>
<p>锁能够保证变量的可见性！</p>
<p><strong>Volatile</strong> </p>
<p>将变量声明为volatile， 确保变量在更新操作时通知其他线程。<strong>只能确保可见性</strong></p>
<p>通常用作 某个操作完成，发生中断 或者 状态的标志。</p>
<p>使用时需要满足下面的所有条件：</p>
<ul>
<li>变量的写入操作不依赖当前值， 或者确保只有单个线程更新变量的值</li>
<li>变量不会与其它状态变量一起纳入不变性条件中</li>
<li>访问变量时不需要加锁</li>
</ul>
<p><strong>发布与逸出</strong></p>
<blockquote>
<p>发布： 使对象能够在当前作用域之外的代码中使用(包括引用)</p>
</blockquote>
<blockquote>
<p>溢出： 某一个不该发布的对象被发布时， 称为逸出</p>
</blockquote>
<p>当从对象的构造函数中发布对象时， 只是发布了一个尚未构造完成的对象！！！</p>
<p><strong>线程封闭：</strong></p>
<p>单线程内访问数据， 不需要同步， 称为线程封闭！</p>
<p>如JDBC使用的connection对象， 分发到一个线程中， 用完后还回来， 隐含使用了线程封闭</p>
<p><strong>栈封闭：</strong></p>
<p>栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。（没什么用，其它线程访问不到）</p>
<p><strong>ThreadLocal类：</strong></p>
<p>这个类可以使线程中的某一个值与保存的值的对象关联起来， 每一个线程对应都有一个副本</p>
<p><strong>不变性：</strong></p>
<p>不变的对象一定是线程安全的！</p>
<p>满足条件有：</p>
<ul>
<li>对象创建之后就不可以更改</li>
<li>对象所有的域都是final 类型的</li>
<li>对象是正确构造的（在对象的创建期间， this 引用没有逸出）</li>
</ul>
<p>使用 volatile 发布不可变对象可以保证线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Test1 test1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer mapTest1;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(Integer i, Test1 t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test1 = t;</span><br><span class="line">        <span class="keyword">this</span>.mapTest1 = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">int2Test</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  mapTest1 == i? test1 : NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面所有域都是不可变的， 创建之后不可修改， 构造的时候没有溢出， 因此是一个不可变类</p>
<p>因此是线程安全的！</p>
<p><strong>安全发布</strong></p>
<p>不可变对象可以被安全地发布， java内存模式提供初始化安全的保证。</p>
<p>（final 指向的域是可变的， 那么指向的域也需要同步）</p>
<p><strong>安全发布的常用模式</strong>：</p>
<ul>
<li>在静态初始化函数中初始化一个对象的引用（JVM 存在同步机制，在初始话阶段执行！一定安全）</li>
<li>将对象的引用保存在volatile 类型的域 或者 AtomicReferance 对象中</li>
<li>将对象的引用保存到某个正确构造对象的final 类型域中</li>
<li>将对象的引用保存到由一个锁保护的域中</li>
</ul>
<p><strong>事实不可变对象</strong>必须通过安全的方式发布</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Date&gt; name2date =</span><br><span class="line">    Collections.synchronizedMap(<span class="keyword">new</span> HashMa&lt;String, Date());</span><br></pre></td></tr></table></figure>





<h3 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h3><p><strong>设计线程安全的类：</strong></p>
<ul>
<li>找出构成对象状态的所有变量</li>
<li>找出约束状态变量的不变性条件</li>
<li>建立对象状态的并发访问管理策略</li>
</ul>
<p><strong>实例封装：</strong></p>
<p>将数据封装在对象的内部， 将数据的访问限制在对象的方法上， 从而确保线程安全</p>
<p><strong>java监视器模式：</strong></p>
<p>对变量的封装通过 方法来执行， 而这些方法都是同步的！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronzed <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronzed <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">long</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用私有锁来保护变量：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object myLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        synchronzed(myLock)&#123;</span><br><span class="line">            <span class="comment">// 访问 保护的变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比监视器模式， 程序的维护较难， 检查是否正确时要检查整个程序而不是单个类（其它类可以通过方法获取lock  ）。</p>
<p>以上都是一个类的情况</p>
<hr>
<p>如果有多个类，<strong>基于委托</strong>， 将线程的安全委托给别的类来处理，如将数据放入concurrentHashMap中。</p>
<p>多个线程安全的类组合在一起，不一定线程安全， 要视情况而定：</p>
<ul>
<li>当多个变量之间有约束条件时， 组合在一起就不线程安全了！</li>
</ul>
<h3 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h3><h4 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h4><p>包括 Vector 和 Hashtable， 这些整个类是线程安全的，符合操作也是线程安全的！</p>
<p><strong>存在问题</strong></p>
<p>getValue 和 removeValue 两个方法的复合操作都是线程安全，但是组合在一起时，如果并发执行， 有可能一个线程先remov最后一个元素， 而继续getValue！</p>
<p>还有一种情况在迭代的时候产生， 一个线程迭代元素，另一个线程删除了某一个元素， 会报错！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)&#123;</span><br><span class="line">    vector.get(i);</span><br><span class="line">    <span class="comment">//当i 进入到了最后一个元素，但还没有get， 此时跳到另一个线程，删了它，再回到这里 get一个没有的元素！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toString 也是一个隐藏的迭代器！</p>
<p>如果要安全地迭代同步容器类， 可以在客户端给整个容器加锁， 加锁之后，其它操作访问不到， 但这样效率低下，当容器很大的时候！</p>
<p>引出：</p>
<h4 id="并发容器类"><a href="#并发容器类" class="headerlink" title="并发容器类"></a>并发容器类</h4><h5 id="concurentHashMap"><a href="#concurentHashMap" class="headerlink" title="concurentHashMap"></a><strong>concurentHashMap</strong></h5><p>对于HashMap，如果散列函数设计的不好，都散列到了同一条的散列表上，当遍历这条散列表时，其它的线程不能访问这条散列表， 导致效率低下！</p>
<p> concurrentHashMap 没有实现对map的加锁访问，不是在每一个方法上同步， 而是使用分段锁！（详见分段锁）</p>
<h5 id="CopyOnWhiteArrayList"><a href="#CopyOnWhiteArrayList" class="headerlink" title="CopyOnWhiteArrayList"></a>CopyOnWhiteArrayList</h5><p>顾名思义， 在写的时候会复制一遍，迭代线程和修改线程不会相互影响！</p>
<h4 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h4><h5 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><strong>CountDownLatch</strong></h5><p>闭锁可以让所有的线程都到达时执行！</p>
<p>初始化为一个正数， 代表等待的线程， 当没有等待线程的时候继续运行！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Latch</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch startLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch endLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()  -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    startLatch.await();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: i am here!!&quot;</span>);</span><br><span class="line">                    endLatch.countDown();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start, end;</span><br><span class="line">        start = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;start count!!!&quot;</span>);</span><br><span class="line">        startLatch.countDown();</span><br><span class="line">        endLatch.await();</span><br><span class="line">        end = System.nanoTime();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Latch test = <span class="keyword">new</span> Latch();</span><br><span class="line">        test.calc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><p>栅栏是所有线程到达栅栏位置才能继续执行, 栅栏是可以重复使用的， 初始化的时候等待n个线程和等待到n个线程运行的任务！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Barrier</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Barrier</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, () -&gt;&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;this is barrier!!! end&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meeting</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: i am here!!&quot;</span>);</span><br><span class="line">                   <span class="keyword">try</span>&#123;</span><br><span class="line">                       <span class="keyword">this</span>.cyclicBarrier.await();</span><br><span class="line">                   &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                       System.out.println(e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).start();</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Barrier barrier = <span class="keyword">new</span> Barrier();</span><br><span class="line">        barrier.meeting();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="Semphore"><a href="#Semphore" class="headerlink" title="Semphore"></a>Semphore</h5><p>二值信号量相当于一把锁， 信号量可以通过， 锁和条件变量实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line">    TestSemaphore()&#123;</span><br><span class="line">        <span class="keyword">this</span>.list =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.sem = <span class="keyword">new</span> Semaphore(<span class="number">10</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sem.acquire();</span><br><span class="line">            list.add(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestSemaphore testSemaphore = <span class="keyword">new</span> TestSemaphore();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                testSemaphore.addOne();</span><br><span class="line">                System.out.println(<span class="string">&quot;addone cur size:&quot;</span> + testSemaphore.list.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                testSemaphore.removeOne();</span><br><span class="line">                System.out.println(<span class="string">&quot;removeone cur size:&quot;</span> + testSemaphore.list.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h5><p>exchanger 可以交换一个数据， 当交换数据的时候只要有一个线程没有到达时，会阻塞！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExchanger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a is running&quot;</span>);</span><br><span class="line">        String value = <span class="string">&quot;helloa&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">this</span>.exchanger.exchange(value);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b is running&quot;</span>);</span><br><span class="line">        String value = <span class="string">&quot;hellob&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String temp = <span class="keyword">this</span>.exchanger.exchange(value);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestExchanger te= <span class="keyword">new</span> TestExchanger();</span><br><span class="line">        <span class="keyword">new</span> Thread(te::a).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(te::b).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="FetureTast"><a href="#FetureTast" class="headerlink" title="FetureTast"></a>FetureTast</h5><p>有返回值的闭锁， 新建立一个线程提前运行所要的值， 之后get的时候， 会阻塞等待值的返回！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFuture</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">private</span> Thread thread = <span class="keyword">new</span> Thread(future);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">return</span>  future.get();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestFuture testFuture = <span class="keyword">new</span> TestFuture();</span><br><span class="line">        testFuture.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;feture started!!!&quot;</span>);</span><br><span class="line">        System.out.println(testFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="结构化并发应用程序"><a href="#结构化并发应用程序" class="headerlink" title="结构化并发应用程序"></a>结构化并发应用程序</h2><h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><p>ThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>五、Queuing 队列</strong></p>
<p>BlockingQueu用于存放提交的任务，队列的实际容量与线程池大小相关联。</p>
<ul>
<li>如果当前线程池任务线程数量小于核心线程池数量，执行器总是优先创建一个任务线程，而不是从线程队列中取一个空闲线程。</li>
<li>如果当前线程池任务线程数量大于核心线程池数量，执行器总是优先从运行线程队列中取一个空闲线程，而不是创建一个任务线程。</li>
<li>如果当前线程池任务线程数量大于核心线程池数量，且运行队列中无空闲任务线程，将会创建一个任务线程，直到超出maximumPoolSize，当超出maxinumPoolSize 时， 放入队列， 如果此时队列是有界的</li>
</ul>
<p>主要有三种队列策略：</p>
<ol>
<li><p><strong>Direct handoffs 直接握手队列</strong><br> Direct handoffs 的一个很好的默认选择是 SynchronousQueue，它将任务交给线程而不需要保留。这里，如果没有线程立即可用来运行它，那么排队任务的尝试将失败，因此将构建新的线程。<br> 此策略在处理可能具有内部依赖关系的请求集时避免锁定。Direct handoffs 通常需要无限制的maximumPoolSizes来避免拒绝新提交的任务。</p>
<p> **注意: **当任务持续以平均提交速度大余平均处理速度时，会导致线程数量会无限增长问题。</p>
</li>
<li><p><strong>Unbounded queues 无界队列</strong><br> 当所有corePoolSize线程繁忙时，使用无界队列（例如，没有预定义容量的LinkedBlockingQueue）将导致新任务在队列中等待，从而导致maximumPoolSize的值没有任何作用。当每个任务互不影响，完全独立于其他任务时，这可能是合适的; 例如，在网页服务器中， 这种队列方式可以用于平滑瞬时大量请求。<strong>但得注意，当任务持续以平均提交速度大余平均处理速度时，会导致队列无限增长问题。</strong></p>
</li>
<li><p><strong>Bounded queues 有界队列</strong><br> 一个有界的队列（例如，一个ArrayBlockingQueue）和有限的maximumPoolSizes配置有助于防止资源耗尽，但是难以控制。队列大小和maximumPoolSizes需要 相互权衡：</p>
</li>
</ol>
<ul>
<li>使用大队列和较小的maximumPoolSizes可以最大限度地减少CPU使用率，操作系统资源和上下文切换开销，但会导致人为的低吞吐量。如果任务经常被阻塞（比如I/O限制），那么系统可以调度比我们允许的更多的线程。</li>
<li>使用小队列通常需要较大的maximumPoolSizes，这会使CPU更繁忙，但可能会遇到不可接受的调度开销，这也会降低吞吐量。</li>
</ul>
<p><strong>Rejected tasks 拒绝任务</strong><br> 拒绝任务有两种情况：1. 线程池已经被关闭；2. 任务队列已满且maximumPoolSizes已满；<br> 无论哪种情况，都会调用RejectedExecutionHandler的rejectedExecution方法。预定义了四种处理策略：</p>
<ol>
<li><strong>AbortPolicy</strong>：默认测策略，抛出RejectedExecutionException运行时异常；</li>
<li><strong>CallerRunsPolicy</strong>：这提供了一个简单的反馈控制机制，可以减慢提交新任务的速度；</li>
<li><strong>DiscardPolicy</strong>：直接丢弃新提交的任务；</li>
<li><strong>DiscardOldestPolicy</strong>：如果执行器没有关闭，队列头的任务将会被丢弃，然后执行器重新尝试执行任务（如果失败，则重复这一过程）；<br> 我们可以自己定义RejectedExecutionHandler，以适应特殊的容量和队列策略场景中。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>计网总结</title>
    <url>/2019/02/28/notepad/network/%E8%AE%A1%E7%BD%91%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<h1 id="计网总结"><a href="#计网总结" class="headerlink" title="计网总结"></a>计网总结</h1><p>javaguide 上的总结的很好，直接拿来充博客用！ 来自： <a class="link"   href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" >https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络<i class="fas fa-external-link-alt"></i></a></p>
<p>[toc]</p>
<h2 id="一-OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#一-OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="一 OSI与TCP/IP各层的结构与功能,都有哪些协议?"></a>一 OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="五层体系结构"></p>
<p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p>
<h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>
<p><strong>域名系统</strong></p>
<blockquote>
<p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a class="link"   href="http://www.ibm.com、oracle/" >www.ibm.com、Oracle<i class="fas fa-external-link-alt"></i></a> 公司的域名是 <a class="link"   href="http://www.oracle.com、cisco公司的域名是/" >www.oracle.com、Cisco公司的域名是<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="http://www.cisco.com/" >www.cisco.com<i class="fas fa-external-link-alt"></i></a> 等。</p>
</blockquote>
<p><strong>HTTP协议</strong></p>
<blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p>
</blockquote>
<h3 id="1-2-运输层"><a href="#1-2-运输层" class="headerlink" title="1.2 运输层"></a>1.2 运输层</h3><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p><strong>运输层主要使用以下两种协议:</strong></p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>
</ol>
<p><strong>TCP 与 UDP 的对比见问题三。</strong></p>
<h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>
<p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p>
<h3 id="1-4-数据链路层"><a href="#1-4-数据链路层" class="headerlink" title="1.4 数据链路层"></a>1.4 数据链路层</h3><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。<br>控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h3 id="1-5-物理层"><a href="#1-5-物理层" class="headerlink" title="1.5 物理层"></a>1.5 物理层</h3><p>在物理层上所传送的数据单位是比特。<br> <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p>
<h3 id="1-6-总结一下"><a href="#1-6-总结一下" class="headerlink" title="1.6 总结一下"></a>1.6 总结一下</h3><p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：<a class="link"   href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" >https://blog.csdn.net/yaopeng_2005/article/details/7064869<i class="fas fa-external-link-alt"></i></a></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="七层体系结构图"></p>
<h2 id="二-TCP-三次握手和四次挥手-面试常客"><a href="#二-TCP-三次握手和四次挥手-面试常客" class="headerlink" title="二 TCP 三次握手和四次挥手(面试常客)"></a>二 TCP 三次握手和四次挥手(面试常客)</h2><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<h3 id="2-1-TCP-三次握手漫画图解"><a href="#2-1-TCP-三次握手漫画图解" class="headerlink" title="2.1 TCP 三次握手漫画图解"></a>2.1 TCP 三次握手漫画图解</h3><p>如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)。<br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p>
<p><strong>简单示意图：</strong><br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="TCP三次握手"></p>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<h3 id="2-2-为什么要三次握手"><a href="#2-2-为什么要三次握手" class="headerlink" title="2.2 为什么要三次握手"></a>2.2 为什么要三次握手</h3><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h3 id="2-3-为什么要传回-SYN"><a href="#2-3-为什么要传回-SYN" class="headerlink" title="2.3 为什么要传回 SYN"></a>2.3 为什么要传回 SYN</h3><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="2-4-传了-SYN-为啥还要传-ACK"><a href="#2-4-传了-SYN-为啥还要传-ACK" class="headerlink" title="2.4 传了 SYN,为啥还要传 ACK"></a>2.4 传了 SYN,为啥还要传 ACK</h3><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP四次挥手"></p>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h3 id="2-5-为什么要四次挥手"><a href="#2-5-为什么要四次挥手" class="headerlink" title="2.5 为什么要四次挥手"></a>2.5 为什么要四次挥手</h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a class="link"   href="https://blog.csdn.net/qzcsu/article/details/72861891" >https://blog.csdn.net/qzcsu/article/details/72861891<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="三-TCP-UDP-协议的区别"><a href="#三-TCP-UDP-协议的区别" class="headerlink" title="三 TCP,UDP 协议的区别"></a>三 TCP,UDP 协议的区别</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h2 id="四-TCP-协议如何保证可靠传输"><a href="#四-TCP-协议如何保证可靠传输" class="headerlink" title="四 TCP 协议如何保证可靠传输"></a>四 TCP 协议如何保证可靠传输</h2><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。 </li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </li>
<li>TCP 的接收端会丢弃重复的数据。 </li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </li>
</ol>
<h3 id="4-1-ARQ协议"><a href="#4-1-ARQ协议" class="headerlink" title="4.1 ARQ协议"></a>4.1 ARQ协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h4 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h4><ul>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>
</ul>
<p><strong>优点：</strong> 简单</p>
<p><strong>缺点：</strong> 信道利用率低，等待时间长</p>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
<h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h3 id="4-2-滑动窗口和流量控制"><a href="#4-2-滑动窗口和流量控制" class="headerlink" title="4.2 滑动窗口和流量控制"></a>4.2 滑动窗口和流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="4-3-拥塞控制"><a href="#4-3-拥塞控制" class="headerlink" title="4.3 拥塞控制"></a>4.3 拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>
<li><strong>快重传与快恢复：</strong><br> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h2 id="五-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客"><a href="#五-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客" class="headerlink" title="五  在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)"></a>五  在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</h2><p>百度好像最喜欢问这个问题。</p>
<blockquote>
<p>打开一个网页，整个过程会使用哪些协议</p>
</blockquote>
<p>图解（图片来源：《图解HTTP》）：</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url输入到展示出来的过程.jpg" style="zoom:50%;" />

<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这篇文章：</p>
<ul>
<li><a class="link"   href="https://segmentfault.com/a/1190000006879700" >https://segmentfault.com/a/1190000006879700<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="六-状态码"><a href="#六-状态码" class="headerlink" title="六 状态码"></a>六 状态码</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="状态码"></p>
<h2 id="七-各种协议与HTTP协议之间的关系"><a href="#七-各种协议与HTTP协议之间的关系" class="headerlink" title="七 各种协议与HTTP协议之间的关系"></a>七 各种协议与HTTP协议之间的关系</h2><p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p>
<p>图片来源：《图解HTTP》</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种协议与HTTP协议之间的关系"></p>
<h2 id="八-HTTP长连接-短连接"><a href="#八-HTTP长连接-短连接" class="headerlink" title="八  HTTP长连接,短连接"></a>八  HTTP长连接,短连接</h2><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong> </p>
<p>—— <a class="link"   href="https://www.cnblogs.com/gotodsp/p/6366163.html" >《HTTP长连接、短连接究竟是什么？》<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="九-HTTP是不保存状态的协议-如何保存用户状态"><a href="#九-HTTP是不保存状态的协议-如何保存用户状态" class="headerlink" title="九 HTTP是不保存状态的协议,如何保存用户状态?"></a>九 HTTP是不保存状态的协议,如何保存用户状态?</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP  协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HTTP%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84.png" alt="HTTP是无状态协议"></p>
<h2 id="十-Cookie的作用是什么-和Session有什么区别？"><a href="#十-Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="十 Cookie的作用是什么?和Session有什么区别？"></a>十 Cookie的作用是什么?和Session有什么区别？</h2><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p> <strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="十一-HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#十一-HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="十一 HTTP 1.0和HTTP 1.1的主要区别是什么?"></a>十一 HTTP 1.0和HTTP 1.1的主要区别是什么?</h2><blockquote>
<p>这部分回答引用这篇文章 <a class="link"   href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A" >https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?<i class="fas fa-external-link-alt"></i></a> 的一些内容。</p>
</blockquote>
<p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<ol>
<li><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<h2 id="十二-URI和URL的区别是什么"><a href="#十二-URI和URL的区别是什么" class="headerlink" title="十二 URI和URL的区别是什么?"></a>十二 URI和URL的区别是什么?</h2><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="十三-HTTP-和-HTTPS-的区别？"><a href="#十三-HTTP-和-HTTPS-的区别？" class="headerlink" title="十三 HTTP 和 HTTPS 的区别？"></a>十三 HTTP 和 HTTPS 的区别？</h2><ol>
<li><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>
<li><strong>安全性和资源消耗：</strong> HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
</li>
</ol>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>非常推荐大家看一下 《图解HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a class="link"   href="https://blog.csdn.net/qq_16209077/article/details/52718250" >https://blog.csdn.net/qq_16209077/article/details/52718250<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/zixiaomuwu/article/details/60965466" >https://blog.csdn.net/zixiaomuwu/article/details/60965466<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/turn__back/article/details/73743641" >https://blog.csdn.net/turn__back/article/details/73743641<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A" >https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>DDIA</title>
    <url>/2020/12/03/notepad/read/DDIA.mm/</url>
    <content><![CDATA[<h1 id="数据密集型应用学习笔记"><a href="#数据密集型应用学习笔记" class="headerlink" title="数据密集型应用学习笔记"></a>数据密集型应用学习笔记</h1><h2 id="陈杰"><a href="#陈杰" class="headerlink" title="陈杰"></a>陈杰</h2><h2 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h2><blockquote>
<p> 当今许多应用大多是数据数据密集（data-intensive）而不是计算密集型（compute-intensive）的。所以CPU的处理能力往往不是应用程序的瓶颈。关键在于数据的量、数据的复杂度以及数据的快速多变性。</p>
</blockquote>
<ul>
<li>应用往往包含以下模块：</li>
</ul>
<ol>
<li>数据库：用于存储数据</li>
<li>高速缓存：缓存复杂或者操作代价昂贵的结果，加快下一次访问</li>
<li>索引：用户可以按照关键字搜索数据并支持各种过滤</li>
<li>流式处理：持续发送消息到另一个进程，处理采用异步方式</li>
<li>批处理：定期处理大量积累的数据</li>
</ol>
<h3 id="认识数据系统"><a href="#认识数据系统" class="headerlink" title="认识数据系统"></a>认识数据系统</h3><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20201205234835.png" alt="一个数据架构系统，包含了不同的组件"></p>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><blockquote>
<p>出现意外情况，比如硬件、软件故障、人为失误等，系统可以继续正常运转，至少确保功能正确。</p>
</blockquote>
<h4 id="硬件故障"><a href="#硬件故障" class="headerlink" title="硬件故障"></a>硬件故障</h4><blockquote>
<p>比较容易出现的，硬盘崩溃，内存故障，电网停电。</p>
<p>第一反应是为硬件冗余来减少系统故障率。例如磁盘RAID，服务器双电源，甚至热插拔CPU，数据中心添加备用电源、发电机。</p>
<p>这样当一个组件发生故障时，冗余组件可以快速接管，之后运维人员可以修复或者更换坏掉的组件。</p>
<p>直到最近，采用硬件冗余方案对于大多数应用场景还是足够的，它让单机完全失效的概率降到最低。只要可以把备份迅速恢复到新的机器上，故障的停机时间在大多数应用中并不是灾难性的。</p>
<p>现在，通过软件容错的方式来容易多机失效成为新的手段，或者成为硬件容错方案的有力补充。例如滚动升级。</p>
</blockquote>
<h4 id="软件错误"><a href="#软件错误" class="headerlink" title="软件错误"></a>软件错误</h4><blockquote>
<p>这类故障更难预料。各个节点直接是由软件关联的，可能会导致更多的系统故障。</p>
</blockquote>
<ul>
<li>例如，</li>
</ul>
<ol>
<li>由于软件错误，导致特定的输入引发应用的崩溃。例如Linux内核bug，在2012年6月30的闰秒时候触发，导致很多应用程序被挂掉。</li>
<li>失控的进程把系统的资源耗尽，导致这些共享资源不能被释放。</li>
<li>系统的Dependency出了问题，返回值异常。</li>
<li>组件中的小故障触发另一个组件中的故障，进而触发更多的故障。</li>
</ol>
<ul>
<li>没有快速的解决方法。只能仔细考虑很多细节。</li>
</ul>
<ol>
<li>检查系统的假设条件和系统之间的交互</li>
<li>进行全面的测试</li>
<li>进程隔离，</li>
<li>允许进程崩溃后自动重启</li>
<li>反复评估、监控并分析生产环境中的行为表现。</li>
</ol>
<p>例如消息队列中，输出消息的数量应等于输入消息的数量。如果发现不一致，则立即告警。</p>
<h4 id="人为失误"><a href="#人为失误" class="headerlink" title="人为失误"></a>人为失误</h4><blockquote>
<p>人无法做到万无一失。运维人员的配置错误可能是系统下线的第一大原因。</p>
<p>要保证系统可靠，如何减少人为错误对它的影响？</p>
</blockquote>
<ol>
<li>用最小出错的方式来设计系统。让做错事更难。</li>
<li>想办法分离最容易出错的地方，容易引发故障的接口。使用Sandbox隔离真正的生产和测试环境。</li>
<li>充分的测试。单元测试，集成测试，手动测试。边界条件的考虑。</li>
<li>当出现人为失误时，有快速回滚或者回复的机制。滚动发布新代码。</li>
<li>监控子系统需要详细和清晰。</li>
<li>推行管理流程和相关培训。</li>
</ol>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><blockquote>
<p>随着规模的增长，例如数据量、流量和复杂性，系统应该可以用合理的方式进行应对，满足这种增长。</p>
<p>当应用负载增加的时候，比如用户从1w到100w，从100w到1000w，应用程序如何应对增长的负载。</p>
<p>相关参数：Web服务的QPS，数据库的写入比例，DAU，缓存命中率。有时候平均值很重要，有时候短时间内的峰值会成为系统瓶颈。</p>
<p>Twitter的Fan-out结构，对数据量提出了挑战。当一个人发Tweet时候，怎么处理Timeline这个请求。根据粉丝的数量，区别处理。</p>
</blockquote>
<h4 id="描述性能"><a href="#描述性能" class="headerlink" title="描述性能"></a>描述性能</h4><ul>
<li>系统负载增加后，会发生什么，两种思考方式</li>
</ul>
<ol>
<li>系统资源不变（CPU，内存，带宽），系统的性能会发生什么变化？</li>
<li>如果要保持性能不变，需要增加多少资源？</li>
</ol>
<ul>
<li>不同类型的系统关心的性能指标不同</li>
</ul>
<ol>
<li>批处理系统通常关心<strong>吞吐量（throughput）</strong>，例如Hadoop，每秒可以处理多少条数据或者完成一个作业总共需要多少时间。</li>
<li>Online系统中，更看重服务的<strong>响应时间（response time）</strong>，即客户端从发出请求到得到回复的总时间。</li>
</ol>
<p><a href="https://guoyongxin.github.io/2019/04/20/DDIA-1-%E5%8F%AF%E9%9D%A0%E5%8F%AF%E6%89%A9%E5%B1%95%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4.png"><img src="https://guoyongxin.github.io/2019/04/20/DDIA-1-%E5%8F%AF%E9%9D%A0%E5%8F%AF%E6%89%A9%E5%B1%95%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4.png" alt="展示了一个服务100次请求响应时间的均值与百分位数、中位数">展示了一个服务100次请求响应时间的均值与百分位数、中位数</a></p>
<ul>
<li><p>对于响应时间，如下图，有一些很长的，算异常请求，可能是由于数据大很多。但也有可能是其他因素造成的，例如上下文切换、进程调度、网络丢包、TCP重传、垃圾回收STW，缺页中断、磁盘IO。</p>
</li>
<li><p>最好使用百分位数，中位数（50%）来评估系统的响应时间。</p>
</li>
<li><p>采用较高的响应时间百分位数很重要，因为直接影响用户的总体服务体验。例如亚马逊采用99.9百分位来定义服务响应时间。优化99.9%的目标可能成本很高。能不能带来收益很关键。</p>
</li>
<li><p>排队延迟（queueing delay）通常占了高百分位点处响应时间的很大一部分。由于服务器只能并行处理少量的事务（如受其CPU核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为头部阻塞（head-of-line blocking）</p>
</li>
</ul>
<h4 id="应对负载增加"><a href="#应对负载增加" class="headerlink" title="应对负载增加"></a>应对负载增加</h4><ul>
<li><p>垂直扩展和水平扩展。</p>
</li>
<li><p>好的系统有弹性特征，可以自动检测负载的变化，来自动添加更多的计算资源。</p>
</li>
<li><p>可扩展架构通常都是从通用模块逐步构建出来的。</p>
</li>
</ul>
<h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><blockquote>
<p>项目会随着时间的推移，项目会需要新的人员参与到开发和运维工作中，来满足系统的稳定和新场景的适应。系统应该高效的变化。</p>
<p>软件的大部分开销并不在最初的开发阶段，而是在持续的维护阶段，包括修复漏洞、保持系统正常运行、调查失效、适配新的平台、为新的场景进行修改、偿还技术债、添加新的功能等等。</p>
<p>为此，我们将特别关注软件系统的三个设计原则：</p>
</blockquote>
<h4 id="可操作性（Operability）"><a href="#可操作性（Operability）" class="headerlink" title="可操作性（Operability）"></a>可操作性（Operability）</h4><blockquote>
<p> 便于运维团队保持系统平稳运行。</p>
<p>良好的可操作性意味着更轻松的日常工作，进而运维团队能专注于高价值的事情。</p>
<p>数据系统可以通过各种方式使日常任务更轻松</p>
</blockquote>
<h4 id="简单性（Simplicity）"><a href="#简单性（Simplicity）" class="headerlink" title="简单性（Simplicity）"></a>简单性（Simplicity）</h4><ul>
<li>从系统中消除尽可能多的复杂度（complexity），使新工程师也能轻松理解系统。（注意这和用户接口的简单性不一样。）<br><strong>复杂度（complexity）</strong>有各种可能的症状，例如：状态空间激增、模块间紧密耦合、纠结的依赖关系、不一致的命名和术语、解决性能问题的Hack、需要绕开的特例等等，</li>
</ul>
<h4 id="可演化性（evolability）"><a href="#可演化性（evolability）" class="headerlink" title="可演化性（evolability）"></a>可演化性（evolability）</h4><ul>
<li><p> 使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为可扩展性（extensibility），可修改性（modifiability）或可塑性（plasticity）。</p>
</li>
<li><p>组织流程方面，敏捷开发，TDD，重构。</p>
</li>
<li><p>修改数据系统并使其适应不断变化需求的容易程度，是与简单性和抽象性密切相关的：简单易懂的系统通常比复杂系统更容易修改</p>
</li>
</ul>
<h2 id="第3章"><a href="#第3章" class="headerlink" title="第3章"></a>第3章</h2><h3 id="数据库核心：-数据结构"><a href="#数据库核心：-数据结构" class="headerlink" title="数据库核心： 数据结构"></a>数据库核心： 数据结构</h3><blockquote>
<p>一个最简单的数据库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">db_set</span></span> () &#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>,<span class="variable">$2</span>&quot;</span> &gt;&gt; database</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">db_get</span></span> () &#123;</span><br><span class="line">	grep <span class="string">&quot;^<span class="variable">$1</span>,&quot;</span> database | sed -e <span class="string">&quot;s/^<span class="variable">$1</span>,//&quot;</span> | tail -n 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>db_set</p>
<ul>
<li>追加到文件尾部方式通常足够高效， 因而db_set函数性能很好。</li>
<li>与db_set相似， 许多数据库内部都使用日志(log) , 日志是一个仅支持追加式更新的数据文件</li>
</ul>
</li>
<li><p>db_get</p>
<ul>
<li>db_get函数的性能会非常差。</li>
<li>每次想查找一个键， db_get必须从头到尾扫描整个数据库文件来查找键的出现位置, 查找的开销是O(n)。</li>
</ul>
</li>
</ul>
<p>如何解决查找缓慢？ </p>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><blockquote>
<p>可以提供高性能的读和写， 只要所有的key可以放入内存（因为hash map需要保存在内存中）</p>
</blockquote>
<ul>
<li>引入新的问题<ul>
<li>哈希表必须全部放入内存， 如果有大量的键， 就没那么幸运了。</li>
<li>很难使磁盘上的hash map表现良好，需要大量的随机访问I/0。</li>
<li>当哈希变满时，增长代价昂贵，并且哈希冲突时需要复杂的处理逻辑。</li>
<li>区间查询效率不高。不能简单地扫描a和z区间内的所有键，只能采用逐个查找的方式查询每一个键。</li>
</ul>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>使用限制，用作存储点击量，访问量</li>
</ul>
<h4 id="SSTable和-LSM-Tree"><a href="#SSTable和-LSM-Tree" class="headerlink" title="SSTable和 LSM-Tree"></a>SSTable和 LSM-Tree</h4><blockquote>
<p><strong>键值对的序列按键排序</strong>。这就是<strong>SSTables（Sorted String Tables）</strong>的数据格式。我们还要求同一个key只会出现在一个段中。</p>
</blockquote>
<h5 id="SSTables优点："><a href="#SSTables优点：" class="headerlink" title="SSTables优点："></a>SSTables优点：</h5><ol>
<li>合并段更简单。就像merge sort一样。</li>
<li>查找数据使用二分查找</li>
<li>压缩时，可以利用稀疏索引，降低了IO带宽。</li>
</ol>
<h5 id="构建和维护SSTables"><a href="#构建和维护SSTables" class="headerlink" title="构建和维护SSTables"></a>构建和维护SSTables</h5><p>要解决排序问题。方法是，</p>
<ol>
<li>在内存中保存一个排序结构，比如红黑树，AVL树。</li>
<li>在插入修改时候可以很快的响应。</li>
<li>可以顺序的读区它们。</li>
</ol>
<h5 id="存储引擎工作流程"><a href="#存储引擎工作流程" class="headerlink" title="存储引擎工作流程"></a>存储引擎工作流程</h5><ol>
<li>写入时，将数据加入内存表中，可以是红黑树实现。</li>
<li>当内存中的红黑树大小超过阀值时，把它用SSTable的格式写入磁盘。</li>
<li>处理读请求时，先尝试查询内存表，如果miss就查询磁盘段文件s。</li>
<li>周期性的执行合并和压缩。丢弃被覆盖和删除的值。</li>
</ol>
<h5 id="实现LSM-Tree（Log-structured-Merge-Tree）"><a href="#实现LSM-Tree（Log-structured-Merge-Tree）" class="headerlink" title="实现LSM-Tree（Log-structured Merge-Tree）"></a>实现LSM-Tree（Log-structured Merge-Tree）</h5><ul>
<li><p>LevelDB，RocksDB，HBase， 都源于Google的BigTable论文。最初这个索引结构在早起的系统中被命名LSM-Tree。因此，基于合并和压缩的排序文件原理的存储引擎，通常都被称作LSM存储引擎。</p>
</li>
<li><p>全文搜索，Lucene是ElasticSearch和Solr的索引引擎。采用了类似的方法保存字典。全文索引复杂的多，但想法类似。</p>
</li>
</ul>
<h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><ol>
<li>查询不存在的key时，会从内存开始扫描到磁盘的最后一个段。解决方法是，Bloom Filter。</li>
<li>压缩合并的时机。分为大小分级和分层压缩两个方法。一个是小的SSTables被连续合并到大的旧的SSTables。另一个是key的范围分裂成多个更小的SSTables，旧数据被移动到单独的层级。</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul>
<li>由于数据是按照排序存储，因此可以高效的执行区间查询。</li>
<li>因为磁盘是顺序写入的，LSM-Tree的写入吞吐量可以非常高。</li>
</ul>
<h4 id="B-trees索引"><a href="#B-trees索引" class="headerlink" title="B-trees索引"></a>B-trees索引</h4><blockquote>
<p>应用最广泛的索引结构。和SSTable一样，B-tree保留按key排，也可以实现高效的范围查询。</p>
<p>B-tree将数据库分解成固定大小的块和页（4KB or more）。这种设计更接近底层硬件，因为磁盘也是固定大小的块的排列。</p>
<p>每个页可以用地址标志，是磁盘地址，而不是内存。这样可以用这些页面引用构造一个树状页面进行索引。索引的根是一个页面，之后的查找根据地址，读取相应的页。</p>
<p>分支因子：大多数数据库的索引适合3-4层的B-tree.因此不需要遍历非常深的页面层次即可找到所需的页。</p>
<ul>
<li> B树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</li>
<li>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</li>
</ul>
</blockquote>
<h5 id="使B-tree可靠"><a href="#使B-tree可靠" class="headerlink" title="使B-tree可靠"></a>使B-tree可靠</h5><ul>
<li><p>B-tree底层的基本操作是使用新数据覆盖磁盘的旧页。磁盘是覆盖扇区，对于SSD，擦除和重写的存储芯片块很大，情况更复杂。</p>
</li>
<li><p>页面溢出，需要分裂页时，也要覆盖其父页对更新后的两个子页的引用。属于复杂操作。在完成更新前发生崩溃，可能会产生孤儿页面。</p>
</li>
<li><p>崩溃恢复，使用redo Log。写数据之前先写日志。</p>
</li>
<li><p>并发控制。</p>
</li>
</ul>
<h5 id="优化B-tree"><a href="#优化B-tree" class="headerlink" title="优化B-tree"></a>优化B-tree</h5><ol>
<li>一些数据库不是用覆盖页，而是做复制。</li>
<li>保存key的缩略信息而不是完整的key，来节省空间。只需要提供足够的信息来描述key的起止范围。</li>
<li>页可以存在磁盘的任何位置。可能回有随机的IO，而不是连续的。有些B-tree尝试实现对B-tree进行布局，但是随着树的增长，这个顺序会越来越难维护。</li>
<li>添加额外指针。左到右的指针，加速遍历。</li>
</ol>
<h4 id="对比B-tree-LSM-tree"><a href="#对比B-tree-LSM-tree" class="headerlink" title="对比B-tree, LSM-tree"></a>对比B-tree, LSM-tree</h4><blockquote>
<p>根据经验，LSM-Tree写入更快，而B-tree读更快。读取通常在LSM—Tree中较慢，因为要检查多个不同的数据结构和SSTables。</p>
</blockquote>
<h5 id="LSM-Tree优点"><a href="#LSM-Tree优点" class="headerlink" title="LSM-Tree优点"></a>LSM-Tree优点</h5><ol>
<li>LSM只写入一次数据（不考虑写放大（写入引起的压缩和合并）），而B-tree写入两次（一次redo log，一次数据本身）。</li>
<li>LSM可以成熟比B-tree更大的吞吐量。有时具有较低的写放大，顺序写入速度快。</li>
<li>可以支持更好的压缩，文件比B-tree小很多。没有B-tree产生碎片的问题。</li>
</ol>
<h5 id="LSM-Tree缺点"><a href="#LSM-Tree缺点" class="headerlink" title="LSM-Tree缺点"></a>LSM-Tree缺点</h5><ol>
<li>响应延迟不确定，因为压缩和合并。</li>
<li>由于配置问题，会出现压缩跟不上写入速度的问题。来不及合并，直到磁盘空间不足。</li>
<li>事务支持不如B-tree</li>
</ol>
<h4 id="其他索引"><a href="#其他索引" class="headerlink" title="其他索引"></a>其他索引</h4><h5 id="在索引中存储值"><a href="#在索引中存储值" class="headerlink" title="在索引中存储值"></a>在索引中存储值</h5><blockquote>
<p>索引中存储行或则行的具体位置（堆文件法）。将索引行直接存在索引中，聚集索引。MySQL的InnoDB存储引擎中，表的主键是聚集索引，二级索引引用主键。</p>
</blockquote>
<h5 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h5><ul>
<li><p>级联索引，通过将一列追加到另一列，将几个字段组合成一个键。只能从前到后匹配。B-tree和LSM-tree都无法高效的应对这种查询。</p>
</li>
<li><p>更常见的索引空间，R树。PostGIS使用PostgreSQL的广义搜索书索引实现了地理空间索引作为R树。</p>
</li>
</ul>
<h5 id="全文搜索和模糊索引"><a href="#全文搜索和模糊索引" class="headerlink" title="全文搜索和模糊索引"></a>全文搜索和模糊索引</h5><blockquote>
<p>之前的搜索都是准确匹配，而不能应对类似的key的搜索，例如错误的拼写。</p>
<p>Lucene引擎支持在某个编辑距离内的模糊搜索。LevelDB中这个内存中的索引是一些key的稀疏集合。但在Lucene中，内存中的索引是key中的字符串序列的有限状态机，类似字典树。这个自动机可以转换成Leveshtein自动机，支持编辑距离内的搜索。</p>
</blockquote>
<h5 id="在内存中保存所有内容"><a href="#在内存中保存所有内容" class="headerlink" title="在内存中保存所有内容"></a>在内存中保存所有内容</h5><ul>
<li><p>内存数据库。例如Memcached，做缓存。数据在重启后可以恢复。</p>
</li>
<li><p>内存数据可以更快的原因，是因为它们可以避免使用写磁盘的格式对内存数据结构编码的开销。</p>
</li>
<li><p>提供了给予磁盘索引难以实现的数据结构，例如Redis中的优先级队列和集合。</p>
</li>
<li><p>可以使用反缓存的方法，当没有足够的内存时，将一部分不常用数据倒入磁盘，类似操作系统的虚拟内存。</p>
</li>
<li><p>将来的NVM（non-volatile memory）技术广泛的普及，也可能很大的改变存储引擎的设计。</p>
</li>
</ul>
<h3 id="事务处理OLTP与分析处理OLAP"><a href="#事务处理OLTP与分析处理OLAP" class="headerlink" title="事务处理OLTP与分析处理OLAP"></a>事务处理OLTP与分析处理OLAP</h3><blockquote>
<p>事务意味着允许客户端进行低延迟读区和写入，相比于只能周期性的运行的批处理作业。事务不一定具有ACID属性。</p>
<ul>
<li><p>OLTP每次返回<font color='red'>少量的数据</font>，随机访问，低延迟要求。</p>
</li>
<li><p>OLAP对大量数据访问，批量导入（ETL）或事件流，内部分析师，为决策提供支持。</p>
</li>
</ul>
</blockquote>
<h4 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h4><blockquote>
<p>数据仓库是一个单独的数据库，分析师可以在不影响OLTP的情况下，任意使用数据仓库。数据仓库包含公司所有OLTP数据库的只读副本。</p>
<p>单独使用数据仓库的优势在于数据仓库可以针对分析访问模式进行优化。本文前半部分讨论的索引模型只适合与OLTP而不适合做分析查询。</p>
</blockquote>
<h5 id="OLTP数据库和数据仓库的差异"><a href="#OLTP数据库和数据仓库的差异" class="headerlink" title="OLTP数据库和数据仓库的差异"></a>OLTP数据库和数据仓库的差异</h5><ul>
<li><p>数据仓库也支持SQL查询接口，但是和OLTP的实现差异很大。</p>
</li>
<li><p>一些数据库（SQL Server和SAP HANA）在同一产品中支持事务处理和数据仓库。然而，它们是两个独立的存储和查询引擎，只是通过一个SQL接口来访问。</p>
</li>
<li><p>一些商用的数据仓库，Teradata，Vertica，SAP HANA等很贵。还有开源的基于Hadoop的SQL项目，例如Apache Hive，Spark SQL，Cloudera Impala，Facebook Presto，Apache Tajo和Apache Drill. 其中一些是基于Google Dremel而构建的。</p>
</li>
</ul>
<h4 id="星型与雪花型分析模式"><a href="#星型与雪花型分析模式" class="headerlink" title="星型与雪花型分析模式"></a>星型与雪花型分析模式</h4><blockquote>
<p>许多数据仓库都使用了星型模式，也称为维度建模。</p>
<p>这种模式的中心是一个所谓的事实表。事实表的每一行表示在特定时间发生的事件。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20201205232229.png"></p>
<ul>
<li><p>通常，事实被捕获为单独的事件，这样之后的分析具有很大的灵活性。</p>
</li>
<li><p>事实表中的列是属性，其他列可能会引用其他表的外键，成为维度表，这些维度代表事件的发生地点，时间，方式和原因。</p>
</li>
<li><p>名称<strong>星型模式</strong>来源于关系表可视化的适合，事实表位于中间，被一系列维度表包围。</p>
</li>
<li><p>该模型的一个变体成为<strong>雪花模型</strong>，其中维度进一步细分为子空间。例如，dimproduct表中的每一行可以再次向外引用品牌和类型的外键。这样更规范，但是更复杂。分析人员一般首选星型。</p>
</li>
<li><p>典型的数据仓库中，表都非常宽，事实表通常超过100列，甚至几百列。维度表也可能很宽。</p>
</li>
</ul>
<h3 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h3><ol>
<li><p>主要关注事实表的海量数据问题，通常有万亿行、PB级别的数据。</p>
</li>
<li><p>虽然通常事实表超过100列，但是一般一次分析也只会访问其中的4，5列。如何高效的执行这中类型的查询？</p>
</li>
<li><p>OLTP系统中，数据库的存储都是面向行的。如果属性超过100列，那么需要把很多不需要的数据读入内存，然后丢弃。非常低效。</p>
</li>
<li><p>面向列存储，不是将一行的内容存在一起，而是把每一列的所有值存在一起。</p>
</li>
</ol>
<h4 id="列压缩"><a href="#列压缩" class="headerlink" title="列压缩"></a>列压缩</h4><blockquote>
<p>面向列的存储非常适合压缩。一种技术是位图编码。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20201205232510.png"></p>
<ul>
<li><p>每一个不同的值一个位图，位图的位数是行数。</p>
</li>
<li><p>Bigtable模型仍然主要是面向行的。</p>
</li>
</ul>
<h5 id="内存带宽和矢量化处理"><a href="#内存带宽和矢量化处理" class="headerlink" title="内存带宽和矢量化处理"></a>内存带宽和矢量化处理</h5><ul>
<li>除了减少需要从磁盘加载的数据量之外，列存储也有利于高效利用CPU的周期性。</li>
</ul>
<h4 id="列存储中的排序"><a href="#列存储中的排序" class="headerlink" title="列存储中的排序"></a>列存储中的排序</h4><ul>
<li>列的存储如果是按照某个常见的顺序，例如date，就可以做类似于SSTables的索引机制。注意单独排序某列没用，需要正行排序。</li>
</ul>
<p>– 数据仓库管理员需要基于经验选择合适的排序列，可以单列也可以是多列。这样查询优化器可以更高效。</p>
<ul>
<li>另一个好处是可以进行压缩。可以进行游程编码，位图那样。</li>
</ul>
<h5 id="几种不同的排序"><a href="#几种不同的排序" class="headerlink" title="几种不同的排序"></a>几种不同的排序</h5><ol>
<li>C-Store的改进。用不同的方式存储相同的数据。使不同的排序查询都获益。也就是通过排序后的冗余数据加速。</li>
<li>列排序，类似于面向行的二级索引。区别是，列的索引中，存的是值而不是地址。</li>
</ol>
<h4 id="列存储与写操作"><a href="#列存储与写操作" class="headerlink" title="列存储与写操作"></a>列存储与写操作</h4><ul>
<li><p>上述的优化，都是对读的优化，这会让写变得更困难。类似B-tree的就地更新的操作，对压缩列是不可能的。</p>
</li>
<li><p>一个方案是类似LSM-tree。先写入内存的排序数据结构，然后在一定的时候把内存的数据顺序的倒入磁盘，接着进行有可能的文件合并。这样查询的时候需要检查内存中的数据，和磁盘中的数据。这对于查询方是透明的。</p>
</li>
</ul>
<h4 id="聚合：数据立方体和物化视图"><a href="#聚合：数据立方体和物化视图" class="headerlink" title="聚合：数据立方体和物化视图"></a>聚合：数据立方体和物化视图</h4><ul>
<li><p>数据仓库不是一定要用列存储的。但是列存储因为查询分析更快，所以正在迅速普及。数据仓库另一个方面是物化聚合，就是把常用的查询物理存储化，缓存一些查询结果。</p>
</li>
<li><p>实现：物化视图。 物化视图的常见特例称为数据立方体或OLAP立方。它是按不同维度分组的聚合网格。以沿着每行或每列应用相同的汇总，并获得一个维度减少的汇总（按产品的销售额，无论日期，还是按日期销售，无论产品如何）。</p>
</li>
<li><p>缺点是数据立方体不具有查询原始数据的灵活性。因此，大多数数据仓库试图保留尽可能多的原始数据，并将聚合数据（如数据立方体）仅用作某些查询的性能提升。</p>
</li>
</ul>
<h2 id="第9章-一致性与共识"><a href="#第9章-一致性与共识" class="headerlink" title="第9章 一致性与共识"></a>第9章 一致性与共识</h2><blockquote>
<p> 分布式最庸的抽象之一就是共识： 所有的节点就某一项提议达成一致.</p>
</blockquote>
<h3 id="可线性化"><a href="#可线性化" class="headerlink" title="可线性化"></a>可线性化</h3><blockquote>
<p>也称为原子一致性， 强一致性。</p>
<p>其基本的想法是让一个系统看起来好像只有一个数据副本， 且所有的操作都是原子的。有了这个保证， 应用程序就不需要关心系统内部的多个副本。</p>
</blockquote>
<h4 id="如何达到线性化？"><a href="#如何达到线性化？" class="headerlink" title="如何达到线性化？"></a>如何达到线性化？</h4><blockquote>
<p>可线性化背后的基本思想很简单：使系统看起来好像只有一个数据副本。</p>
</blockquote>
<blockquote>
<p><strong>可线性化与可串行化</strong></p>
<ul>
<li><p>可串行化</p>
<p>可串行化是事务的隔离属性， 其中每个事务可以读写多个对象（行， 文档， 记录等。它用来确保事务执行的结果<font color='red'>与串行执行（即每次执行一个事务）的结果完全相同</font>， 即使串行执行的顺序可能与事务实际执行顺序不同 。</p>
</li>
<li><p>可线性化</p>
<p>可线性化是<font color='red'>读写寄存器（单个对象）的最新值保证</font>。它并不要求将操作组合到事务中， 因此无法避免写倾针等问题 除非采取其他额外措施。</p>
</li>
</ul>
</blockquote>
<h4 id="线性化的依赖条件"><a href="#线性化的依赖条件" class="headerlink" title="线性化的依赖条件"></a>线性化的依赖条件</h4><ul>
<li>加锁与主节点选取</li>
<li>约束与唯一性保证</li>
<li>跨通道的时间依赖</li>
</ul>
<h4 id="实现线性化系统"><a href="#实现线性化系统" class="headerlink" title="实现线性化系统"></a>实现线性化系统</h4><ul>
<li><p>主从复制（部分支持可线性化）</p>
<p>在主从复制的系统中（参阅第5章的“主节点与从节点”) 只有主节点承担数据写入， 从节点则在各自节点上维护数据的备份副本。<strong>如果从主节点或者同步更新的从节点上读取， 则可以满足线性化。</strong>但并非每个主从复制的具体数据库实例都是可线性化的， 主要是因为它们可能采用了快照隔离的设计， 或者实现时存在并发方面的bug 。</p>
<p>而从主节点上读取的前提是你确定知道哪个节点是主节点。正如在第8章“ 真相由多数决定” 中所讨论的， 某节点可能自认为是主节点， 但事实并非如此， 这个“自以为是＂ 的主节点如果对外提供服务， 就会违反线性。</p>
<p>如果使用了异步复制， 故障切换过程中甚至可能会丢失一些已提交的写入，结果是同时违反持久性和线性化。</p>
</li>
<li><p>共识算法（可线性化）</p>
<p>与主从复制机制相似。不过共识协议通常内置一些措施来防止裂脑和过期的副本。正是由于这些专门的设计， 共识算法可以安全地实现线性化存储， 这些系统包括Zo0Keepe r l2 ‘1和etcdl22 」等。</p>
</li>
<li><p>多主复制（不可线性化）</p>
<p>具有多主节点复制的系统通常无法线性化的， 主要由于它们同时在多个节点上执行并发写入， 并将数据异步复制到其他节点。因此它们可能会产生冲突的写入，需要额外的解决方案。这类冲突其实正是多副本所引入的结果。</p>
</li>
<li><p>无主复制（可能不可线性化）</p>
<p>对千无主节点复制的系统（即Dynamo风格， 参阅第5章的“无主节点复制) 有些入认为只要配置法定读取和写入满足(w+r&gt;n)就可以获得“ 强一致性” 。但这完全取决千具体的quorum的配置， 以及如何定义强一致性， 它可能并不保证线性化。</p>
<p>例如基于墙上时钟（包括Cassandra, 参阅第8章“ 依赖于同步的时钟,,)的“ 最后写入获胜＂ 冲突解决方法几乎肯定是非线性化， 因为这种时间戳无法保证与实际事件顺序一致（例如由于时钟偏移）。</p>
<p>不规范的quorum(参阅第5章“ 宽松的quorum与数据回传) 也会破坏线性化。甚至即使是严格的quorum, 正如之后即将介绍的， 也会发生违背线性化的情况。</p>
</li>
</ul>
<h5 id="线性化与-quorum"><a href="#线性化与-quorum" class="headerlink" title="线性化与 quorum"></a>线性化与 quorum</h5><h4 id="线性化的代价"><a href="#线性化的代价" class="headerlink" title="线性化的代价"></a>线性化的代价</h4><h5 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h5>]]></content>
      <categories>
        <category>read</category>
      </categories>
      <tags>
        <tag>DDIA</tag>
      </tags>
  </entry>
  <entry>
    <title>DP</title>
    <url>/2019/12/28/notepad/algorithm/exercise/dp/</url>
    <content><![CDATA[<h1 id="DP-题目汇总"><a href="#DP-题目汇总" class="headerlink" title=" DP 题目汇总 "></a><center> DP 题目汇总 </center></h1><p>记录一些遇到过的dp问题</p>
<p>DP(Dynamic Programming) 一种解决最优化问题的算法思想。</p>
<p>要求： <strong>重叠子问题</strong> &amp;&amp; <strong>最优子结构</strong></p>
<ul>
<li><p>递归： 记忆化搜索</p>
</li>
<li><p>递推： 自底向上</p>
</li>
</ul>
<p>[toc]</p>
<h4 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h4><blockquote>
<p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
</blockquote>
<h4 id="最大连续子序和"><a href="#最大连续子序和" class="headerlink" title="最大连续子序和"></a>最大连续子序和</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dp[i] = max&#123;A[i], dp[i<span class="number">-1</span>] + A[i]&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dp[i] = max&#123;<span class="number">1</span>, dp[j] + <span class="number">1</span>&#125;  (贪心也可以)</span><br></pre></td></tr></table></figure>



<h4 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>, A[i] == B[j]</span><br><span class="line">    		max&#123;dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], A[i] != B[j]&#125;</span><br></pre></td></tr></table></figure>



<h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>], S[i] == S[j]</span><br><span class="line">    		<span class="number">0</span>, S[i] != S[j]</span><br></pre></td></tr></table></figure>



<h4 id="01-背包问题"><a href="#01-背包问题" class="headerlink" title="01 背包问题"></a>01 背包问题</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">d[i][v] = max&#123;dp[i<span class="number">-1</span>][v], dp[i<span class="number">-1</span>][v-w[i]] + c[i]&#125;</span><br></pre></td></tr></table></figure>



<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dp[i][v] = max&#123;dp[i<span class="number">-1</span>], dp[i][v - w[i]] + c[i]&#125;</span><br></pre></td></tr></table></figure>



<h4 id="非相连最大和"><a href="#非相连最大和" class="headerlink" title="非相连最大和"></a>非相连最大和</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sum(k) = max(sum(k – <span class="number">2</span>) + A[k], sum(k – <span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h4 id="leetcode-dp中等专题"><a href="#leetcode-dp中等专题" class="headerlink" title="leetcode - dp中等专题"></a>leetcode - dp中等专题</h4><h5 id="60-不同的二叉搜索树"><a href="#60-不同的二叉搜索树" class="headerlink" title="60.不同的二叉搜索树"></a>60.不同的二叉搜索树</h5><blockquote>
<p>一组数据能够构成二叉树的最多的装填类型</p>
</blockquote>
<p><em>F</em>(<em>i</em>,<em>n</em>)=<em>G</em>(<em>i</em>−1)⋅<em>G</em>(<em>n</em>−<em>i</em>)</p>
<p>把一组数据看成左右和中间一点</p>
<h5 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h5><blockquote>
<p>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
</blockquote>
<p>dp[i + 2] = max(dp[i] + nums[i], dp[i+1]);</p>
<p>对于一家要么偷（取前两个之前最大的和加上前两个）， 要么不偷（取前面一个的就行了）</p>
<h5 id="740-删除与获得点数"><a href="#740-删除与获得点数" class="headerlink" title="740. 删除与获得点数"></a>740. 删除与获得点数</h5><blockquote>
<p>给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
</blockquote>
<p>nums = [2, 2, 3, 3, 3, 4]    变换一下    all=[0, 0, 2, 3, 1];</p>
<p>dp[i + 2] = max(dp[i] + i * nums[i], dp[i+1]);</p>
<p>和打家劫舍一样</p>
<h5 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a>面试题 08.11. 硬币</h5><blockquote>
<p>给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">4</span>; ++c) &#123;</span><br><span class="line">    <span class="keyword">int</span> coin = coins[c];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= n; ++i) </span><br><span class="line">        f[i] = (f[i] + f[i - coin]) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="464-我能赢吗"><a href="#464-我能赢吗" class="headerlink" title="464. 我能赢吗"></a>464. 我能赢吗</h5><blockquote>
<p>在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？</p>
</blockquote>
<p>使用 dfs +  状态记忆就可以了, 太巧秒了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(满足条件) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(dfs(cur + i))&#123;<span class="comment">// 注意这里是输的，状态反过来了</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a>523. 连续的子数组和</h5><blockquote>
<p>给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p>
</blockquote>
<p>1、 使用前缀和的方法，将 O（n^3） 优化为 O（n^ 2）</p>
<p>2、 很巧妙，记录所有前缀和的取余的数据</p>
<p>j –  i 如果是满足答案的， 那么， 前缀和 map[j % k] == map[i % k], 可以证明得到</p>
<h5 id="375-猜数字大小-II"><a href="#375-猜数字大小-II" class="headerlink" title="375. 猜数字大小 II"></a>375. 猜数字大小 II</h5><blockquote>
<p>我们正在玩一个猜数游戏，游戏规则如下：我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。</p>
</blockquote>
<h5 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a>718. 最长重复子数组</h5><blockquote>
<p> 给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>
</blockquote>
<p>dp [i] [j] 表示A 从 i 和  B 从 j的最长的前缀和</p>
<h5 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h5><blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为<strong>摆动序列。</strong>第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
</blockquote>
<p>摆动序列和一个数组的最大乘积和是一样的， 要记录两个状态！！！</p>
<h5 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a>剑指 Offer 14- II. 剪绳子 II</h5><blockquote>
<p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m]</code> 。请问 <code>k[0]*k[1]*...*k[m]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</blockquote>
<p>这道题是一道数学题， 只要一直往3 减去就好了。</p>
<h5 id="983-最低票价"><a href="#983-最低票价" class="headerlink" title="983. 最低票价"></a>983. 最低票价</h5><blockquote>
<p>难度中等237收藏分享切换为英文关注反馈</p>
</blockquote>
<blockquote>
<p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 <code>days</code> 的数组给出。每一项是一个从 <code>1</code> 到 <code>365</code> 的整数。</p>
</blockquote>
<blockquote>
<p>火车票有三种不同的销售方式：</p>
</blockquote>
<ul>
<li>一张为期一天的通行证售价为 <code>costs[0]</code> 美元；</li>
<li>一张为期七天的通行证售价为 <code>costs[1]</code> 美元；</li>
<li>一张为期三十天的通行证售价为 <code>costs[2]</code> 美元。</li>
</ul>
<blockquote>
<p>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
</blockquote>
<p>返回你想要完成在给定的列表 <code>days</code> 中列出的每一天的旅行所需要的最低消费。</p>
<p>我们用 dp*(<em>i</em>) 来表示从第  i  天开始到一年的结束，我们需要花的钱。</p>
<h5 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h5><blockquote>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
</blockquote>
<p>dp[i] [j] 表示在i, j 点的最大大正方形</p>
<p>dp 转移方程只要去左边，左上和上边最小的就可以了</p>
<h5 id="面试题-01-05-一次编辑"><a href="#面试题-01-05-一次编辑" class="headerlink" title="面试题 01.05. 一次编辑"></a>面试题 01.05. 一次编辑</h5><blockquote>
<p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
</blockquote>
<p>dp[i] [j] 表示 第一个字符在 i， 第二个字符在 j 的时候编辑次数, 模拟出删除，替换，和拆入</p>
<h5 id="376-摆动序列-1"><a href="#376-摆动序列-1" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h5><blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为<strong>摆动序列。</strong>第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
</blockquote>
<p>和整数和一样，使用两个记录状态和， 也可以直接贪心， 因为前面的跟后面的没有关系，前面一个是上升的就接着找下一个下降的就行</p>
<h5 id="718-最长重复子数组-1"><a href="#718-最长重复子数组-1" class="headerlink" title="718. 最长重复子数组"></a>718. 最长重复子数组</h5><blockquote>
<p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>
</blockquote>
<p>二维dp</p>
<h5 id="面试题-08-02-迷路的机器人"><a href="#面试题-08-02-迷路的机器人" class="headerlink" title="面试题 08.02. 迷路的机器人"></a>面试题 08.02. 迷路的机器人</h5><blockquote>
<p>设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。</p>
</blockquote>
<p>可以使用 dfs 加上减枝， 也可以使用dfs，相当于 bfs</p>
<h5 id="面试题-17-06-2出现的次数"><a href="#面试题-17-06-2出现的次数" class="headerlink" title="面试题 17.06. 2出现的次数"></a>面试题 17.06. 2出现的次数</h5><blockquote>
<p>编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。</p>
</blockquote>
<p>遍历每一位数字， 计算每一位数字大于2， 等于 2， 小于 2 的情况！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numberOf2sInRange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">1</span>, total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = n/(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> exatnum = n%<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> post = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != post)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exatnum&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            total += (pre+<span class="number">1</span>)*base;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exatnum==<span class="number">2</span>)&#123;</span><br><span class="line">            total += pre*base + post+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            total += pre*base;</span><br><span class="line">        &#125;</span><br><span class="line">        post += exatnum*base;</span><br><span class="line">        exatnum = pre%<span class="number">10</span>;</span><br><span class="line">        pre /= <span class="number">10</span>;</span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="1367-二叉树中的列表"><a href="#1367-二叉树中的列表" class="headerlink" title="1367. 二叉树中的列表"></a>1367. 二叉树中的列表</h5><blockquote>
<p>给你一棵以 <code>root</code> 为根的二叉树和一个 <code>head</code> 为第一个节点的链表。</p>
<p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 <code>head</code> 为首的链表中每个节点的值，那么请你返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p>
</blockquote>
<p>暴力， 没有什么难度</p>
<h5 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a>95. 不同的二叉搜索树 II</h5><blockquote>
<p> 给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p>
</blockquote>
<p>太巧妙了！！！， 递归的优雅之处！！！， <strong>看到停下来，</strong> <strong>再看一遍</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> left = helper(start, i<span class="number">-1</span>), right = helper(i+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a:left) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> b:right) &#123;</span><br><span class="line">                TreeNode* node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                node-&gt;left = a;</span><br><span class="line">                node-&gt;right = b;</span><br><span class="line">                res.push_back(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="1372-二叉树中的最长交错路径"><a href="#1372-二叉树中的最长交错路径" class="headerlink" title="1372. 二叉树中的最长交错路径"></a>1372. 二叉树中的最长交错路径</h5><blockquote>
<p>给你一棵以 <code>root</code> 为根的二叉树，二叉树中的交错路径定义如下：</p>
</blockquote>
<ul>
<li>选择二叉树中 <strong>任意</strong> 节点和一个方向（左或者右）。</li>
<li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</li>
<li>改变前进方向：左变右或者右变左。</li>
<li>重复第二步和第三步，直到你在树中无法继续移动。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxAns;</span><br><span class="line">    <span class="comment">/* 0 =&gt; left, 1 =&gt; right */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* o, <span class="keyword">bool</span> dir, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        maxAns = max(maxAns, len);</span><br><span class="line">        <span class="keyword">if</span> (!dir) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;left) dfs(o-&gt;left, <span class="number">1</span>, len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;right) dfs(o-&gt;right, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;right) dfs(o-&gt;right, <span class="number">0</span>, len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;left) dfs(o-&gt;left, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        maxAns = <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">0</span>); dfs(root, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a>213. 打家劫舍 II</h5><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
</blockquote>
<p>分位两种情况来计算dp！</p>
<h5 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h5><blockquote>
<p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
</blockquote>
<p>二维dp</p>
<h5 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h5><blockquote>
<p> 给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
</blockquote>
<p>dp[i] [j] 表示 从 i 到 j 是一个回文子串</p>
<h5 id="面试题-17-08-马戏团人塔"><a href="#面试题-17-08-马戏团人塔" class="headerlink" title="面试题 17.08. 马戏团人塔"></a>面试题 17.08. 马戏团人塔</h5><p>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> vint = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bestSeqAtIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;vint&gt; <span class="title">k</span><span class="params">(len,vint(<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) k[i][<span class="number">0</span>] = height[i], k[i][<span class="number">1</span>] = weight[i];        </span><br><span class="line">        sort(k.begin(),k.end(),[](<span class="keyword">const</span> vint&amp; a,<span class="keyword">const</span> vint&amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] != b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">vint <span class="title">m</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = lower_bound(m.begin(),m.end(),k[i][<span class="number">1</span>])-m.begin();</span><br><span class="line">            <span class="keyword">if</span>(p == m.size()) m.push_back(k[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> m[p] = k[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h5><blockquote>
<p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p>
</blockquote>
<p>二维dp</p>
<h5 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h5><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。</p>
<p>二维dp</p>
<h5 id="801-使序列递增的最小交换次数"><a href="#801-使序列递增的最小交换次数" class="headerlink" title="801. 使序列递增的最小交换次数"></a>801. 使序列递增的最小交换次数</h5><blockquote>
<p>我们有两个长度相等且不为空的整型数组 <code>A</code> 和 <code>B</code> 。</p>
<p>我们可以交换 <code>A[i]</code> 和 <code>B[i]</code> 的元素。注意这两个元素在各自的序列中应该处于相同的位置。</p>
<p>在交换过一些元素之后，数组 <code>A</code> 和 <code>B</code> 都应该是严格递增的（数组严格递增的条件仅为<code>A[0] &lt; A[1] &lt; A[2] &lt; ... &lt; A[A.length - 1]</code>）。</p>
<p>给定数组 <code>A</code> 和 <code>B</code> ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。</p>
</blockquote>
<p>没懂，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，<br>没懂，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，，</p>
<h5 id="1314-矩阵区域和"><a href="#1314-矩阵区域和" class="headerlink" title="1314. 矩阵区域和"></a>1314. 矩阵区域和</h5><blockquote>
<p>给你一个 <code>m * n</code> 的矩阵 <code>mat</code> 和一个整数 <code>K</code> ，请你返回一个矩阵 <code>answer</code> ，其中每个 <code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和： </p>
</blockquote>
<ul>
<li><code>i - K &lt;= r &lt;= i + K, j - K &lt;= c &lt;= j + K</code> </li>
<li><code>(r, c)</code> 在矩阵内。</li>
</ul>
<p>使用前缀和记录每一个小矩阵的值， easy</p>
<h5 id="931-下降路径最小和"><a href="#931-下降路径最小和" class="headerlink" title="931. 下降路径最小和"></a>931. 下降路径最小和</h5><blockquote>
<p>给定一个<strong>方形</strong>整数数组 <code>A</code>，我们想要得到通过 <code>A</code> 的<em>下降路径</em>的<strong>最小</strong>和。</p>
<p>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。</p>
</blockquote>
<p>easy dp[i] [j] 表示为 在 i， j 位置的最小和</p>
<h5 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a>剑指 Offer 63. 股票的最大利润</h5><blockquote>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
</blockquote>
<p>贪心， 只需要记住之前最小的股票价格就好了</p>
<h5 id="1339-分裂二叉树的最大乘积"><a href="#1339-分裂二叉树的最大乘积" class="headerlink" title="1339. 分裂二叉树的最大乘积"></a>1339. 分裂二叉树的最大乘积</h5><blockquote>
<p>给你一棵二叉树，它的根为 <code>root</code> 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    postOrder(root);</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sums.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 取最大值时不能取模，应该用long型存结果</span></span><br><span class="line">        res = max(res, sums[i] * (sums.back() - sums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(res % mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">postOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> res = root-&gt;val + postOrder(root-&gt;left) + postOrder(root-&gt;right);</span><br><span class="line">    sums.push_back(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太巧妙了， 后序遍历的做法， 太太太太太太太太太太太太巧妙了！！！*<strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<h5 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h5><blockquote>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p><strong>注意:</strong></p>
<ol>
<li>可以认为区间的终点总是大于它的起点。</li>
<li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li>
</ol>
</blockquote>
<p>求最长上升子序列, 模版题记住！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> vint = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> vvint = <span class="built_in">vector</span>&lt;vint&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vvint&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!intervals.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(intervals.begin(), intervals.end(),[](<span class="keyword">const</span> vint&amp; a, <span class="keyword">const</span> vint&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; i : intervals)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(i[<span class="number">0</span>] &lt; end)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i[<span class="number">1</span>] &lt; end) end = i[<span class="number">1</span>];</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>   end = i[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a>646. 最长数对链</h5><blockquote>
<p>给出 <code>n</code> 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p>
<p>现在，我们定义一种跟随关系，当且仅当 <code>b &lt; c</code> 时，数对<code>(c, d)</code> 才可以跟在 <code>(a, b)</code> 后面。我们用这种形式来构造一个数对链。</p>
<p>给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p>
</blockquote>
<p>和上题基本一样， 模版题来的！！！</p>
<h5 id="1477-找两个和为目标值且不重叠的子数组"><a href="#1477-找两个和为目标值且不重叠的子数组" class="headerlink" title="1477. 找两个和为目标值且不重叠的子数组"></a>1477. 找两个和为目标值且不重叠的子数组</h5><blockquote>
<p>给你一个整数数组 <code>arr</code> 和一个整数值 <code>target</code> 。</p>
<p>请你在 <code>arr</code> 中找 <strong>两个互不重叠的子数组</strong> 且它们的和都等于 <code>target</code> 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 <strong>最小值</strong> 。</p>
<p>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 <strong>-1</strong> 。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSumOfLengths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, r = arr.size() - <span class="number">1</span>, ans = <span class="number">200000</span>; </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">len</span><span class="params">(arr.size() + <span class="number">1</span>, <span class="number">200000</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = r; l &gt;= <span class="number">0</span>; --l) &#123; <span class="comment">//l,r是滑动区间的左右坐标</span></span><br><span class="line">        sum += arr[l];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt; target) sum -= arr[r--];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = r - l + <span class="number">1</span>; <span class="comment">//子数组长度</span></span><br><span class="line">            ans = min(ans, cur + len[r + <span class="number">1</span>]); <span class="comment">//子数组长度 + 后面子数组的最小长度</span></span><br><span class="line">            len[l] = min(len[l + <span class="number">1</span>], cur); <span class="comment">//更新子数组的最小长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> len[l] = len[l + <span class="number">1</span>]; <span class="comment">//更新子数组的最小长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == <span class="number">200000</span> ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很巧妙，多看看， 使用滑动窗口解决问题</p>
<h5 id="650-只有两个键的键盘"><a href="#650-只有两个键的键盘" class="headerlink" title="650. 只有两个键的键盘"></a>650. 只有两个键的键盘</h5><blockquote>
<p>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p>
<ol>
<li><code>Copy All</code> (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。</li>
<li><code>Paste</code> (粘贴) : 你可以粘贴你<strong>上一次</strong>复制的字符。</li>
</ol>
<p>给定一个数字 <code>n</code> 。你需要使用最少的操作次数，在记事本中打印出<strong>恰好</strong> <code>n</code> 个 ‘A’。输出能够打印出 <code>n</code> 个 ‘A’ 的最少操作次数。</p>
</blockquote>
<p>steps[n] = steps[i] + n/i, 核心在于找到最大的因子， 这样可以尽可能的少操作数据</p>
<h5 id="712-两个字符串的最小ASCII删除和"><a href="#712-两个字符串的最小ASCII删除和" class="headerlink" title="712. 两个字符串的最小ASCII删除和"></a>712. 两个字符串的最小ASCII删除和</h5><blockquote>
<p>给定两个字符串<code>s1, s2</code>，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p>
</blockquote>
<p>聪明一点，这道题就是 LCS的扩展版！！！！！！！！！！！！！！！！！和 lcs 基本是一样的啊啊啊啊啊啊</p>
<h5 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h5><blockquote>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 <code>+</code> 和 <code>-</code>。对于数组中的任意一个整数，你都可以从 <code>+</code> 或 <code>-</code>中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][<span class="number">2001</span>];</span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>] + <span class="number">1000</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][-nums[<span class="number">0</span>] + <span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sum = -<span class="number">1000</span>; sum &lt;= <span class="number">1000</span>; sum++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][sum + <span class="number">1000</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][sum + nums[i] + <span class="number">1000</span>] += dp[i - <span class="number">1</span>][sum + <span class="number">1000</span>];</span><br><span class="line">                dp[i][sum - nums[i] + <span class="number">1000</span>] += dp[i - <span class="number">1</span>][sum + <span class="number">1000</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S &gt; <span class="number">1000</span> ? <span class="number">0</span> : dp[nums.length - <span class="number">1</span>][S + <span class="number">1000</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>背包问题的修改， 强！ 要点在于加上了 1000， 处理负数的情况</p>
<h5 id="1155-掷骰子的N种方法"><a href="#1155-掷骰子的N种方法" class="headerlink" title="1155. 掷骰子的N种方法"></a>1155. 掷骰子的N种方法</h5><blockquote>
<p>这里有 <code>d</code> 个一样的骰子，每个骰子上都有 <code>f</code> 个面，分别标号为 <code>1, 2, ..., f</code>。</p>
<p>我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。</p>
<p>如果需要掷出的总点数为 <code>target</code>，请你计算出有多少种不同的组合情况（所有的组合情况总共有 <code>f^d</code> 种），<strong>模 <code>10^9 + 7</code></strong> 后返回。</p>
</blockquote>
<p>dp[i] [j] 表示前i 个筛子， 得分为j的情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(d + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= target; j ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f &amp;&amp; j - k &gt;= <span class="number">0</span>; k ++)&#123;<span class="comment">// 对于每一种的取分，</span></span><br><span class="line">                dp[i][j] += dp[i<span class="number">-1</span>][j-k];</span><br><span class="line">                dp[i][j] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  dp[d][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较难的 3 维dp 问题。</p>
<h5 id="1277-统计全为-1-的正方形子矩阵"><a href="#1277-统计全为-1-的正方形子矩阵" class="headerlink" title="1277. 统计全为 1 的正方形子矩阵"></a>1277. 统计全为 1 的正方形子矩阵</h5><blockquote>
<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数。</p>
</blockquote>
<p>和中间是正方形的做法是一样的！</p>
<p>dp[i] [j] 表示到 i ，j 时是否为正方形</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习笔记</title>
    <url>/2019/07/01/notepad/os/os/</url>
    <content><![CDATA[<h1 id="操作系统复习指南"><a href="#操作系统复习指南" class="headerlink" title="操作系统复习指南"></a><center>操作系统复习指南</center></h1><h2 id="1-CPU-调度算法"><a href="#1-CPU-调度算法" class="headerlink" title="1.CPU 调度算法"></a>1.CPU 调度算法</h2><blockquote>
<p>了解CPU 调度算法，如先到先服务、最短作业优先、轮转、多级反馈队列等调度算法，<br>以及掌握多处理器调度的特殊性。</p>
</blockquote>
<p>T<del>周转时间</del>  =  T<del>完成时间</del>  -  T <del>到达时间</del></p>
<p>FIFO：     平均周转时间很大</p>
<p>SJF：         当一个长时间的任务先到达时，平均周转时间也会很大， 因为不能停止执行。</p>
<p>STCF：     放宽假设条件， 进程可以上下切断， 周转时间很好。</p>
<p>T<del>响应时间</del>  =  T<del>首次运行</del>  -  T <del>到达时间</del></p>
<p>STCF 的响应时间不好 ， 引入RR。</p>
<p>RR：根据时间片切换进程，均摊上下文切换成本，RR响应时间好， 但周转时间不好， 陷入死循环。。。</p>
<p>于是引入MLFQ， 综合解决两个问题。</p>
<p>MLFQ：</p>
<ul>
<li><p>相同优先级的进程按RR调度</p>
</li>
<li><p>如果 优先级  A &gt; B ， 先运行A</p>
</li>
<li><p>初始工作时，放到最高优先级队列中</p>
</li>
<li><ul>
<li>工作用完优先级后，降低优先级</li>
<li>如果在工作在时间片内主动释放cpu， 优先级不变</li>
</ul>
</li>
<li><p>经过一段时间，重新把所有的的进程放到最高优先级</p>
</li>
</ul>
<p>进程可能恶意每次都在快运行完的时候主动释放cpu， 因此，更改第四条如下</p>
<ul>
<li>如果进程用完了，一个优先级上的时间片段， 则降低优先级，无论是否主动释放cpu</li>
</ul>
<p>确保每一个工作获得一定的比例的cpu时间， 而不是优化cpu的周转时间和响应时间， 引入比例份额调度。</p>
<p>彩票调度： 按彩票的数量多少来运行程序， 彩票多概率大运行多，当任务短的时候，有随机性， 引入步长调度</p>
<p>步长调度： 步伐短运行地多，无论怎样都是按比例，缺点是需要<strong>全局状态</strong>， 当一个新的进程加入时， 要更新全部进程的当前步长， 彩票调度只需要一个<strong>全局变量</strong>，总的彩票数。</p>
<p>多处理器调度： 处理缓存一致性问题， 硬件上，cpu监听总线更改缓存，软件上：</p>
<p>单队列调度（SQMS）： 简单，但是缓存不亲和</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200107152722.png"></p>
<p>多队列调度（MQMS）：天生缓存亲和， 但负载不均衡！（工作窃取）</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200107164327.png"></p>
<p>上图可以看出， A进程独占cpu， 工作窃取，就是定时查看其他cpu的工作负载。</p>
<h2 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2.进程和线程"></a>2.进程和线程</h2><blockquote>
<p>掌握进程和线程的概念，熟练使用进程和线程相关编程接口，如fork，exec，wait，<br>pthread_create，pthread_join等。</p>
</blockquote>
<h3 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h3><p>进程就是运行中的程序， 一个进程可以创建多个线程。</p>
<p>进程之间不共用内存， 线程之间可以共用内存， 但每一个线程都有自己的堆栈。</p>
<ul>
<li>fork()</li>
</ul>
<p>子进程改变全局变量不会改变父进程的值， 子进程有自己的程序运行空间， copy自父进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#inclucde <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world(pid: %d)\n&quot;</span>,(<span class="keyword">int</span>)getpid);</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc &lt; <span class="number">0</span>) &#123;<span class="comment">// 创建失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>+ <span class="built_in">stderr</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;<span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am child (pid: %d)&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//!!!!!!!! 注意父进程的 rc 值是 子进程的 pid</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am parent of %d (pid: %d)&quot;</span>, rc, (<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>waidpid（）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#inclucde <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world(pid: %d)\n&quot;</span>,(<span class="keyword">int</span>)getpid);</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc &lt; <span class="number">0</span>) &#123;  <span class="comment">// 创建失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>+ <span class="built_in">stderr</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;<span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am child (pid: %d)&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//!!!!!!!! 注意父进程的 rc 值是 子进程的 pid</span></span><br><span class="line">    	<span class="keyword">int</span> wc == wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am parent of %d (wc: %d) (pid: %d)&quot;</span>, rc, wc, (<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rc = wc </p>
<p>fork 用作相同程序的拷贝作用，执行不同的程序时， 可以用</p>
<ul>
<li>exec()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argc[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span> + <span class="built_in">stderr</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;</span><br><span class="line">        close(STDOUT_FILENO);<span class="comment">// 关闭标准输入与输出</span></span><br><span class="line">        open(<span class="string">&quot;./p4,output&quot;</span>,O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);  </span><br><span class="line">        <span class="keyword">char</span> * myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>; <span class="comment">// 可运行的程序</span></span><br><span class="line">        myargs[<span class="number">1</span>] = <span class="string">&quot;file.c&quot;</span>;</span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        execvp(myargs[<span class="number">0</span>],myargs);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);<span class="comment">// this will be not ecec</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>// todo</p>
<h3 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">( <span class="keyword">pthread_t</span> * thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> * attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> * (*start_routine)(<span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> * arg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、第一个是指向 pthread_t 的指针， 用于交互</span></span><br><span class="line"><span class="comment">2、第二个是设置新的线程的，栈大小等等信息</span></span><br><span class="line"><span class="comment">3、执行的函数</span></span><br><span class="line"><span class="comment">4、参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> * thread,<span class="keyword">void</span> ** value_ptr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//第一个参数为创建的时候，保留的指针， 第二个为返回值</span></span></span><br></pre></td></tr></table></figure>









<h2 id="3-并发同步"><a href="#3-并发同步" class="headerlink" title="3.并发同步"></a>3.并发同步</h2><blockquote>
<p>掌握进程并发同步相关概念，如死锁、活锁等概念，真实应用中存在的不同类型的同步<br>问题，熟练使用pthread库中的相关同步函数进行编程。</p>
</blockquote>
<p>题目说，进程并发同步的相关概念， 让我对进程和线程的理解再次产生怀疑，首先再次总结一下：</p>
<p>进程是为运行中的程序提供的一个抽象，线程是为单个运行的进程提供的抽象，多线程程序有多个执行点， 每个线程类似于进程， 唯一的区别是： 线程之间共享地址空间，能够访问相同的数据（在堆上的数据或者全局变量， 不是局部变量）。</p>
<p>非死锁：</p>
<ul>
<li>违反原子性</li>
<li>违反顺序缺陷</li>
</ul>
<h3 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h3><p>产生原因：</p>
<ul>
<li><p>组件之间会有复杂的依赖</p>
</li>
<li><p>模块化会封装细节</p>
</li>
</ul>
<p>解决方案：</p>
<p>所有的线程获取锁的顺序如果是相同的就不会产生死锁</p>
<p>产生条件：</p>
<ul>
<li>互斥</li>
</ul>
<p>使用硬件支持， 使用不用锁的数据结构！</p>
<ul>
<li>持有并等待</li>
</ul>
<p>或取多个锁时： 可以用一个把大的锁锁住， 即使防止获取锁的过程中，上下文切换！</p>
<ul>
<li>非抢占</li>
</ul>
<p>获取第一个锁后，查看第二个锁是否被占有， 如果占有直接放弃第一个锁，再次获取第一个锁， 这样存在一个问题， 两个锁一直重复这个问题， 倒置<strong>活锁</strong></p>
<ul>
<li>循环等待</li>
</ul>
<p>锁的获取按照一定的顺序获取等待</p>
<h2 id="4-地址空间"><a href="#4-地址空间" class="headerlink" title="4.地址空间"></a>4.地址空间</h2><blockquote>
<p>掌握地址空间的概念，以及用户态堆内存的管理。</p>
</blockquote>
<p>一个进程的地址空间应该包含运行的程序的所有内存状态，操作系统给程序的抽象， 包括代码块， 堆，栈，真实的<strong>物理空间</strong>可能在任意的地方，地址空间是连续的0KB -&gt; 16KB 。如下图：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104151718.png"></p>
<p>所谓堆内存（属于地址空间）， 申请和释放都是又程序猿自己自己自己完成（注意这里操作的是地址空间，虚拟的）。java不用</p>
<h3 id="分配："><a href="#分配：" class="headerlink" title="分配："></a>分配：</h3><p> void malloc（size_t size） , size大小一般为宏来设定， 比如 sizeof(double),  注意 void 的返回类型 是返回地址的指针，可以强转， 如下：</p>
<p>int *x = malloc(sizeof(int));</p>
<h3 id="释放："><a href="#释放：" class="headerlink" title="释放："></a>释放：</h3><p> free(x)   , 分配的大小不会被用户传入， 必须由<strong>内存分配库</strong>本身记录追踪。</p>
<h3 id="常见错误："><a href="#常见错误：" class="headerlink" title="常见错误："></a>常见错误：</h3><ul>
<li><p>忘记分配内存（这个常犯， 常犯， 给一个指针赋值！！！！指针是存放在栈中的， 4个字节的）</p>
</li>
<li><p>没有分配足够的内存</p>
</li>
<li><p>忘记初始化分配的内存， NULL 一般输出为 0， 但0 不等于 NULL ，默认都是0</p>
</li>
<li><p>忘记释放内存（这个我一般都不是释放 ^ _ ^，web、操作系统等长时间运行的程序一定需要！！）</p>
</li>
<li><p>反复释放内存（内存都不释放， 这个绝对不会发生的）</p>
</li>
<li><p>用完之前释放内存</p>
</li>
<li><p>错误调用free（）， 参数传入错误的值。</p>
</li>
</ul>
<h2 id="5-同步原语"><a href="#5-同步原语" class="headerlink" title="5.同步原语"></a>5.同步原语</h2><p>掌握锁、条件变量、信号量三种同步机制（熟练使用pthread库中的函数），并使用这些<br>机制解决实际应用问题，如生产者消费者问题。</p>
<h3 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h3><p>锁就是一个<strong>变量</strong>， 锁为程序员提供了最小程度的调度控制，线程是操作系统的cpu调度的最小单位。</p>
<h4 id="实现锁"><a href="#实现锁" class="headerlink" title="实现锁"></a>实现锁</h4><h5 id="控制中断"><a href="#控制中断" class="headerlink" title="控制中断"></a>控制中断</h5><p>通过控制中断， 让代码原子执行</p>
<p>缺点很多， 不支持多cpu， 出现系统问题，操作系统需要控制中断来获取控制权。。。</p>
<h5 id="TestAndSet"><a href="#TestAndSet" class="headerlink" title="TestAndSet"></a>TestAndSet</h5><p>这条指令基于硬件的支持，等价于下面代码是<strong>原子执行</strong>的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *old_ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *old = old_ptr;</span><br><span class="line">	*old_ptr = <span class="keyword">new</span>;</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自旋锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line"> 	<span class="keyword">int</span> flag;</span><br><span class="line"> &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line"> 	lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//上面会一直自旋，浪费cpu资源， 也可能一直自旋永远得不到执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> * lock)</span></span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FetchAndAdd"><a href="#FetchAndAdd" class="headerlink" title="FetchAndAdd"></a>FetchAndAdd</h5><p>这也是一个硬件支持的原语，这一条指令等价于下面原子执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FetchAndAdd(<span class="keyword">int</span> *ptr)&#123;</span><br><span class="line">	<span class="keyword">int</span> old = *ptr;</span><br><span class="line">	*ptr = old + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个公平的自旋锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line"> 	<span class="keyword">int</span> ticket;</span><br><span class="line"> 	<span class="keyword">int</span> turn;</span><br><span class="line"> &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line"> 	lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="comment">// 这里每一一次测试都会增加， 让每一个线程都能得到执行！</span></span><br><span class="line">    <span class="keyword">while</span>(lock-&gt;trun != myturn);</span><br><span class="line">    <span class="comment">//这里还是会自旋</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面硬件原语的支持虽然实现了简单的公平锁， 但是它会自旋，下面实现不自旋的公平锁</p>
<h4 id="实现公平不自旋锁"><a href="#实现公平不自旋锁" class="headerlink" title="实现公平不自旋锁"></a>实现公平不自旋锁</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> flag;</span><br><span class="line"> 	<span class="keyword">int</span> guard;</span><br><span class="line">	<span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"> 	m-&gt;flag = <span class="number">0</span>;</span><br><span class="line"> 	m-&gt;guard = <span class="number">0</span>;</span><br><span class="line"> 	queue_init(m-&gt;q);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 这里虽然也会自旋， 但是这个guard，在一个线程获取锁后（后面的else），guard也设置成了0，</span></span><br><span class="line">     <span class="comment">//也就是说，即使已经有线程获取了锁， 这条指令还是有可能通过的， 不会一直在这里自旋，只会自旋几个周期</span></span><br><span class="line">	<span class="comment">// guard的作用是保证后面的flag的设置是原子进行的</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 这里保证的原子的执行了， 因为其它指令的gurad为1，进不来这里， 不会有两个线程同时进入这里</span></span><br><span class="line"> 	<span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;<span class="comment">// 如果能获取到锁</span></span><br><span class="line"> 		m-&gt;flag = <span class="number">1</span>; </span><br><span class="line"> 		m-&gt;guard = <span class="number">0</span>;<span class="comment">// 重置为0</span></span><br><span class="line"> 	&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果没有获取到锁</span></span><br><span class="line"> 		queue_add(m-&gt;q, gettid());<span class="comment">// 加入队列，休眠队列</span></span><br><span class="line"> 		m-&gt;guard = <span class="number">0</span>;<span class="comment">// guard这里也重置为0</span></span><br><span class="line"> 		park();</span><br><span class="line">        <span class="comment">//这个是操作系统提供给程序员的函数， 休眠自己，在c语言中， 每种操作系统可以提供不同的</span></span><br><span class="line">        <span class="comment">//函数库供程序猿调度，在 java统一为yeild（）， linux中使用c也为 yeild（）</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">//通过自旋获取guard</span></span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">		 m-&gt;flag = <span class="number">0</span>; <span class="comment">// 空的话flag直接设置0</span></span><br><span class="line"> 	<span class="keyword">else</span></span><br><span class="line">		 unpark(queue_remove(m-&gt;q)); </span><br><span class="line"> 		<span class="comment">// 这里并没有将 flag设置0， 因为要保证公平性， 按照队列的线程来进行唤醒，这样</span></span><br><span class="line">    <span class="comment">// 队列里的每一个线程都能够得到执行，直接将flag的1 使用权传给了队列的第一个线程</span></span><br><span class="line"> 	m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码还有一个很微妙的竞态条件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">queue_add(m-&gt;q, gettid());</span><br><span class="line">m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">park();</span><br></pre></td></tr></table></figure>

<p>假设这段代码执行完前两句语句， 此时guard 变成了0，  释放锁的线程可以运行了， 而这个线程已经在休眠队列里面，但是它却还没有休眠， 这是如果唤醒了它，相当于白唤醒， 之后它执行park又再次休眠，而没加入队列里面了。结果就是永久休眠。 所以linux的实现有一个再次确认的代码！！！ </p>
<p>linux 也是使用这种思想， 但是提供的原语不同。</p>
<p>锁的实现已经完成了，但是还有一种情况，当父进程等待子进程结束的时候，就要用到下面的同步原语：</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cond_wait(<span class="keyword">pthread_cond_t</span> *c, <span class="keyword">pthread_mutex_t</span> *m);</span><br><span class="line">pthread_cond_signal(<span class="keyword">pthread_cond_t</span> *c);</span><br></pre></td></tr></table></figure>

<p>实现子进程等带父进程：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;m);</span><br><span class="line"> 	done = <span class="number">1</span>;</span><br><span class="line"> 	Pthread_cond_signal(&amp;c);</span><br><span class="line">    <span class="comment">//唤醒因为条件c而休眠你的线程</span></span><br><span class="line"> 	Pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line"> 	thr_exit();</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;m);</span><br><span class="line">    <span class="comment">//为什么要锁呢？ 因为下面wait函数有释放锁！！！！！！！！！！！</span></span><br><span class="line"> 	<span class="keyword">while</span> (done == <span class="number">0</span>)			</span><br><span class="line"> 	Pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    1、 这里要使用一个done来标记时候是否完成， 如果不用， 子进程先于父进程完成的时候，就会卡主</span></span><br><span class="line"><span class="comment"> 	因为子进程已经过了唤醒父进程，而父进程又重新休眠，这样没有线程唤醒父进程</span></span><br><span class="line"><span class="comment"> 	2、当调用了这条命令之后， 线程首先会将** 锁释放 **，然后调用线程休眠自己，（原子操作）</span></span><br><span class="line"><span class="comment">	3、要用while， 而不能用if，在这里使用if正确， 但是有多个信号的时候， 可能会出现1 的情况</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line"> 	Pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line"> 	<span class="keyword">pthread_t</span> p;</span><br><span class="line"> 	Pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);<span class="comment">//创建新的线程</span></span><br><span class="line"> 	thr_join();		<span class="comment">//等待子线程完成</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书上没有给出条件变量的实现方法，但是通过其功能描述结合锁的实现应该也略知一二！</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是dijkstra提出的，可以用作为锁和条件变量， 让同步原语更加通用。</p>
<p>信号量是一个<strong>整形数值</strong>的对象, 下面是POSIX库的使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">sem_s s;</span><br><span class="line">sem_init(&amp;s,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">sem_wait(sem_s *s);</span><br><span class="line">sem_post(sem_s *s);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一共有三个参数：</span></span><br><span class="line"><span class="comment">1、 s是传入一个信号量</span></span><br><span class="line"><span class="comment">2、0表示同一进程多个线程共享， 当为其它的时候， 可以在不同的进程中通知</span></span><br><span class="line"><span class="comment">3、初始化信号量的值为 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="实现信号量"><a href="#实现信号量" class="headerlink" title="实现信号量"></a>实现信号量</h4><p>基于锁和信号量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Zem_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">	<span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; Zem_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_init</span><span class="params">(Zem_t *s, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	s-&gt;value = value;</span><br><span class="line">	Cond_init(&amp;s-&gt;cond);</span><br><span class="line">	Mutex_init(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_wait</span><span class="params">(Zem_t *s)</span> </span>&#123;</span><br><span class="line"> 	Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line"> 	<span class="keyword">while</span> (s-&gt;value &lt;= <span class="number">0</span>)<span class="comment">//当初始化的value小于等于0 的时候等待当前的线程</span></span><br><span class="line"> 		Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);</span><br><span class="line"> 	s-&gt;value--;			<span class="comment">// value 减去1不能放到上面，原因在下面</span></span><br><span class="line"> 	Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Zem_post</span><span class="params">(Zem_t *s)</span> </span>&#123;</span><br><span class="line">	Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line"> 	s-&gt;value++;  		<span class="comment">//唤醒一个等待着的线程，对应的value 加上1</span></span><br><span class="line"> 	Cond_signal(&amp;s-&gt;cond);</span><br><span class="line"> 	Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>看了实现之后， 很容易就能用一个信号量实现一个锁</p>
<h4 id="信号量实现条件变量"><a href="#信号量实现条件变量" class="headerlink" title="信号量实现条件变量"></a>信号量实现条件变量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">	sem_post(&amp;s); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	sem_init(&amp;s, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 这里初始化为0，</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> c;</span><br><span class="line">	Pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">	sem_wait(&amp;s); </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    有两种情况考虑：</span></span><br><span class="line"><span class="comment">    1、 当父进程线运行时， 信号量的值为0，休眠自己，此时不会减去1</span></span><br><span class="line"><span class="comment">    	子进程运行post的时候，唤醒了父进程，value加上了1，变成1</span></span><br><span class="line"><span class="comment">    	********* 父进程继续运行，减去1 ， 信号量重新变为0， 这就是value - 1 不能放上面的原因！！</span></span><br><span class="line"><span class="comment">    2、 当子进程先运行的时候， value加上了1， 等于1</span></span><br><span class="line"><span class="comment">    	当父进程运行的时候， value为1， 不用等了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二值信号量（锁）"><a href="#二值信号量（锁）" class="headerlink" title="二值信号量（锁）"></a>二值信号量（锁）</h4><p>初始化信号量的值为1，这就实现了一个锁！！！</p>
<p>当有一个进程获取锁之后， value 就变成了0， 其它线程要进入必须等待被唤醒。</p>
<p>当有多个线程在休眠时， 多个线程同时被唤醒， 多个线程会抢占锁，谁先抢到谁先起来， 这里应该是存在不公平现象的， 有可能有些线程一直得不到执行！？？？？？？？应该只有一个线程会被唤醒！！！？？？</p>
<p>上面理解错误！！！！不会有多个被唤醒的情况， 条件变量目前只有一个在等待</p>
<p>应该是按照fifo来的</p>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><h4 id="基于条件变量和锁"><a href="#基于条件变量和锁" class="headerlink" title="基于条件变量和锁"></a>基于条件变量和锁</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buffer[MAX];</span><br><span class="line"><span class="keyword">int</span> fill_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> use_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	buffer[fill_ptr] = value;</span><br><span class="line"> 	fill_ptr = (fill_ptr + <span class="number">1</span>) % MAX;</span><br><span class="line"> 	count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> tmp = buffer[use_ptr];</span><br><span class="line"> 	use_ptr = (use_ptr + <span class="number">1</span>) % MAX;</span><br><span class="line"> 	count--;</span><br><span class="line"> 	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">cond_t</span> empty, fill;</span><br><span class="line"> <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里要使用两个条件变量， 如果只使用一个， 而条件变量的唤醒不是按照队列来的，这时</span></span><br><span class="line"><span class="comment">假设有两个消费者因为没有count休眠</span></span><br><span class="line"><span class="comment">而生产者生产满了之后， 就去休眠了， 等待唤醒</span></span><br><span class="line"><span class="comment">此时一个消费者先被唤醒，消费完count后， 唤醒了另一个消费者，发现count已经没了，也去休眠，</span></span><br><span class="line"><span class="comment">此时没人唤醒生产者了。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"> 		Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1</span></span><br><span class="line">        <span class="keyword">while</span> (count == MAX) <span class="comment">// p2</span></span><br><span class="line">            Pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">// p3</span></span><br><span class="line">        put(i); <span class="comment">// p4</span></span><br><span class="line">        Pthread_cond_signal(&amp;fill); <span class="comment">// p5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6</span></span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// c2</span></span><br><span class="line">         	Pthread_cond_wait(&amp;fill, &amp;mutex); <span class="comment">// c3</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里使用while，而不是if， 原因：</span></span><br><span class="line"><span class="comment">        当有多个消费者时， 其中一个消费者先运行，发现count = 0，休眠， 接下来生产者生产一个</span></span><br><span class="line"><span class="comment">        count = 1， 这时另一个消费者运行， 把数据取走， 此时count = 0； 假设接下来是</span></span><br><span class="line"><span class="comment">        刚才那个休眠的消费者继续运行，此时count已经是0了， 而如果使用if， if只会判断一次， </span></span><br><span class="line"><span class="comment">        刚才休眠的时候已经判断过了，所以这个消费者会继续运行， count -= 1； = -1！！！</span></span><br><span class="line"><span class="comment">        所以要使用while ， while 会重新回来判断！！</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> tmp = get(); <span class="comment">// c4</span></span><br><span class="line">        Pthread_cond_signal(&amp;empty); <span class="comment">// c5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="基于信号量"><a href="#基于信号量" class="headerlink" title="基于信号量"></a>基于信号量</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"> 		sem_wait(&amp;mutex); <span class="comment">// Line P0 (NEW LINE)</span></span><br><span class="line">        sem_wait(&amp;empty); <span class="comment">// Line P1</span></span><br><span class="line">        put(i); <span class="comment">// Line P2</span></span><br><span class="line">        sem_post(&amp;full); <span class="comment">// Line P3</span></span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// Line P4 (NEW LINE)</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">         sem_wait(&amp;mutex); <span class="comment">// Line C0 (NEW LINE)</span></span><br><span class="line">         sem_wait(&amp;full); <span class="comment">// Line C1</span></span><br><span class="line">         <span class="keyword">int</span> tmp = get(); <span class="comment">// Line C2</span></span><br><span class="line">         sem_post(&amp;empty); <span class="comment">// Line C3</span></span><br><span class="line">         sem_post(&amp;mutex); <span class="comment">// Line C4 (NEW LINE)</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="6-分段与分页"><a href="#6-分段与分页" class="headerlink" title="6.分段与分页"></a>6.分段与分页</h2><blockquote>
<p>掌握虚拟内存管理中的分段与分页机制的原理，以及比较其优缺点。</p>
</blockquote>
<h3 id="动态重定位："><a href="#动态重定位：" class="headerlink" title="动态重定位："></a><strong>动态重定位</strong>：</h3><p>基于硬件的动态重定位，使用内存管理单元（MMU）给<strong>地址空间</strong>分配内存，效率低下， 造成很多内部碎片（图中allocated but not use）。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20200104152143704.png"></p>
<h3 id="分段："><a href="#分段：" class="headerlink" title="分段："></a>分段：</h3><p>因此引入分段解决内部碎片问题：MMU给<strong>地址空间</strong>内的每一个逻辑段都分配内存。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20200104152706215.png"></p>
<p>段的引用： 显示方式</p>
<img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104153148.png" style="zoom:80%;" />

<p>于是乎， 在内存上产生很多<strong>外部碎片</strong>， 解决方法，基于空闲列表 和 各种管理算法：</p>
<p>这里我觉得不会考，但列一列：</p>
<ul>
<li><p>最优匹配</p>
</li>
<li><p>最差匹配</p>
</li>
<li><p>首次匹配</p>
</li>
<li><p>下次匹配</p>
</li>
<li><p>分离空闲列表：经常申请的内存空间，给它一个独立的列表</p>
</li>
<li><p>伙伴系统： 二分分配， 合并和分配的时候很方便， 二进制与二叉树的巧合</p>
</li>
</ul>
<p>可以看出分段会产生外部碎片， 这是一个很根本的问题，不通用， 即使有管理内存算法！</p>
<p>以上不会考的，应该考二级页表！</p>
<h3 id="分页："><a href="#分页：" class="headerlink" title="分页："></a>分页：</h3><p>分页不是将一个<strong>地址空间</strong>按逻辑段分， 而是分割成固定大小的单元，称为 <strong>页帧</strong>。</p>
<p>页表： 记录每一个地址空间的每一个<strong>虚拟页</strong>（<strong>页帧</strong>）在物理内存中的位置，==页表是每一个进程数据结构==。</p>
<p>物理帧号（PFN）或称 物理页号（PPN physical page number）： 真实的物理 <strong>页帧</strong> 地址。</p>
<ul>
<li>地址空间划分：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104162855.png"></p>
<ul>
<li>物理地址划分</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104162939.png"></p>
<p>页表项（PTE page table entry）： 记录 PFN </p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104160826.png"></p>
<p>上图中中间的地址转换（address translation）就通过页表来存储！！</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p><strong>地址空间</strong> 地址 21  -&gt; 010101  <img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104160907.png"></p>
<p>从物理地址 （vpn 01 推出 ）中拿出PTE，取出 PFN 得到地址空间的真实的物理地址， 偏移量不变， 因为页帧一样大。</p>
<p>如何拿出vpn对应的PTE：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT             <span class="comment">//取出VPN</span></span><br><span class="line">PTEAddr = PageTableBaseRegister + (VPN * <span class="keyword">sizeof</span>(PTE))  <span class="comment">// 算出物理地址， 拿到PTE的物理地址</span></span><br></pre></td></tr></table></figure>

<p>于是呢， 有两次的内存访问， ==慢==！</p>
<p>页表存放：</p>
<p>简单的存放线性页表， 32 位的地址空间， 4KB（2^ 12）的页大小（大部分os，windows，linux），PTE个数：2^32 / 2^12 = 2^20,  PTE大小（假设）4B， 线性页表大小 4B * 2^20 = 4MB, 所以一个进程就 4MB内存， 10个就==。。。==</p>
<p>以上就是页表的两个缺点！</p>
<p>先比较优缺点：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分段</td>
<td align="center">很好支持稀疏地址空间，很快，算法简单，适合硬件完成，地址转换的开销极小， 代码共享（如果代码独立的段中，可以被多个运行程序共享）。</td>
<td align="center">不支持<strong>一般化</strong>的稀疏地址，产生外部碎片问题很根本，难以避免，随时间推移，管理难，分配也困难。</td>
</tr>
<tr>
<td align="center">分页</td>
<td align="center">不会导致外部碎片， 很灵活，支持稀疏的地址空间</td>
<td align="center">速度较慢，要两次访问内存，<strong>有可能</strong>产生内存浪费</td>
</tr>
</tbody></table>
<h2 id="7-TLB，-多级页表"><a href="#7-TLB，-多级页表" class="headerlink" title="7.TLB， 多级页表"></a>7.TLB， 多级页表</h2><blockquote>
<p>掌握TLB 与多级页表，掌握多级页表相关的计算，比如根据地址位、页面大小、PTE 大<br>小等条件，进行虚拟地址到物理地址的转换；掌握多级页表的访问过程。</p>
</blockquote>
<p>第6点的页表的两个问题需要解决！</p>
<h3 id="解决问题1：-慢"><a href="#解决问题1：-慢" class="headerlink" title="解决问题1： 慢"></a>解决问题1： 慢</h3><h4 id="TLB："><a href="#TLB：" class="headerlink" title="TLB："></a>TLB：</h4><p>TLB（地址转换旁路缓冲储存器）也叫 地址转换缓存， 频繁发生虚拟到物理地址的硬件缓存。</p>
<h5 id="原理（注意加粗，-）："><a href="#原理（注意加粗，-）：" class="headerlink" title="原理（注意加粗， ** **）："></a>原理（注意加粗， ** **）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line"> (Success, TlbEntry) = TLB_Lookup(VPN)  <span class="comment">// TLB里面找VPN对应的物理地址</span></span><br><span class="line"> <span class="keyword">if</span> (Success == True) <span class="comment">// TLB Hit</span></span><br><span class="line">	 <span class="keyword">if</span> (CanAccess(TlbEntry.ProtectBits) == True)</span><br><span class="line">		Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line"> 		PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span><br><span class="line"> 		Register = AccessMemory(PhysAddr)  <span class="comment">// 直接从** 缓存地址**中拿到实际的物理地址</span></span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">		 RaiseException(PROTECTION_FAULT)</span><br><span class="line"> <span class="keyword">else</span> 			<span class="comment">// TLB Miss</span></span><br><span class="line">	 PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br><span class="line">	 PTE = AccessMemory(PTEAddr)    <span class="comment">//没有找到就多了一次PTE ** 内存 **的寻址， 多了一次一次就一次</span></span><br><span class="line">  	<span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">	 	RaiseException(SEGMENTATION_FAULT)</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">		RaiseException(PROTECTION_FAULT)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)</span><br><span class="line">		RetryInstruction()</span><br></pre></td></tr></table></figure>

<h4 id="缓存："><a href="#缓存：" class="headerlink" title="缓存："></a>缓存：</h4><p>计算机中有很多缓存，有指令、数据、地址转换， 上面是地址转换的缓存TLB，缓存要小，越小越快（物理限制），有时间和空间局部性。cpu的数据缓存也分为多级。</p>
<p>曾看到一道题， TLB 和 cache 有什么不同？？？？  </p>
<h4 id="问题里面的问题："><a href="#问题里面的问题：" class="headerlink" title="问题里面的问题："></a>问题里面的问题：</h4><p>当TLB中有两条相同的VPN索引两个不同的物理地址， 可以通过ASID标记（进程号）来标记， 这样就不用覆盖掉之前的VPN了， 当两个进程交互运行时， 相同的VPN可以存在于TLB中，还是上一张图。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104165558.png"></p>
<h5 id="TLB覆盖问题："><a href="#TLB覆盖问题：" class="headerlink" title="TLB覆盖问题："></a>TLB覆盖问题：</h5><p> 如果程序短时间内访问的页数超过了 TLB中的页数， 会产生大量未命中，因为要重写，因此要支持更大的页， 才不会访问很多页！！</p>
<h5 id="TLB的替换策略：LRU"><a href="#TLB的替换策略：LRU" class="headerlink" title="TLB的替换策略：LRU"></a>TLB的替换策略：LRU</h5><p>难道是问题8的？ 不是的，问题8是页的替换， 这里是TLB的替换，思路应该一样的！！</p>
<p>听说腾讯的面试有要求写一个LRU算法！ 基于哈希，哈希每次访问的地址，用一个链表存储哈希后的地址数值，有新的访问就把他放到链表的头结点（包括在链表中的），满了删队尾。（脑子里想起链表的操作删除，插入操作）</p>
<h3 id="解决问题2：-页表很大！"><a href="#解决问题2：-页表很大！" class="headerlink" title="解决问题2： 页表很大！"></a>解决问题2： 页表很大！</h3><h4 id="更大的页"><a href="#更大的页" class="headerlink" title="更大的页"></a>更大的页</h4><p>页变大， 页表条目减少， 页表也就小了， 但是页变大有内部碎片产生！因为每一页都用不完积累就多</p>
<h4 id="分段-分页"><a href="#分段-分页" class="headerlink" title="分段+分页"></a>分段+分页</h4><p>分段与分页相结合，外部碎片再次产生， 页表就是为了解决外部碎片的！！！分段产生外部碎片的根源，无可避免！！</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>于是乎，只有引入多级页表：</p>
<p>问题所在： 页表中存在很多无效区域。</p>
<p>基本思想：将<strong>页表</strong>分成<strong>页</strong>大小的单元，如果整页的PTE无效，就完全不分配该页的页表（很重要！）于是引入:</p>
<p>PDE(页目录)： 记录页表的页是否有效， 包含有效位和页帧号。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104215751.png"></p>
<p>详细深入具体仔细的一个书上的例子： 完美非无可增，乃不可减，老师说必考。</p>
<p>首先题目： 地址空间 16KB（2^14)，地址位数14位， 页大小 64B（2^6),   偏移位数6 位，VPN位数： 14 - 4 = 8 位，页表项条数为 2^8条 , PTE的大小为 4B（假设），如果是线性页表大小为： 4 * 256B = 1KB，如果分配到PDE中， 每页存 64B/4B = <font color="red">16</font> 条PTE，一共要256/16 = ==16==页来存储PTE，于是页目录的索引要 4位（来自黄色的数字），如下图：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104221733.png"></p>
<p>计算PTE的PFN算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PDEAddr = PageDirBase + (PDIndex(<span class="number">4</span>位就可以找到！) - <span class="keyword">sizeof</span>(PDE))</span><br></pre></td></tr></table></figure>

<p>于是找到了PTE所在的物理页帧PFN！（第一步）</p>
<p>因为VPN一共8位， 找PTE所在的页用了4位， 还有4位就索引属于该页所有的PTE的那一条（来自红色的数字）！</p>
<p>通过下面的这条式子找到， 实际物理地址的PFN！(第二步)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PTEAddr = (PDE.PFN &lt;&lt; SHIFT) + (PTIndex * <span class="keyword">sizeof</span>(PTE))</span><br></pre></td></tr></table></figure>

<p>最后,计算实际的物理地址！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PhysAddr &#x3D; (PTE.PFN &lt;&lt; SHIFT) + offset</span><br></pre></td></tr></table></figure>

<p>总结，二级页表的访问内存数目达到了两次，访问速度慢， 但是解决了页表大的问题， 是一个时空的折中。</p>
<h2 id="8-页面置换算法"><a href="#8-页面置换算法" class="headerlink" title="8.页面置换算法"></a>8.页面置换算法</h2><p>掌握页面置换算法，比如FIFO，LRU等，要求能根据给定的页面访问序列，给出特定算<br>法的计算过程；掌握CLOCK算法。</p>
<p>这一块课，没有去听，^ _ ^</p>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>这个好实现， 先进先出，用一个队列就行！</p>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>这个在TLB的替换页面中写了。</p>
<p>LRU 也有问题， 当内存大的时候， LRU的实现代价很大，比如存储LRU的数据结构，因此引入一个近似LRU：</p>
<h3 id="近似LRU"><a href="#近似LRU" class="headerlink" title="近似LRU"></a>近似LRU</h3><p>近似LRU 要硬件的帮助， 给页增加一个使用位， 如果为1， 则认为当前页正在被使用。</p>
<h4 id="clock算法"><a href="#clock算法" class="headerlink" title="clock算法"></a>clock算法</h4><p>算法思路： 当要进行页替换的时候，检查当前的页的使用位，如果为1， 则意味着当前页在被使用，不适合替换，然后将这个位设置为0， 接着检查下一个页的使用位。 如果为0， 则直接替换。 算法的最坏情况是所有的页都是在被使用的， 把所有的1 都换为 0， 此时再来一遍循环选第一个替换， 实际上这种情况很少出现！</p>
<h4 id="ARC算法"><a href="#ARC算法" class="headerlink" title="ARC算法"></a>ARC算法</h4><p>书上没有介绍！</p>
<p>//todo</p>
<h2 id="9-磁盘驱动器"><a href="#9-磁盘驱动器" class="headerlink" title="9.磁盘驱动器"></a>9.磁盘驱动器</h2><blockquote>
<p>掌握磁盘寻道、旋转、传输时间的概念及计算过程。</p>
</blockquote>
<p>寻道： 就是寻道，一般有偏斜</p>
<p>旋转：就是旋转</p>
<p>T <del>I/O</del> = T <del>寻道</del> + T <del>旋转</del> + T <del>传输</del></p>
<p>R<del>I/O</del>（传输速度） = 文件大小 / T <del>I/O</del></p>
<h2 id="10-磁盘调度算法"><a href="#10-磁盘调度算法" class="headerlink" title="10.磁盘调度算法"></a>10.磁盘调度算法</h2><blockquote>
<p>了解各种磁盘调度算法的原理。</p>
</blockquote>
<h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p>最短任务优先， 计算 I/O的时间，选择最短的！</p>
<h3 id="SSTF"><a href="#SSTF" class="headerlink" title="SSTF"></a>SSTF</h3><p>最短寻道时间优先， 可能产生饥饿，一直在同一道内请求</p>
<h3 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h3><p>到一层的时候， 将请求加入队列， 处理完再寻道，这样避免饥饿</p>
<h3 id="SPTF"><a href="#SPTF" class="headerlink" title="SPTF"></a>SPTF</h3><p>最短定位时间</p>
<h2 id="11-RAID"><a href="#11-RAID" class="headerlink" title="11.RAID"></a>11.RAID</h2><blockquote>
<p> 掌握磁盘阵列RAID-0，RAID-1，RAID-4，RAID-5的原理，并分析各种RAID在容量、可<br>靠性、吞吐量三个层面的特性。熟练使用RAID的这些特性进行设计。</p>
</blockquote>
<p>RAID:  廉价冗余磁盘阵列</p>
<p>用于使用多个磁盘构建更大、更快、更可靠的磁盘系统</p>
<h3 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h3><p>条带化</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174035.png"></p>
<p>计算公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Disk = A % number_of_disks</span><br><span class="line">Offset = A / number_of_disks</span><br></pre></td></tr></table></figure>

<p>容量最好， 性能优， 不可靠！</p>
<h3 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h3><p>一半用作镜像</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174309.png"></p>
<p>容量减半， 速度也减半， 因为并发io，少了一半，可靠！</p>
<h3 id="RAID4"><a href="#RAID4" class="headerlink" title="RAID4"></a>RAID4</h3><p>专门用一个磁盘用来奇偶校验</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174532.png"></p>
<p>可靠， 速度（n-1）S， 容量大</p>
<p>当一校验盘同时有两个块需要校验时， 速度会减慢， 因此引入：</p>
<h3 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h3><p>旋转奇偶校验</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174917.png"></p>
<p>可靠， 速度（n-1）S，容量大</p>
<h3 id="性能比较："><a href="#性能比较：" class="headerlink" title="性能比较："></a>性能比较：</h3><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174957.png"></p>
<h2 id="12-文件系统接口"><a href="#12-文件系统接口" class="headerlink" title="12.文件系统接口"></a>12.文件系统接口</h2><blockquote>
<p> 了解文件系统接口，如open，read，write，在实现时对元数据和文件内容的读写过程。</p>
</blockquote>
<p>都说不考喽！！！</p>
<h2 id="13-操作系统历史"><a href="#13-操作系统历史" class="headerlink" title="13.操作系统历史"></a>13.操作系统历史</h2><blockquote>
<p>了解课堂上讲到的跟操作系统发展史相关的重要人物，并能介绍其主要贡献。</p>
</blockquote>
<ul>
<li>图灵</li>
</ul>
<p>计算机之父</p>
<ul>
<li>冯·诺伊曼</li>
</ul>
<p>提出了“存储程序”的概念和二进制原理</p>
<ul>
<li>linus</li>
</ul>
<p>编写第一个linux</p>
<ul>
<li>阿兰·马西森·图灵（1912-1917年6月23日）</li>
</ul>
<p>他在计算机科学的发展，提供概念的形式化“算法”和“计算”的图灵机，可以考虑通用计算机的模型。</p>
<p>图灵被广泛认为是理论计算机之父！</p>
<ul>
<li>Dijkstra</li>
</ul>
<p>同步进程通信的信号量</p>
<ul>
<li>Thompson</li>
</ul>
<p>用B语言写了第一个UNIX操作系统</p>
<h2 id="14-其它"><a href="#14-其它" class="headerlink" title="14.其它"></a>14.其它</h2><blockquote>
<p>作业中的难点问题需要掌握其解题方法。</p>
</blockquote>
<p>都包含在上面了。</p>
]]></content>
      <categories>
        <category>os</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式</title>
    <url>/2019/10/01/notepad/read/design_pattern/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><center>设计模式</center></h1><p>笔记说明： 这是一节专业选修课，上课没怎么听， 弥补一下错过的东西， 给大部分的设计模式写了一个demo， 很多细节都在里面，代码地址： github/fierygit,  一共有23 个设计模式， 5 个 创建型， 7 个 结构型， 11 个行为型！</p>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p><strong>(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</strong></p>
<a id="more"></a>


<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p><strong>(Open-Closed Principle, OCP)：软件实体应当对扩展开放，对修改关闭</strong></p>
<h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p><strong>(Liskov Substitution Principle, LSP)：所有引用基类的地方必须能透明地使用其子类的对象</strong></p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p><strong>(Dependency Inversion Principle, DIP)：高层模块不应该依赖底层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象</strong></p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p><strong>(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口</strong></p>
<h3 id="复用原则"><a href="#复用原则" class="headerlink" title="复用原则"></a>复用原则</h3><p><strong>(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的</strong></p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p><strong>(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用</strong></p>
<hr>
<hr>
<h2 id="六个创建型模式"><a href="#六个创建型模式" class="headerlink" title="六个创建型模式"></a>六个创建型模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/SimpleFactory.png"></p>
<p>● Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</p>
<p>● Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p>
<p>● ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>参考工程 SimpleFactory（代码在github，study_note）</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</p>
<p><strong>主要优点：</strong></p>
<p>(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</p>
<p>(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</p>
<p>(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</p>
<p>(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</p>
<p>(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p>
<p>(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p>
<hr>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p> 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p>
<h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/FactoryMethod.png"></p>
<p>● Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</p>
<p>● ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</p>
<p>● Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</p>
<p>● ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>参考工程 FactoryMethod</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类；</p>
<p><strong>主要优点：</strong></p>
<p>(1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p>
<p>(2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</p>
<p>(3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p>
<p>(2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
<hr>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p> 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例 </p>
<h4 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h4><p> ● Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。 </p>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>参考工程 SIngleton</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p> <strong>饿汉式单例与懒汉式单例</strong> </p>
<p>  饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。可见，无论是饿汉式单例还是懒汉式单例都存在这样那样的问题。</p>
<p> <strong>Initialization Demand Holder (IoDH)</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton &#123;  </span><br><span class="line">    private Singleton() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    private static class HolderClass &#123;  </span><br><span class="line">       private final static Singleton instance &#x3D; new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        return HolderClass.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void main(String args[]) &#123;  </span><br><span class="line">        Singleton s1, s2;   </span><br><span class="line">            s1 &#x3D; Singleton.getInstance();  </span><br><span class="line">        s2 &#x3D; Singleton.getInstance();  </span><br><span class="line">        System.out.println(s1&#x3D;&#x3D;s2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过一个静态的方法初始化一个静态的类！</p>
<hr>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p> 使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种<strong>对象</strong>创建型模式。 </p>
<h4 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h4><p>●Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</p>
<p>● ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</p>
<p>● Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便</p>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p>参考工程：PrototypePattern</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>一般而言，Java语言中的clone()方法满足：</p>
<ul>
<li><p>(1) 对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；</p>
</li>
<li><p>(2) 对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；</p>
</li>
<li><p>(3) <font color ="red">如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</font></p>
</li>
</ul>
<p>为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：</p>
<ul>
<li><p>(1) 在派生类中覆盖基类的clone()方法，并声明为public；</p>
</li>
<li><p>(2) 在派生类的clone()方法中，调用super.clone()；</p>
</li>
<li><p>(3)派生类需实现Cloneable接口。</p>
</li>
</ul>
<h5 id="浅克隆-ShallowClone-和深克隆-DeepClone"><a href="#浅克隆-ShallowClone-和深克隆-DeepClone" class="headerlink" title="浅克隆(ShallowClone)和深克隆(DeepClone)"></a><strong>浅克隆(ShallowClone)和深克隆(DeepClone)</strong></h5><p>​     Java语言中，数据类型分为值类型（基本数据类型）和引用类型.</p>
<ul>
<li><p><strong>值类型</strong>包括int、double、byte、boolean、char等简单数据类型，</p>
</li>
<li><p><strong>引用类型</strong>包括类、接口、数组等复杂类型。</p>
</li>
</ul>
<p>浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制，下面将对两者进行详细介绍。 </p>
<p><strong>浅克隆</strong></p>
<p>  在浅克隆中，如果原型对象的成员变量是<strong>值类型</strong>，将复制一份给克隆对象；如果原型对象的成员变量是<strong>引用类</strong>型，则将<strong>引用对象的地址</strong>复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p>
<p><strong>深克隆</strong></p>
<p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p>
<p><strong>主要优点：</strong></p>
<p>(1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</p>
<p>(2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</p>
<p>(3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</p>
<p>(4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p>
<p>(2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</p>
<hr>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种<strong>对象</strong>创建型模式。 </p>
<h4 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/Builder.png"></p>
<p>● Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</p>
<p>●ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</p>
<p>●Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</p>
<p>● Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的==构造函数==或者==Setter==方法将该对象传入指挥者类中。</p>
<h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><p>参考工程：BuilderPattern</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>(1) 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p>
<p>(2) 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”</p>
<p>(3) 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。</p>
<p>(2) 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。</p>
<hr>
<hr>
<h2 id="结构形模式"><a href="#结构形模式" class="headerlink" title="结构形模式"></a>结构形模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p> 适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 </p>
<h4 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/patternAdapter.jpg"></p>
<p>● Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</p>
<p>● Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p>
<p>● Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</p>
<h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><p> AdapterPattern</p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>无论是对象适配器模式还是类适配器模式都具有如下优点：</p>
<p>(1) 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</p>
<p>(2) 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</p>
<p>(3) 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p>
<p>具体来说，类适配器模式还有如下优点：</p>
<p>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p>
<p>对象适配器模式还有如下优点：</p>
<p>(1) 一个对象适配器可以把多个不同的适配者适配到同一个目标；</p>
<p>(2) 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；</p>
<p>(2) 适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；</p>
<p>(3) 在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</p>
<p>对象适配器模式的缺点如下：</p>
<p>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p>
<hr>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p> 桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。 </p>
<h4 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/bridgepattern.jpg"></p>
<p>●Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</p>
<p>●RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。</p>
<p>●Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。</p>
<p>●ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。</p>
<h4 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h4><p>BridgePattern</p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>主题的维度是抽象的， 另一个维度接口，在抽象的主题里面调用另一个维度</p>
<p><strong>主要优点：</strong></p>
<p>(1)分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。</p>
<p>(2)在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。</p>
<p>(3)桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。</p>
<p><strong>主要缺点：</strong></p>
<p>(1)桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</p>
<p>(2)桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p> 组合多个对象形成<strong>树形结构</strong>以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。 </p>
<h4 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h4><p>● Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。</p>
<p>● Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。</p>
<p>● Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</p>
<h4 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h4><p>参考工程： CompositePattern </p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>(1) 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</p>
<p>(2) 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</p>
<p>(3) 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</p>
<p>(4) 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。                        </p>
<p><strong>主要缺点：</strong></p>
<p>在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。</p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><h4 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h4><p> 动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。 </p>
<h4 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h4><p>● Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</p>
<p>● ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</p>
<p>● Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</p>
<p>● ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</p>
<h4 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h4><p>参考工程： DecoratorPattern </p>
<h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>(1) 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</p>
<p>(2) 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。</p>
<p>(3) 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。</p>
<p>(4) 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</p>
<p>(2) 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><h4 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h4><p> 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 </p>
<h4 id="结构-9"><a href="#结构-9" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20191113203800361.png"></p>
<p>Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</p>
<p> SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p>
<h4 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h4><p> FacadePattern</p>
<h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>(1) 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。</p>
<p>(2) 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。</p>
<p>(3) 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</p>
<p><strong>主要缺点：</strong></p>
<p>(1) 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活 性。</p>
<p>(2) 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h4 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h4><h4 id="结构-10"><a href="#结构-10" class="headerlink" title="结构"></a>结构</h4><h4 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h4><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p><strong>主要缺点：</strong></p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h4><h4 id="结构-11"><a href="#结构-11" class="headerlink" title="结构"></a>结构</h4><h4 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h4><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p><strong>主要缺点：</strong></p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><h4 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h4><h4 id="结构-12"><a href="#结构-12" class="headerlink" title="结构"></a>结构</h4><h4 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h4><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p><strong>主要缺点：</strong></p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h4><p> 将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。 </p>
<h4 id="结构-13"><a href="#结构-13" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20191115171949964.png"></p>
<p>● Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行<br>请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。<br>● ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类<br>中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方<br>法时，将调用接收者对象的相关操作(Action)。<br>● Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不<br>需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以<br>将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求<br>接收者的相关操作。<br>● Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。</p>
<h4 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h4><p>CommandPattern</p>
<p>自定义功能键的实现</p>
<p>可以将命令用一个数组来存储， 这样可以实现批处理</p>
<p>此外还可以是实现一个撤销的功能， 类似于备忘录模式， 两个可以实现撤销操作的模式</p>
<h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p>(1) 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间<br>实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的<br>请求者使用，两者之间具有良好的独立性。<br>(2) 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此<br>增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的<br>要求。<br>(3) 可以比较容易地设计一个命令队列或宏命令（组合命令）。<br>(4) 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。</p>
<p><strong>主要缺点：</strong></p>
<p>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调<br>用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这<br>将影响命令模式的使用。</p>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>以不同的方式操作复杂对象结构</p>
<h4 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h4><p>访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以<br>在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型。<br>模式。</p>
<h4 id="结构-14"><a href="#结构-14" class="headerlink" title="结构"></a>结构</h4><p>●Vistor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一<br>个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体<br>访问者需要实现这些操作方法，定义对这些元素的访问操作。<br>●ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操<br>作用于访问对象结构中一种类型的元素。<br>●Element（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法<br>通常以一个抽象访问者作为参数。【稍后将介绍为什么要这样设计。】<br>●ConcreteElement（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者<br>的访问方法以便完成对一个元素的操作。<br>● ObjectStructure（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提<br>供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，<br>如一个List对象或一个Set对象。</p>
<h4 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h4><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><p><strong>主要优点：</strong></p>
<p><strong>主要缺点：</strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/09/10/notepad/java/JavaStudy/src/main/java/Basic/Collection/README/</url>
    <content><![CDATA[<h2 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h2><blockquote>
<p>copy from zengsiyan</p>
</blockquote>
<p>Java对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储<font color=red>（内存上的存储）</font>。</p>
<p>然而使用数组存储对象存在一些弊端，因此，Java引入集合框架，实现<font color=red><strong>动态</strong></font>的存储对象的容器。</p>
<ul>
<li>首先，了解<font color=red>数组</font>的<strong>特点</strong>与<strong>局限性</strong>：</li>
</ul>
<blockquote>
<ul>
<li>数组在内存存储方面的特点：<ul>
<li>数组初始化以后，<strong>长度就确定了</strong>。</li>
<li>数组声明的类型就决定了元素初始化的<strong>类型</strong>。</li>
</ul>
</li>
<li>数组在存储数据方面的弊端：<ul>
<li>数组初始化以后长度不可改变，<strong>无法扩展</strong>。</li>
<li>数组提供的属性和方法相对较少，不便于增、删（或<strong>效率不高</strong>）</li>
<li>数组存储数据有序可重复（或<strong>存储数据的特点单一</strong>）</li>
</ul>
</li>
</ul>
</blockquote>
<p>而数组的弊端在Java集合上都得到了解决。</p>
<ul>
<li>Java集合分为<font color=red><strong>Collection接口</strong></font>和<font color=red><strong>Map接口</strong></font>两大块：</li>
</ul>
<p>$$<br>x \begin{cases}Collection：单列数据，定义了存取一组对象的方法的集合\\Map：双列数据，保存具有映射关系“key-value对”的集合\end{cases}<br>$$</p>
<p>​<br>​                        </p>
<p><img src="assert/collection" alt="clooetion"></p>
<p><img src="assert/005PzEdegy1g5iw4w2ksuj30f6083gls.jpg" alt="map"></p>
<h2 id="1-List接口"><a href="#1-List接口" class="headerlink" title="1. List接口"></a>1. List接口</h2><h3 id="1-1-ArrayList源码分析"><a href="#1-1-ArrayList源码分析" class="headerlink" title="1.1 ArrayList源码分析"></a>1.1 ArrayList源码分析</h3><ol>
<li><strong>底层的物理存储结构：</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br></pre></td></tr></table></figure>

<p>可见，ArrayList的物理存储结构为Object类型的数组——elementData。</p>
<p>然后，一个私有整型变量记录elementData中真实存放的元素的个数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>构造器：</strong></li>
</ol>
<ul>
<li><strong>空参构造</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">  * 这个注释是JDK7的注释，如果是JDK7，那么这里会创建出一个默认长度为10的Object[]数组</span></span><br><span class="line"><span class="comment">  * 而JDK8没有直接创建长度为10的数组。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接将elementData赋值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">  * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">  * first element is added.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// DEFAULTCAPACITY_EMPTY_ELEMENTDATA是全局常量，长度为0的Object数组，JDK8这样做的好处是最大限度的节省了内存空间，它会等到真正添加元素时再创建数组。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>意即：调用ArrayList的空参构造器，底层会将全局常量（一个长度为0的Object数组）赋给elementData。</p>
<ul>
<li><strong>定容构造：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">  *         is negative</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始容量大于0，那么创建指定容量的Object数组赋值给elementData</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;	<span class="comment">// 指定容量为0，将elementData赋值为空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 指定容量为负数，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 如果定容构造器的容量被指定为0，那么elementData也被赋值为一个全局常量。（长度为0的Object数组）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<blockquote>
<p><font color=red><strong>EMPTY_ELEMENTDATA</strong></font> 与 <font color=red><strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong></font>均是长度为0的Object数组，且均是全局常量。</p>
<p>但是前者是在定容构造器容量为0时为elementData赋值（理论上的容量是0）。</p>
<p>后者是空参构造器为elementData赋值（理论上的容量是10，只是现在没有创建）。它实际上是在add时再创建。</p>
</blockquote>
<ol start="3">
<li><strong>add(E e)方法</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;		<span class="comment">// 容量满足需求了，那将指定的这个元素追加到原数组末尾</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是确定增加一个元素后，需不需要扩容。然后在满足容量的elementData中新增元素便可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将必须存储的最小容量值作为参数（minCapacity）传入，以判断是否有扩容的必要</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算一次容量，实际上是顺应空参构造中的DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里就体现了JDK8与JDK7不同的地方，对于空参构造，JDK8是在这里为默认长度为10的Object开辟空间的。即如果elementData是被空参构造赋值过且数组未使用过，那么返回默认长度和最小长度中最大的那个值作为新的最小长度。</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// DEFAULT_CAPACITY是类中定义的全局常量，它的值为10</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果elementData不是默认空参构造过未初始化的，那么直接返回最小容量</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)	<span class="comment">// 判断是否有扩容的必要</span></span><br><span class="line">        grow(minCapacity);	<span class="comment">// 扩容方法的具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">  * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;	<span class="comment">// 绑定原有长度</span></span><br><span class="line">    <span class="comment">// 将新长度扩容为原有长度的1.5倍（原长+原长/2）</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新长度还是小于最小容量，那么最小容量就作为新长度（默认空参构造会在这里被指定为10）</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)	<span class="comment">// 极端的大于整数界限的情况</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);	<span class="comment">// 数组扩容方法，将elementData扩容为newCapacity，并且原有数据不变，返回值更新elementData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，ArrayList的一次add就完成了。</p>
<p><strong>小结：JDK8在处理ArrayList的空参构造上使用<font color=red>延迟创建</font>的方式，较大限度的节省了内存空间。</strong></p>
<h3 id="1-2-LinkedList源码分析"><a href="#1-2-LinkedList源码分析" class="headerlink" title="1.2 LinkedList源码分析"></a>1.2 LinkedList源码分析</h3><ol>
<li><strong>底层的物理存储结构：</strong></li>
</ol>
<p>底层的物理存储结构是<font color=red>双向链表</font>，其定义了名为Node的内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 三个属性元素、后序节点、前序节点</span></span><br><span class="line">    E item;		</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList中比较核心的<font color=red>三个属性</font>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;		<span class="comment">// 记录双向链表中元素的个数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Pointer to first node.</span></span><br><span class="line"><span class="comment">  * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">  *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;	<span class="comment">// 标识双向链表中第一个元素所在的节点</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Pointer to last node.</span></span><br><span class="line"><span class="comment">  * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">  *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;		<span class="comment">// 标识双向链表中最后一个元素所在的节点</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>构造器：</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty list.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，空参构造器调Object的空参构造，它们什么都不会做，也就是那三个属性都将是默认值：</p>
<blockquote>
<ul>
<li><p>size = 0;    </p>
</li>
<li><p>first = null;</p>
</li>
<li><p>last = null;</p>
</li>
</ul>
</blockquote>
<ol start="3">
<li><strong>add(E e)：</strong></li>
</ol>
<p>因为双向链表本身就是动态的，因此不在需要频繁的去考虑扩容、缩容等问题了。其add方法就是新建一个节点，然后将这个节点的指针与链表末尾节点的指针绑定好就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addLast&#125;.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);	<span class="comment">// 在双向链表的尾部添加元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Links e as last element.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;		<span class="comment">// 绑定双向链表的尾节点</span></span><br><span class="line">    <span class="comment">// 创建待添加的新节点，前序节点为双向链表的尾节点，后序节点为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);	</span><br><span class="line">    <span class="comment">// 更新双向链表的尾节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果原双向链表为空（原尾节点为null代表链表空）</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;	<span class="comment">// 那么首节点和尾节点都会指向这个新增的第一个节点</span></span><br><span class="line">    <span class="keyword">else</span>					<span class="comment">// 如果原双向链表非空，那么原尾节点的后续指向新增节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;					<span class="comment">// 双向链表元素个数加一</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-Collections-SynchronizedList和Vector的区别"><a href="#1-3-Collections-SynchronizedList和Vector的区别" class="headerlink" title="1.3 Collections.SynchronizedList和Vector的区别"></a>1.3 Collections.SynchronizedList和Vector的区别</h3><ul>
<li><p>如果使用add方法，那么他们的扩容机制不一样。</p>
</li>
<li><p>SynchronizedList可以指定锁定的对象。</p>
</li>
</ul>
<p>（Collections.SynchronizedList只是使用同步代码块包裹了ArrayList的方法，而ArrayList和Vector中同名方法的方法体内容并无太大差异，所以在锁定范围和锁的作用域上两者并无却别。 在锁定的对象区别上，SynchronizedList的同步代码块锁定的是mutex对象，Vector锁定的是this对象。那么mutex对象是SynchronizedList在使用构造函数时可以传入一个Object,如果在调用的时候显示的传入一个对象，那么锁定的就是用户传入的对象。如果没有指定，那么锁定的也是this对象。）</p>
<h2 id="2-Set接口"><a href="#2-Set接口" class="headerlink" title="2. Set接口"></a>2. Set接口</h2><ul>
<li><p>Set接口继承了Collection接口，而且Set接口内没有额外的提供方法。</p>
</li>
<li><p>Set接口代表了<strong>无序、不可重复</strong>的集合。</p>
</li>
<li><p>Set的主要实现类有：<font color=red>HashSet、LinkedHashSet、TreeSet</font>。</p>
</li>
</ul>
<blockquote>
<ul>
<li>HashSet：<ul>
<li>Set接口的主要实现类。</li>
<li>线程不安全，效率高。</li>
<li>能够存储null值。</li>
</ul>
</li>
<li>LinkedHashSet：<ul>
<li>是HashSet的子类。</li>
<li>以链表的方式组织，可以<font color=red>按照添加时的顺序</font>遍历LinkedHashSet中的数据。</li>
</ul>
</li>
<li>TreeSet：<ul>
<li>底层使用HashMap，即，实际采用<font color=red><strong>红黑树</strong></font>存储。</li>
<li>要求TreeSet中存放的对象均属于同一个类。</li>
<li>可以按照对象指定的属性进行排序。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>理解Set的无序性：</strong></li>
</ul>
<blockquote>
<p>Set的无序性不等同于随机性，它存储的数据在底层不是依次存放的，<font color=red>而是根据数据的Hash值决定元素的存放位置。</font></p>
</blockquote>
<ul>
<li><strong>理解Set的不可重复性：</strong></li>
</ul>
<blockquote>
<p>Set中保证添加的元素在使用equals()方法判断时不能返回true，即相同的元不能被添加进来。</p>
<p><font color=red><strong>注意</strong>：Set判断重复元素的方法是先根据hashCode方法返回的hash值确定元素要存放的位置索引，然后再与具有相同索引的所有元素去equals()。</font>这样做可以大大减少比较次数，提高效率。</p>
</blockquote>
<p><strong><font color=red>由此也可知，Set中存放的元素类型应该是重写了equals()和hashCode()的类型。意即，使用HashSet及其子类，必定需要重写equals()和hashCode()方法，而且equals()和hashCode()方法的重写应当要满足相等的对象应该具有相等的hash值的原则。</font></strong></p>
<h3 id="2-1-重写hashCode"><a href="#2-1-重写hashCode" class="headerlink" title="2.1 重写hashCode()"></a>2.1 重写hashCode()</h3><p>使用IDEA自动重写hashCode()方法时，会发现有系数<font color=red>31</font>，原因：</p>
<ul>
<li>选择系数的时候要选择尽量大的系数，因为如果计算出来的hash地址越大，所谓的“冲突”就会越少，查找起来的效率就会越高。<font color=red>(所以一般要乘以一个系数)</font></li>
<li>并且31只占用5bits，<strong>相乘造成数据溢出的概率较小</strong>。</li>
<li>i*31可以由<font color=red>( i &lt;&lt; 5 ) - 1</font>来表示，现在很多虚拟机都有相关的优化，能够提高算法效率。</li>
<li>31是一个素数，素数的作用就是某个数乘以一个素数，那么结果只能被被乘数、素数本身和1整除，同样可以减少冲突。</li>
</ul>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 重写Object类的hashCode方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object.hash(name, age)实际上调用的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span> </span>&#123;	<span class="comment">// 可变长参数</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这里可见其生成hash值的过程</span></span><br><span class="line">    <span class="keyword">for</span> (Object element : a)</span><br><span class="line">        <span class="comment">// 如果elemenet是null，那么返回0，如果不是那么返回这个类型重写的hashCode值然后与乘了31的result进行累和</span></span><br><span class="line">        result = <span class="number">31</span> * result + (element == <span class="keyword">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重写hashCode与equals应该要具有一致性，即<font color=red><strong>equals()中比较的属性在hashCode中也要用到。</strong></font></li>
</ul>
<h3 id="2-2-主要实现类"><a href="#2-2-主要实现类" class="headerlink" title="2.2  主要实现类"></a>2.2  主要实现类</h3><ol>
<li><strong>HashSet</strong></li>
</ol>
<ul>
<li>HashSet底层是以<font color=red>”数组+链表“</font>的方式实现的。</li>
<li>HashSet中元素添加的过程：<strong>【必须理解这个过程，这也是HashMap的过程】</strong></li>
</ul>
<blockquote>
<ul>
<li>想要在HashSet中添加元素a，那么<strong>首先要调用元素a所在类的hashCode方法</strong>，计算元素a的hash值。</li>
<li>此hash值通过某种hash函数确定（计算出）<strong>HashSet底层数组中的存放位置</strong>。判断该位置是否有其他元素。<ul>
<li>如果没有其他元素，那么直接添加，返回<font color=red><strong>添加成功</strong></font>。</li>
<li>如果有其他元素<font color=red><strong>（并且这些元素会以链表形式存放）</strong></font>，那么针对链表上的每个元素调用a元素所在类的equals方法<font color=red>比较两个元素内容是否相等</font><ul>
<li>如果equals返回true，那么<font color=red><strong>添加失败</strong></font>。</li>
<li>a.equals(链上所有元素)均返回false，那么元素a**<font color=red>添加成功</font>**。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ol start="2">
<li><strong>LinkedHashSet</strong></li>
</ol>
<p>LinkedHashSet作为HashSet的子类，在添加数据<font color=red>（添加数据的操作与HashSet一样）</font>的同时每个数据还维护了<font color=red>两个引用</font>，记录此数据的前序数据和后序数据。</p>
<p>优点： 在需要对集合进行频繁的遍历时，LinkedHashSet效率高于HashSet。</p>
<ol start="3">
<li><strong>TreeSet</strong></li>
</ol>
<ul>
<li><p>TreeSet的底层实现是红黑树。</p>
</li>
<li><p>向TreeSet中添加的元素必须是同一个类的对象。（因为TreeSet是实现排序类的，如果要排序，那么集合中存储的元素应该都具有相同的属性）。</p>
</li>
<li><p>使用TreeSet的空参构造 —— 自然排序。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person that = (Person) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(that.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;illegal argument!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空参构造，以自然排序为依据</span></span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;tina&quot;</span>, <span class="number">15</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;tony&quot;</span>, <span class="number">19</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;kobe&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;jhon&quot;</span>, <span class="number">17</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;jhon&quot;</span>, <span class="number">13</span>));</span><br><span class="line">    <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person&#123;name=<span class="string">&#x27;jhon&#x27;</span>, age=<span class="number">17</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;kobe&#x27;</span>, age=<span class="number">23</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;tina&#x27;</span>, age=<span class="number">15</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;tony&#x27;</span>, age=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<blockquote>
<p>输出的结果中，最后一条记录new Person(“jhon”, 13)没有加入集合。原因：</p>
<ul>
<li>**<font color=red>特别注意</font>**，如果TreeSet中的元素使用的是自然排序（实现Comparable接口），<font color=red>那么TreeSet认为比较两个元素是否相等的标准为Comparable接口中compareTo方法的返回值（返回值为0则相等，不为0则不等）</font>。不再是equals方法了。然而，TreeSet中是不允许存放相等的元素的（这是Set集合的共性），所以最后这条名为jhon的记录就没有被添加到集合中。</li>
</ul>
</blockquote>
<ul>
<li>使用TreeSet的比较器构造 —— 定制排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不让Person类实现Comparable接口，而是在实例化TreeSet对象的时候使用Comparator构造器，便可实现定制排序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将Comparator实现类的对象作为参数来实现定制排序</span></span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">                Person person1 = (Person) o1;</span><br><span class="line">                Person person2 = (Person) o2;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(person1.age, person2.age);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;illegal argument!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;tina&quot;</span>, <span class="number">15</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;tony&quot;</span>, <span class="number">19</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;kobe&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;jhon&quot;</span>, <span class="number">17</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="string">&quot;jhon&quot;</span>, <span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同样，使用定制排序来实例化TreeSet对象，它内部比较两个元素是否相等的依据也是比较器中compare方法，而不是equals。</li>
<li>其实**<font color=red>排序的属性不能重复</font><strong>的原理很简单，</strong>因为TreeSet底层是红黑树实现的（二叉树），父节点的左子节点必定小于父节点，右子节点必定大于父节点。不会存在两个节点相同的情况！**</li>
</ul>
<h3 id="2-3-面试题"><a href="#2-3-面试题" class="headerlink" title="2.3 面试题"></a>2.3 面试题</h3><p>假设Person类重写了equals()与hashCode()方法，考虑如下程序的运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">    set.remove(p1);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Person&#123;name=<span class="string">&#x27;BB&#x27;</span>, age=<span class="number">1002</span>&#125;, Person&#123;name=<span class="string">&#x27;AA&#x27;</span>, age=<span class="number">1001</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;BB&#x27;</span>, age=<span class="number">1002</span>&#125;, Person&#123;name=<span class="string">&#x27;CC&#x27;</span>, age=<span class="number">1001</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;BB&#x27;</span>, age=<span class="number">1002</span>&#125;, Person&#123;name=<span class="string">&#x27;CC&#x27;</span>, age=<span class="number">1001</span>&#125;, Person&#123;name=<span class="string">&#x27;CC&#x27;</span>, age=<span class="number">1001</span>&#125;]</span><br><span class="line">[Person&#123;name=<span class="string">&#x27;BB&#x27;</span>, age=<span class="number">1002</span>&#125;, Person&#123;name=<span class="string">&#x27;CC&#x27;</span>, age=<span class="number">1001</span>&#125;, Person&#123;name=<span class="string">&#x27;CC&#x27;</span>, age=<span class="number">1001</span>&#125;, Person&#123;name=<span class="string">&#x27;AA&#x27;</span>, age=<span class="number">1001</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<blockquote>
<ul>
<li>第一行输出没有疑问，显然p1和p2的哈希值是不同的，直接输出集合中的两个元素p1和p2。</li>
<li>程序在执行p1.name = “CC”;后再去调用remove方法，那么系统就会根据p1对象生成的新的哈希值去找底层存储p1对象的位置。<ul>
<li>然而，<font color=red>之前存放位置的哈希值是根据AA生成的，现在是以CC生成的哈希值去寻找，自然位置不同，那么HashSet会认为集合中根本就没有这个p1这个对象，</font>因此直接没有进行删除操作。所以得到第二行的输出。</li>
</ul>
</li>
<li>程序在执行set.add(new Person(1001, “CC”));后，会根据1001和CC两个属性去生成哈希值，然后去存放这个新的Person对象。<ul>
<li>然而之前的程序并<font color=red>没有在这个哈希值的位置存放任何内容</font>，因此这个对象将被成功放入集合中。所以得到第三行输出。</li>
</ul>
</li>
<li>程序在执行set.add(new Person(1001, “AA”));后，会根据1001和AA两个属性生成哈希值，然后去存放这个新的Person对象。<ul>
<li>然而这个位置已经存放了对象Person(1001, “CC”)，<font color=red>因此系统会转而去判断equals()的返回值</font>。很显然，返回值为false，因此Person(1001, “AA”)对象被成功添加到集合中。所以得到第四行输出。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3-Map接口"><a href="#3-Map接口" class="headerlink" title="3. Map接口"></a>3. Map接口</h2><p>Map接口作为双列数据的主接口，主要用于存放键值对数据。</p>
<p>Map接口的主要实现类：</p>
<blockquote>
<ul>
<li>HashMap：作为Map接口的<font color=red>主要实现类</font>。线程不安全，效率高。能够存储null的key和value。<font color=red>底层实现，JDK7为数组+链表，JDK8为数组+链表+红黑树。</font><ul>
<li>LinkedHashMap：HashMap的子类。保证在遍历Map元素时，可以按照添加的顺序实现遍历<strong>（原因，在HashMap的底层结构基础上，添加了一对指针，指向前一个和后一个元素）</strong>。<font color=red>对于频繁的遍历操作，此类的执行效率高于HashMap。</font></li>
</ul>
</li>
<li>TreeMap：保证按照添加的key-value对进行排序，实现排序遍历。排序依据为key（比较key是唯一的、不重复的）。<font color=red>底层使用红黑树实现。</font></li>
<li>Hashtable：作为Map接口的古老实现类。线程安全，效率相对较低。不能够存储null的key和value。<font color=red>（基本不会使用，即使需要线程安全的也会找Collections的方法替代）</font><ul>
<li>Properties：Hashtable的子类，其key和value都是String类型的。常用来处理配置文件。 </li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>理解Map结构</strong></li>
</ul>
<p>$$<br>\begin{cases}</p>
<ol>
<li>key\<br>\</li>
<li>value\<br>\</li>
<li>Entry<br>\end{cases}<br>$$</li>
</ol>
<blockquote>
<ul>
<li>**<font color=red>key 是无序的不可重复的，其主要使用Set来存储所有的key</font>**。但是具体是什么类型的Set就要看是什么类型的Map了。（比如，如果是HashMap，那么key就用HashSet，如果是LinkedHasMap，那么key就用LinkedHashSet）。</li>
<li>**<font color=red>value是无序可重复的</font>**，泛泛来说就是用Collection存储的。</li>
<li>**<font color=red>Entry是无序不可重复的，</font>**使用Set进行存储。注意，一个key-value(键值对)就构成一个Entry对象。</li>
</ul>
</blockquote>
<h3 id="3-1-HashMap源码分析"><a href="#3-1-HashMap源码分析" class="headerlink" title="3.1 HashMap源码分析"></a>3.1 HashMap源码分析</h3><ul>
<li><p>JDK7的与JDK8的HashMap实现略有不同，主要以JDK8为准，然后选择性提示JDK7中的区别部分。</p>
</li>
<li><p>JDK8中HashMap的底层实现主要是：<font color=red>数组 + 链表 + 红黑树</font>。</p>
</li>
</ul>
<p>HashMap中一些主要常量与结构：</p>
<ul>
<li>常量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">  * 全局常量，默认初始化数组容量，定义为16.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">  * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">  * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">  * 全局常量，数组能够承受的最大容量，定义为2^30。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">  * 全局常量，默认加载因子0.75，其作用是用于判断数组是否需要扩容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">  * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">  * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">  * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">  * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">  * shrinkage.</span></span><br><span class="line"><span class="comment">  * 全局常量，如果某个数组位置的链表长度大于这个默认阈值8，那么就将链表转化成红黑树</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">  * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">  * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">  * 全局常量，如果某个数组位置的红黑树节点个数小于这个阈值，那么就将红黑树转换成链表</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">  * 静态内部类，存放键值对的基本结构Node（JDK7直接是Entry类），Node同样也是实现了Map.Entry接口。</span></span><br><span class="line"><span class="comment">  * 主要的属性是一个标识Node的hash值，一个键，一个值，一个指向下一节点的引用。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;	<span class="comment">// 注意，键赋值后不能改变，值可以改变</span></span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="comment">// 重写toString方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">	<span class="comment">// 重写hashCode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// set方法（只有value能够set，key不能set）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 重写equals()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">  * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">  * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">  * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">  * 核心数组。Node&lt;K,V&gt;类型的数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">  * for keySet() and values().</span></span><br><span class="line"><span class="comment">  * 键的存放是以Set的方式（不可重复是关键）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">  * 真实元素的长度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">  * 判断数组是否需要扩容的阈值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">  * 加载因子，主要用于判断数组是否需要扩容</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>



<ol>
<li><strong><font color=red>空参构造</font></strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">  * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">  * 这些注释是JDK7的，如果是JDK7，那么空参构造就会创建一个Entry数组，且默认初始长度为16</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空参构造中只是简单的指示下加载因子为DEFAULT_LOAD_FACTOR（0.75）; </span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><font color=red><strong>定容构造</strong></font></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial </span></span><br><span class="line"><span class="comment">  * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.   </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定默认的加载因子后，转而调用带加载因子的构造器</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">  * capacity and load factor.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">  *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定初始容量小于0，抛非法参数异常</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 给定初始容量大于数组最大，那么数组最大就作为初始常量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 如果加载因子小于0或加载因子不是合法的浮点数，抛非法参数异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 为加载因子赋值，并计算阈值（数组是否需要扩容的阈值）</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li><p>loadFactor与threshold的值直接决定数组是否需要扩容。</p>
</li>
<li><p>HashMap的扩容不是简单的数组用完了就扩，因为由于Hash冲突等原因，可能在某个数组的索引位置，一个链会拉的很长很长。而其余的数组索引根本就没有使用。所以要引入加载因子。</p>
</li>
<li><p><font color=red>加载因子太大可能导致一个位置上链很长，加载因子太小可能导致数组的利用率太低。</font>可能根据统计学的等计算加载因子为0.75时较合适。</p>
</li>
</ul>
</blockquote>
<ol start="3">
<li><font color=red><strong>put方法</strong></font></li>
</ol>
<p>可以发现，不论是空参构造，还是两个定容构造，HashMap构造器中并没有创建核心的底层数组。这是JDK8区别与JDK7的地方（JDK7是直接在构造器中就创建了）。与之前的ArrayList类似，JDK8使用了<font color=red>延迟创建机制</font>，<strong>它会在真正需要使用数组的时候再去创建数组，目的是最大限度的减少了内存空间</strong>。</p>
<p>HashMap的put方法主要考虑三个方面的问题：<font color=red>底层数组的创建、数组扩容、红黑树转换</font>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">  * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">  * value is replaced.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">  *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">  *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">  *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">  * put方法的最外层调用，注意，他是有返回值的，如果当前添加的键值对的键在map中已经存在，那么将旧值替换为新值，并且返回旧值。如果不存在，那么返回null。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 转而调用putVal方法完成处理，参数是：</span></span><br><span class="line"><span class="comment">      * 根据key计算得到的hash值</span></span><br><span class="line"><span class="comment">      * key</span></span><br><span class="line"><span class="comment">      * value</span></span><br><span class="line"><span class="comment">      * 后面两个忽略。。</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">  * 该方法是实现put方法的主体，主要流程如下：</span></span><br><span class="line"><span class="comment">  * 	1. 看是否是没有初始化的数组。如果是，那么就转到扩容方法进行初始化。</span></span><br><span class="line"><span class="comment">  * 	2. 计算hash值对应的数组索引位置，如果该位置上没有元素，直接插入成功。</span></span><br><span class="line"><span class="comment">  * 	3. 如果有元素了，那么用当前key的hash值和该索引位置上链表的所有节点的hash值进行比较。如果全都不同，那么插入成功。如果其中有相同的，那么比较调用当前节点的equals()方法进行比较，如果equals()返回false，那么仍然可以插入，如果equals（）返回true那么用当前节点的value去更新旧值。</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个tab作为属性table的副本，节点p用来作为某个节点的副本</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果属性table为空，或者map的长度为0，那么就表示底层数组没有初始化，转而就去调扩容方法来将数组进行初始化。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 节点p指向key的hash值计算得到的数组索引位置上的节点，如果这个索引位置上没有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 那么直接调用插入方法，将新节点插入在这个索引位置上</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果计算得到的数组索引上有元素了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果链表上的头结点和待插入节点的hash值相等且equals也是true，那么后面是直接会执行更新value操作的，这里给e赋值是标志。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果这个数组索引上不是链表而是红黑树，那么调用红黑树的put操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果待插入节点和头结点没有同一个key，那么比较链表上之后的所有节点的hash值和equals方法。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果全部比较完，还是没有相同的key那么这里e会是null（就是需要直接插入的情况）</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将新节点插在链表最末尾（七上八下，JDK7是插在头节点前面，JDK8是插在最末尾）</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 判断一下新节点插入后，链表是否需要转化称红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果存在与待插入节点相等的key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 循环增量</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e有值，那就是存在与待插入的节点相同的key，那么执行更新旧value的操作</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果执行了直接插入的操作，那么这里判断一下要不要扩容。且插入节点（没有更新旧value）返回null</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>有一点需要注意</strong>，<font color=red>即使是同一个数组索引位置上同一链表上的节点，也是会hash值不同的，而且很常见。</font>因为这个索引位置的确定是通过hash值取与运算得到的，所以任然有将待插入元素的key与链表上的所有元素的key比较hash值的必要。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">  * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">  * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">  * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">  * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">  * 数组扩容的主体方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// oldTab作为属性table的副本</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 如果是空参构造来的这里（数组没有赋值），那么原容量为0，否则就是取原数组的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 属性阈值的副本oldThr</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果不是还未使用过的数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果原容量已经（或者大于）最大容量了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 那么容量不变，阈值更新为整型的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，新容量扩容为原来的两倍。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 如果扩容后小于最大容量，并且原容量是大于默认容量的，那么将阈值扩大一倍（原来的两倍）</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定容构造器初始化了阈值，但是如果数组未定义过，因此数组新容量取阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 空参构造来到这里（数组没定义过，阈值没初始化过）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;	<span class="comment">// 新容量为默认容量值：16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新阈值为0，（定容构造调用会来到这里）那么，重新计算阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;	</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将属性阈值更新</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 容量确定后，用新容量创建新的底层数组，然后完成将原有数组中的元素嫁接到新数组中的一系列工作</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;		<span class="comment">// 数组统一是在这里造的</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-2-LinkedHashMap源码分析"><a href="#3-2-LinkedHashMap源码分析" class="headerlink" title="3.2 LinkedHashMap源码分析"></a>3.2 LinkedHashMap源码分析</h3><p>搞懂HashMap的底层实现后LinkedHashMap的底层实现就很简单了。</p>
<p><font color=red>LinkedHashMap是HashMap的子类，而且LinkedHashMap中很方法并没有重写，而是直接用了父类的方法。</font>因此只需重点关注不同部分。</p>
<ul>
<li>空参构造</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment">  * with the default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();	<span class="comment">// 直接调的父类HashMap的空参构造方法</span></span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定容构造</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span></span><br><span class="line"><span class="comment">  * with the specified initial capacity and a default load factor (0.75).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);	<span class="comment">// 同样是父类HashMap定容构造方法</span></span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，重点关注他的put方法如何实现在遍历Map元素时，可以按照添加的顺序实现遍历便可了。</p>
<p>但是</p>
<blockquote>
<ul>
<li>LinkedHashMap没有重写父类的put方法，因此子类对象调用put方法是直接去调的父类的put方法。</li>
<li>LinkedHashMap也没有重写父类的putValue方法，因此也是直接用的父类方法。</li>
</ul>
</blockquote>
<p>但是，LinkedHashMap重写了父类的newNode方法，即，在向数组（或数组索引位置上的链表）添加元素时，会调用子类自己的newNode方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调的是LinkedHashMap中自定义的结构Entry</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">  * Entry是HashMap中Node结构的子类，它继承了父类Node的结构外还定义了两个指针before和after，这样就在底层数组存放的同时，一个指向他的前序一个指向它的后序。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>意即，虽然LinkedHashMap底层的存储仍然是数组+链表+红黑树，<font color=red>但是每个元素节点都配有指向前序和后序的节点。</font>这样，在遍历起来就靠前序、后序找了。针对需要频繁遍历的map而言，提高的效率（遍历效率）。<strong>其余的与HashMap无异。</strong></li>
</ul>
<h3 id="3-3-TreeMap"><a href="#3-3-TreeMap" class="headerlink" title="3.3 TreeMap"></a>3.3 TreeMap</h3><p>向TreeMap中添加键值对，<font color=red>要求key必须是由同一个类创建的对象</font>。因为要按照&lt;key进行排序，因此便要考虑比较器<strong>（Comparable或Comparator）</strong>。</p>
<p>注意，只能按照key中的属性来排序，不能按照value排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        Map treeMap = <span class="keyword">new</span> TreeMap(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Student &amp;&amp; o2 <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">                    Student s1 = (Student) o1;</span><br><span class="line">                    Student s2 = (Student) o2;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(s1.age, s2.age);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;illegal argument exception!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">// 按照键的age属性进行排序。切记，不可按值排序</span></span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Student(<span class="string">&quot;tom&quot;</span>, <span class="number">10</span>), <span class="number">1</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Student(<span class="string">&quot;mary&quot;</span>, <span class="number">9</span>), <span class="number">2</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Student(<span class="string">&quot;kobe&quot;</span>, <span class="number">12</span>), <span class="number">3</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Student(<span class="string">&quot;jerff&quot;</span>, <span class="number">20</span>), <span class="number">4</span>);</span><br><span class="line">        System.out.println(treeMap);</span><br><span class="line"><span class="comment">// 运行结果： &#123;Student&#123;name=&#x27;mary&#x27;, age=9&#125;=2, Student&#123;name=&#x27;tom&#x27;, age=10&#125;=1, Student&#123;name=&#x27;kobe&#x27;, age=12&#125;=3, Student&#123;name=&#x27;jerff&#x27;, age=20&#125;=4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color=red>注意</font>区别LinkedHashMap的顺序和有TreeMap的有序。前者是能够保证输出的时候能够按照输入的顺序输出，后者是真正的排序。</strong></p>
<h3 id="3-4-Properties"><a href="#3-4-Properties" class="headerlink" title="3.4 Properties"></a>3.4 Properties</h3><ul>
<li><p>Properties类是Hashtable类的子类，虽然说Hashtable不怎么用了，但是Properties用于处理属性（配置）文件帮助很大。</p>
</li>
<li><p>Properties的<font color=red>键值对都是String类型</font>。</p>
</li>
<li><p>存取数据建议使用<font color=red>setProperties(String key, String value)方法</font>和<font color=red>getProperties(String key)方法</font>。</p>
</li>
</ul>
<p>考虑如下实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 操作文件需要读取文件流（配置文件为.properties结尾的文件）</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">        <span class="comment">// 加载流对应的文件</span></span><br><span class="line">        properties.load(fis);</span><br><span class="line">        <span class="comment">// 获取配置信息</span></span><br><span class="line">        String name = properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String age = properties.getProperty(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name :&quot;</span> + name + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;age:&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-Collections工具类"><a href="#4-Collections工具类" class="headerlink" title="4. Collections工具类"></a>4. Collections工具类</h2><ul>
<li>Collections是一个操作Set、List和Map等集合的工具类。</li>
<li>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</li>
</ul>
<ol>
<li><font color=red><strong>void reverse(List )</strong></font> ：反转List中元素的顺序。</li>
<li><font color=red><strong>void shuffle(List )</strong> </font>： 对List集合元素进行随机排序。</li>
<li><font color=red><strong>void sort(List )</strong></font> ： 根据元素的自然顺序对指定List集合元素按升序排序。</li>
<li><font color=red><strong>void sort(List , Comparator )</strong></font>： 根据指定的Comparator产生的顺序对List集合元素进行排序。</li>
<li><font color=red><strong>void swap(List , int , int )</strong> </font>： 将指定List集合中的两元素顺序进行交换。</li>
<li><font color=red><strong>Object max(Collection )</strong> </font>： 根据元素的自然顺序(Comparable接口)，返回给定集合中的最大元素。</li>
<li><font color=red><strong>Object max(Collection , Comparator )</strong> </font>：根据Comparator指定的顺序，返回给定集合中的最大元素。</li>
<li><font color=red><strong>Object min(Collection )</strong> </font>： 根据元素的自然顺序(Comparable接口)，返回给定集合中的最小元素。</li>
<li><font color=red><strong>Object max(Collection , Comparator)</strong> </font>： 根据元素的自然顺序(Comparable接口)，返回给定集合中的最小元素。</li>
<li><font color=red><strong>int frequency(Collection , Object )</strong> </font>：返回指定集合中指定元素的出现次数。</li>
<li><font color=red><strong>void copy(List dest, List src)</strong> </font>： 将src中的内容复制到dest中。<strong>（注意，dest的长度要大于src才行）</strong></li>
<li><font color=red><strong>boolean replaceAll(Lits list, Object oldVal, Object newVal)</strong></font>：使用新值替换list对象中的所有旧值。</li>
</ol>
<p><strong>注意：使用copy方法一定要确保dest的长度不小于src：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List src = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        src.add(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        src.add(<span class="number">15</span>);</span><br><span class="line">        src.add(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 现要将src的复制到dest中,注意将dest的长度设置为src长度的这个操作</span></span><br><span class="line">        List dest = Arrays.asList(<span class="keyword">new</span> Object[src.size()]);</span><br><span class="line">        Collections.copy(dest, src);</span><br><span class="line">        System.out.println(dest);   <span class="comment">// [ok, 15, 16]</span></span><br><span class="line">        System.out.println(src);    <span class="comment">// [ok, 15, 16]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="13">
<li><font color=red><strong>List synchronizedList(List )</strong></font>：将参数List转换为一个线程安全的List，这个线程安全的List作为返回值输出。所有根本不需要用Vector。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list1 = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<ol start="14">
<li><font color=red><strong>Map synchronizedMap(Map )</strong></font>：将参数Map转换为一个线程安全的Map，这个线程安全的Map作为返回值输出。所以根本不需要用Hashtable。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Leetcode100</title>
    <url>/2019/12/28/notepad/algorithm/exercise/leetcode100/</url>
    <content><![CDATA[<h2 id="leetcode100-练习"><a href="#leetcode100-练习" class="headerlink" title="leetcode100 练习"></a><center>leetcode100 练习</center></h2><p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/add-two-numbers" >https://leetcode-cn.com/problems/add-two-numbers<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h4><blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
</blockquote>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/two-sum</span></span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>思路： 一开始看到这道题就是暴力，暴力不知道时间和空间够不够， 因此不写了，想了一会儿， 可以哈希一下，map[num[i]] = i,  用一个map来存储数据的值 和 下标， 这样遍历一遍就可以知道， 有没有 target - num[i]  对应的值， 如果有， 可以直接map到；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数字  map 下标</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            a[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>( a[temp] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[temp] != i)&#123;</span><br><span class="line">                    ans.push_back(i);</span><br><span class="line">                    ans.push_back(a[temp]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h4><blockquote>
<p> 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
</blockquote>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>刚拿到这道题的时候，想都没想，直接就遍历两条链表， 求出值， 然后再加起来， 结果是，给出了一个大于9位的数值，直接就超出了int的范围，看来我还是太年轻了，幼稚！！</p>
<p>然后看了下正确的题解， 遍历链表， 一位一位求， 像人工算超长的算法一样！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;      </span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* index = ans;</span><br><span class="line">        <span class="comment">//l l1 中的值； r l2 中的值；  a 进位</span></span><br><span class="line">        <span class="keyword">int</span> l, r, a;</span><br><span class="line">        l = r = a = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只要有一个不是空的就计算</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            l = l1 == <span class="literal">NULL</span> ? <span class="number">0</span> : l1-&gt;val;</span><br><span class="line">            r = l2 == <span class="literal">NULL</span> ? <span class="number">0</span> : l2-&gt;val;</span><br><span class="line">            <span class="comment">//计算每一位的和， 一开始a为0，没有进位</span></span><br><span class="line">            <span class="keyword">int</span> sum = l + r + a;    </span><br><span class="line">            sum -= sum&gt;= <span class="number">10</span> ? <span class="number">10</span> : <span class="number">0</span>; <span class="comment">//大于10的话减去10 进位</span></span><br><span class="line">            ListNode* temp = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            a = l + r + a&gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//指向答案下一个节点</span></span><br><span class="line">            index-&gt;next = temp;</span><br><span class="line">            index = temp;</span><br><span class="line">            <span class="comment">//响应移动</span></span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)   l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)   l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">             ListNode* temp = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">             index-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h4><blockquote>
<p> 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>


<p>​     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>思路：</p>
<p>一开始没考虑全题目的意思！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;  c;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c.find(s[i]) != c.end())&#123;</span><br><span class="line">                ans = c.size() &gt; ans? c.size() : ans;</span><br><span class="line">                c.clear();               </span><br><span class="line">            &#125;</span><br><span class="line">             c.insert(s[i]);    </span><br><span class="line">        &#125;</span><br><span class="line">        ans = c.size() &gt; ans? c.size() : ans; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>想都不用想肯定错了！</p>
<p>这道题的正确思路是滑动窗口的解题思想， 确保右边的“窗口”一定是没有重复的字母， 每次增加一个字符， 更新窗口的值，在这个过程中记录出现的最大值即为解。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 滑动窗口 start 窗口的开始</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, max = <span class="number">0</span>, j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i ++)&#123;<span class="comment">// 每当加入一个字符</span></span><br><span class="line">            <span class="keyword">for</span>(j = start; j &lt; i; j ++)&#123;  <span class="comment">// 遍历新的窗口</span></span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                     start = j + <span class="number">1</span>;			<span class="comment">//找到第一个相等的字符</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i - start + <span class="number">1</span> &gt; max)</span><br><span class="line">                max = i - start  + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="4-寻找两个有序数组的中位数todo"><a href="#4-寻找两个有序数组的中位数todo" class="headerlink" title="4.寻找两个有序数组的中位数todo"></a>4.寻找两个有序数组的中位数todo</h4><blockquote>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
</blockquote>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line">则中位数是 <span class="number">2.0</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">则中位数是 (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>



<p>//todo 没弄懂</p>
<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h4><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出: <span class="string">&quot;bab&quot;</span></span><br><span class="line">注意: <span class="string">&quot;aba&quot;</span> 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出: <span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>



<p>解题思路：</p>
<p>题解一： 中心查找</p>
<p>遍历一遍字符串， 如果当前的字符不对称就开始检查，现在是否为最大的回文串, 是就更新！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> size = len * <span class="number">2</span> - <span class="number">1</span>;<span class="comment">//一共有 2*n - 1 个重点</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;<span class="comment">//字符本身为中点</span></span><br><span class="line">                <span class="keyword">int</span> mid = i / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(mid - j &gt;= <span class="number">0</span> &amp;&amp; mid + j &lt; len</span><br><span class="line">                &amp;&amp; s[mid-j] == s[mid+j]) j++;</span><br><span class="line">                maxi = <span class="number">2</span> * j - <span class="number">1</span> &gt; max ? i : maxi;</span><br><span class="line">                max = <span class="number">2</span> * j - <span class="number">1</span> &gt; max ? <span class="number">2</span> * j - <span class="number">1</span> : max;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxi &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxi/ <span class="number">2</span> &lt;&lt;  <span class="string">&quot; *0*&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)&#123;<span class="comment">//不是以字符本身为中点</span></span><br><span class="line">                <span class="keyword">int</span> left = i / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(left - j &gt;= <span class="number">0</span> &amp;&amp; right + j &lt; len &amp;&amp; </span><br><span class="line">                s[left - j] == s[right + j]) j++;</span><br><span class="line">                maxi = <span class="number">2</span> * j &gt; max ? i : maxi;</span><br><span class="line">                max = <span class="number">2</span> * j &gt; max ? <span class="number">2</span> * j : max;   </span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxi &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxi/ <span class="number">2</span> &lt;&lt;  <span class="string">&quot; *1*&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxi &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(maxi % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.substr(maxi / <span class="number">2</span> - (max/<span class="number">2</span>), max);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> s.substr(maxi / <span class="number">2</span> - max/<span class="number">2</span> +<span class="number">1</span>, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>题解二： 动态规划</p>
<p>p[ i ] [ j ] 表示 i 到 j 为回文串！</p>
<p>递推式：</p>
<p>p[i+1] [j+1] =  p[ i ] [ j ] + s[i+1] [j+1];</p>
<p>p[i] [j] = (i == j - 1 ) &amp;&amp; s[i] [j - 1];</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">bool</span> flag[len][len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max, l;</span><br><span class="line">        l = max = <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                flag[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i ++)  flag[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++)&#123;      </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(j == i - <span class="number">1</span> &amp;&amp; s[j] == s[i])&#123;</span><br><span class="line">                    flag[j][i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(  max &lt; i - j ) max = i - j , l = j;</span><br><span class="line">                 &#125; </span><br><span class="line">                 <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; flag[j][i<span class="number">-1</span>] &amp;&amp; s[j<span class="number">-1</span>] == s[i])&#123;</span><br><span class="line">                    flag[j<span class="number">-1</span>][i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(  max &lt; i - (j - <span class="number">1</span>) ) max = i - j + <span class="number">1</span>, l = j<span class="number">-1</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(l,max+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="6-Z字型变换"><a href="#6-Z字型变换" class="headerlink" title="6. Z字型变换"></a>6. Z字型变换</h4><blockquote>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
</blockquote>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<p>L    C     I        R<br>E T O E S  I     I  G<br>E    D    H       N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<p>string convert(string s, int numRows);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;LEETCODEISHIRING&quot;</span>, numRows = <span class="number">3</span></span><br><span class="line">输出: <span class="string">&quot;LCIRETOESIIGEDHN&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;LEETCODEISHIRING&quot;</span>, numRows = <span class="number">4</span></span><br><span class="line">输出: <span class="string">&quot;LDREOEIIECIHNTSG&quot;</span></span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>这道题首先想到的是使用找规律， 规律其实很好找！</p>
<p>看到题解中有一个很不错的思路，是把这个的过程直接转换成代码的形式， 好多的题都是这样的！</p>
<p>之前不知道这种做法， 真的是孤陋寡闻！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">		<span class="comment">// 这个表示每一行的字符</span></span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">rows</span><span class="params">(min(numRows, <span class="keyword">int</span>(s.size())))</span></span>; <span class="comment">// 防止s的长度小于行数</span></span><br><span class="line">		<span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">bool</span> goingDown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">			rows[curRow] += c;</span><br><span class="line">			<span class="keyword">if</span> (curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>) &#123;<span class="comment">// 当前行curRow为0或numRows -1时，箭头发生反向转</span></span><br><span class="line">				goingDown = !goingDown;</span><br><span class="line">			&#125;</span><br><span class="line">			curRow += goingDown ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">string</span> ret;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">string</span> row : rows) &#123;<span class="comment">// 从上到下遍历行</span></span><br><span class="line">			ret += row;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h4><blockquote>
<p> 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">123</span></span><br><span class="line">输出: <span class="number">321</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">-123</span></span><br><span class="line">输出: <span class="number">-321</span></span><br></pre></td></tr></table></figure>

<p>==注意:==</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>思路：</p>
<p>这道题最重要的是判断是否溢出， 用一个更大的来存， 或者直接判断（笨方法）。</p>
<p>请你记住下面这两个的求法！！！</p>
<p>MAX_INT = (unsigned)(-1)&gt;&gt;1;<br>MIN_INT = ~MAX_INT;</p>
<p>或者</p>
<p>MIN_INT = 1 &lt;&lt; 31;</p>
<p>MAX_INT = ~MAX_INT;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首次找到最大的int值</span></span><br><span class="line">        <span class="keyword">int</span> MAX_INT, MIN_INT;</span><br><span class="line">        MAX_INT = (<span class="keyword">unsigned</span>)(<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        MIN_INT = ~MAX_INT;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; MAX_INT ||  ans &lt; MIN_INT) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8.字符串转换整数 (atoi)"></a>8.字符串转换整数 (atoi)</h4><blockquote>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
</blockquote>
<ul>
<li><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
</li>
<li><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
</li>
<li><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
</li>
<li><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
</li>
<li><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
</li>
</ul>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 −  1]。如果数值超过这个范围，请返回  INT_MAX (2^31 −  1) 或 INT_MIN (−2^31) 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;42&quot;</span></span><br><span class="line">输出: <span class="number">42</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;   -42&quot;</span></span><br><span class="line">输出: <span class="number">-42</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;4193 with words&quot;</span></span><br><span class="line">输出: <span class="number">4193</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;words and 987&quot;</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;-91283472332&quot;</span></span><br><span class="line">输出: <span class="number">-2147483648</span></span><br></pre></td></tr></table></figure>

<p>解题思路： 直接暴力， 暴力求解！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (1&lt;&lt;31)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX ~INT_MIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> firstnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>  len = str.length();</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;       </span><br><span class="line">             <span class="keyword">if</span>(!firstnum)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(str[i] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(str[i]) &amp;&amp; !(str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">                     <span class="keyword">return</span> <span class="number">0</span>;               </span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;+&#x27;</span>)&#123;                  </span><br><span class="line">                    f = str[i] == <span class="string">&#x27;-&#x27;</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                 &#125;<span class="keyword">else</span> ans = ans * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);             </span><br><span class="line">                firstnum = <span class="number">1</span>;           </span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(str[i]))&#123;</span><br><span class="line">                ans = ans * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(f &amp;&amp; (ans &gt; INT_MAX )) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ans &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> f ? ~(<span class="keyword">int</span>)ans + <span class="number">1</span>:(<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h4><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">121</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">-121</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>你能不将整数转为字符串来解决这个问题吗？</p>
<p>我就直接用字符串处理解决这道题了，还可以用数字反转处理！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; x;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        ss &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; temp.length() / <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(temp[i] != temp[temp.length() - i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a>10.正则表达式匹配</h4><blockquote>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
</blockquote>
<blockquote>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
</blockquote>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">p = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: <span class="string">&quot;a&quot;</span> 无法匹配 <span class="string">&quot;aa&quot;</span> 整个字符串。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">p = <span class="string">&quot;a*&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">&#x27;a&#x27;</span>。</span><br><span class="line">     因此，字符串 <span class="string">&quot;aa&quot;</span> 可被视为 <span class="string">&#x27;a&#x27;</span> 重复了一次。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;ab&quot;</span></span><br><span class="line">p = <span class="string">&quot;.*&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: <span class="string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="string">&#x27;*&#x27;</span>）任意字符（<span class="string">&#x27;.&#x27;</span>）。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;aab&quot;</span></span><br><span class="line">p = <span class="string">&quot;c*a*b&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">&#x27;*&#x27;</span> 表示零个或多个，这里 <span class="string">&#x27;c&#x27;</span> 为 <span class="number">0</span> 个, <span class="string">&#x27;a&#x27;</span> 被重复一次。因此可以匹配字符串 <span class="string">&quot;aab&quot;</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;mississippi&quot;</span></span><br><span class="line">p = <span class="string">&quot;mis*is*p*.&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<p>这道题利用的是递归的思想， 我是一步一步增加考虑的情况，</p>
<p>我下面的代码其实可以合并， 合并后可以更加简洁，跟题解是一样的，但我认为初次做这道题， 一下子合并代码的话不容易理解！！</p>
<p>具体的思路都在注释里面！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这是消除相同的闭包， 不然会超时， 比如a*a*a*a*a*其实一个a*和很多个是没有区别的！！</span></span><br><span class="line">       <span class="comment">// 但是处理的情况却多了很多， 比如第一个a* 会考虑 直接匹配a 也可以不匹配a让后面的匹配，</span></span><br><span class="line">        <span class="comment">// 每一个a* 都是这样考虑这就是一个指数函数了！！！</span></span><br><span class="line">        <span class="keyword">if</span>(p.length() &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[i+<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; i + <span class="number">3</span> &lt;  p.length() </span><br><span class="line">                &amp;&amp; p[i+<span class="number">3</span>] ==<span class="string">&#x27;*&#x27;</span> &amp;&amp; p[i] == p[i+<span class="number">2</span>])&#123;</span><br><span class="line">                    p = p.substr(<span class="number">0</span>, i) + p.substr(i + <span class="number">2</span>, p.length() - i - <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s :  &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;   &quot;</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; P : &quot;</span> &lt;&lt; p &lt;&lt;<span class="built_in">endl</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果pattern 空了， 但是s还没有空的话肯定错了</span></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="string">&quot;&quot;</span>)   <span class="keyword">return</span> s == <span class="string">&quot;&quot;</span> ? <span class="literal">true</span> : <span class="literal">false</span>;  </span><br><span class="line">        <span class="comment">// 如果字符空了， 但是p还没空， 那就删除一个闭包，因为闭包可以为空，</span></span><br><span class="line">        <span class="comment">// 比如 s == “” p == “a*” 这个是可以匹配的！</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> p.length() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> ?  </span><br><span class="line">            isMatch(s,p.substr(<span class="number">2</span>,p.length() - <span class="number">2</span>)) : <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//第一种情况， 一个 . 的情况</span></span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; (p.length() &gt;=<span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span> || p.length() == <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substr(<span class="number">1</span>,s.length() - <span class="number">1</span>),p.substr(<span class="number">1</span>,p.length() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二种  .* 的情况， 返回有两种情况 1、闭包为空， 2、闭包不为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; p.length() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  isMatch(s,p.substr(<span class="number">2</span>,p.length() - <span class="number">2</span>)) || isMatch(s.substr(<span class="number">1</span>,s.length() - <span class="number">1</span>),p) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第三种情况 字符相同但不是闭包的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">0</span>] == s[<span class="number">0</span>] &amp;&amp; (p.length() &gt;=<span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span> || p.length() == <span class="number">1</span>) )&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substr(<span class="number">1</span>,s.length() - <span class="number">1</span>), p.substr(<span class="number">1</span>,p.length() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第四种情况 字符相同且是闭包的情况</span></span><br><span class="line">        <span class="comment">// 返回也有两种： 1、 闭包为空 2、 闭包吃掉一个字符</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">0</span>] == s[<span class="number">0</span>] &amp;&amp; (p.length() &gt;=<span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substr(<span class="number">2</span>,p.length() - <span class="number">2</span>)) ||isMatch(s.substr(<span class="number">1</span>,s.length() - <span class="number">1</span>),p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个情况， 字符不相同， 但是p有闭包， 闭包可以为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">0</span>] != s[<span class="number">0</span>] &amp;&amp; p.length() &gt;=<span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substr(<span class="number">2</span>,p.length() - <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其它情况的话就是匹配不了的了，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h4><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x hyj轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" style="zoom:80%;" />

<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">49</span></span><br></pre></td></tr></table></figure>

<p>首先思路简单：直接暴力可以通过！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span> ; i &lt; len; i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (i - j) * min(height[i],height[j]);</span><br><span class="line">                ans = temp &gt; ans ? temp : ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当这道题肯定没有这么简单就过了， 暴力应该不是出题人的本意！</p>
<p>leetco的题解上抄的！ Terry su</p>
<p>简单反证法证明：通过双指针方法，两个指针一定会同时经过最大面积对应的指针位置。</p>
<p>假设mn是最大的面积</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">                  |                     </span><br><span class="line">           |      |                     </span><br><span class="line">           |      |                     </span><br><span class="line">     ......|......|......               </span><br><span class="line">——————————————————————————————————————— </span><br><span class="line">           m      n</span><br></pre></td></tr></table></figure>

<p>假设有条边p更高在外面，</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">        |                                </span><br><span class="line">        |          |                     </span><br><span class="line">        |   |      |                     </span><br><span class="line">        |   |      |                     </span><br><span class="line">     ...|...|......|......               </span><br><span class="line">——————————————————————————————————————— </span><br><span class="line">        p   m      n</span><br></pre></td></tr></table></figure>

<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">AreaMN = ( <span class="name">n</span> - m ) * min( <span class="name">arr</span>[ m ], arr[ n ] )</span><br><span class="line">AreaPN = ( <span class="name">n</span> - p ) * min( <span class="name">arr</span>[ p ], arr[ n ] )</span><br></pre></td></tr></table></figure>

<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(  <span class="name">n</span> - m ) &lt;= ( <span class="name">n</span> - p )</span><br><span class="line"> min( <span class="name">arr</span>[ m ], arr[ n ] ) &lt;= min( <span class="name">arr</span>[ p ], arr[ n ] )</span><br></pre></td></tr></table></figure>

<p>所以： <code>AreaMN &lt; AreaPN</code>, 与m和n构成最大面积相矛盾，所以假设不成立，即m左侧的点都不高于n，即等于或矮于n。同理可证，n右侧指针等于或矮于m。所以通过双指针方法，两个指针一定会同时经过最大面积对应的指针位置。</p>
<p>原理明白了， 代码自然简单！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b? b : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (r - l) * min(height[l],height[r]);</span><br><span class="line">            max = max &lt; temp? temp : max;</span><br><span class="line">            <span class="keyword">if</span>(height[l] &lt; height[r]) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a>12.整数转罗马数字</h4><blockquote>
<p> 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></table></figure>


<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><br><span class="line">X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><br><span class="line">C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="string">&quot;III&quot;</span></span><br></pre></td></tr></table></figure>

<p>这道是我做过简答的， 相当于找钱，每次找最大面额的钱！</p>
<p>我应该是做过类似的题， 不然我不会一看到代码就直接会思路了， 这应该就是刷题的好处了！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">        m[<span class="number">1000</span>] = <span class="string">&quot;M&quot;</span>;</span><br><span class="line">        m[<span class="number">900</span>] = <span class="string">&quot;CM&quot;</span>;</span><br><span class="line">        m[<span class="number">500</span>] = <span class="string">&quot;D&quot;</span>;</span><br><span class="line">        m[<span class="number">400</span>] = <span class="string">&quot;CD&quot;</span>;</span><br><span class="line">        m[<span class="number">100</span>] = <span class="string">&quot;C&quot;</span>;</span><br><span class="line">        m[<span class="number">90</span>] = <span class="string">&quot;XC&quot;</span>;</span><br><span class="line">        m[<span class="number">50</span>] = <span class="string">&quot;L&quot;</span>;</span><br><span class="line">        m[<span class="number">40</span>] = <span class="string">&quot;XL&quot;</span>;</span><br><span class="line">        m[<span class="number">10</span>] = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">        m[<span class="number">9</span>] = <span class="string">&quot;IX&quot;</span>;</span><br><span class="line">        m[<span class="number">5</span>] = <span class="string">&quot;V&quot;</span>;</span><br><span class="line">        m[<span class="number">4</span>] = <span class="string">&quot;IV&quot;</span>;</span><br><span class="line">        m[<span class="number">1</span>] =  <span class="string">&quot;I&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> range[] = &#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span> ; i++)</span><br><span class="line">            <span class="keyword">while</span>(num &gt;= range[i]) ans += m[range[i]], num-=range[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h4><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;III&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>解题思路： 12 题反过来， 顺序遍历字符串， 全部加起来， 如果前面的比后面的小要双倍减去，一看代码就明白了！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        m[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        m[<span class="string">&#x27;V&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">        m[<span class="string">&#x27;X&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">        m[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">        m[<span class="string">&#x27;C&#x27;</span>] = <span class="number">100</span>;</span><br><span class="line">        m[<span class="string">&#x27;D&#x27;</span>] = <span class="number">500</span>;</span><br><span class="line">        m[<span class="string">&#x27;M&#x27;</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!i)&#123;</span><br><span class="line">                ans += m[s[i]];<span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m[s[i]] &gt; m[s[i - <span class="number">1</span>]])&#123;</span><br><span class="line">                ans -= <span class="number">2</span> * m[s[i - <span class="number">1</span>]]; <span class="comment">// 加倍奉还</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans+= m[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="14-最长公共子串"><a href="#14-最长公共子串" class="headerlink" title="14.最长公共子串"></a>14.最长公共子串</h4><blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
</blockquote>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>暴力，^_~</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>)  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">char</span> com;</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strs.size(); i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> temp = strs[i];</span><br><span class="line">                <span class="keyword">if</span>(temp.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span>(!i) com = temp[index];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(com  !=  temp[index])</span><br><span class="line">                    <span class="keyword">return</span> ans;               </span><br><span class="line">                <span class="keyword">if</span>(index == temp.length() - <span class="number">1</span>) flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="built_in">endl</span>;     </span><br><span class="line">            ans += com;     </span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> ans;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;              </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h4><blockquote>
<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
</blockquote>
<p>注意：答案中不可以包含重复的三元组。</p>
<p> 解题思路：</p>
<p>首先这题可以变成一个两数之和题目， 然后一个for循环找nums 里的一个数等于这个两数之和；</p>
<p>所以这道题首先要会两数之和的做法：</p>
<blockquote>
<p>两数之和等于0(特例=0)</p>
</blockquote>
<p>先将数组排序， 然后利用双指针一个在左边， 一个在右边， 如果指针对应的两个数的和大于0， 则右边指针减1，小于则左边加， 直到相遇， 如果相遇了还没有找到答案就没有解， 这个算法容易，但是怎么证明？</p>
<p>想了很久很久。。。。。。</p>
<p>证明：</p>
<p>首先这个算法有三种情况</p>
<ul>
<li><p>和等于0</p>
<p> 随机一个指针往里面移动，比如（-2  -1 1 2）  现在有两个答案， 找到等于0的 -2 2 后， 假设2左移到1，之后 -2 + 1 &lt; 0, 因此左边 右移， -1 + 1 这个答案也找到了！！</p>
</li>
<li><p>和小于0， 左指针右移</p>
</li>
<li><p>和大于0， 右指针左移</p>
</li>
</ul>
<p>现在考虑后面这两种情况， 只有两种选择， 因此这两个指针一定会移到答案（如果有）的其中一个因子上！</p>
<p>上面这句话其实好理解， 因为如果有答案， 算法的停止条件是left  &lt; right, 已经遍历了所有的项了！</p>
<p>再举个例子：  两数之和等于 16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-8 -6 5 7 11 17 22（答案可以看出 5  11）</span><br></pre></td></tr></table></figure>

<p>现在再来考虑两种情况：</p>
<p>1、假设 右指针 <strong>先</strong> 移到  11（刚好这道题是），</p>
<p>那么此时无论左边指针移到哪里， 反正就是小于5， 那么条件为真的只有左指针右移，直到找到答案！</p>
<p>2、 假设 左指针 <strong>先</strong> 移到  5</p>
<p>那么此时无论右指针在哪里， 反正就是大于11，条件为真的只有右指针左移，直至找到答案或相遇！</p>
<p>3、一次只移动左指针或右指针， 不会同时移到答案的两个， 也就是 5  和 11！！</p>
<p>综上上面四点（包括一定会一个先移到答案）， 可以证明， 如果有答案一定可以找到这个答案！！</p>
<p>三数之和就好解了！！！看注释就会了！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>]，</span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> le, ri,sum;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            le = i + <span class="number">1</span>;<span class="comment">//不重头开始是为了 去重1</span></span><br><span class="line">            ri = len - <span class="number">1</span>;      </span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">//这个也是 去重1， 具体自己想</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 第三项 作为 两数之和的相反数 相同， 去重2</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(le &lt; ri)&#123;</span><br><span class="line">                sum = nums[i] + nums[le] + nums[ri];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;nums[le],nums[i],nums[ri]&#125;;</span><br><span class="line">                    ans.push_back(a);   </span><br><span class="line">                    <span class="comment">//下面两个 去重2！！！</span></span><br><span class="line">                    <span class="keyword">while</span>(le &lt; ri  &amp;&amp; nums[le] == nums[le + <span class="number">1</span>]) le++;</span><br><span class="line">                    <span class="keyword">while</span>(le &lt; ri  &amp;&amp; nums[ri] == nums[ri - <span class="number">1</span>]) ri--;     </span><br><span class="line">                &#125;                       </span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) ri--;</span><br><span class="line">                <span class="keyword">else</span> le++; <span class="comment">// 这个包含相同时的移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去重1    a + b + c = 0  如果不去重， a作为 i 得到一个答案， b作为i得到一个答案, c作为i得到一个答案</span></span><br><span class="line"><span class="comment">//去重2    数组中含有相同的数子     a1 + b + c = 0    a2 + b + c = 0</span></span><br></pre></td></tr></table></figure>

<p><img src="images/image-20200114220202937.png" alt="image-20200114220202937"></p>
<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16.最接近的三数之和"></a>16.最接近的三数之和</h4><blockquote>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">-1</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">-4</span>], 和 target = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 <span class="number">2.</span> (<span class="number">-1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>
<p>思路就是和三数之和一样不同的是多一个判断！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> le, ri;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            le = i + <span class="number">1</span>;</span><br><span class="line">            ri = len - <span class="number">1</span>;    </span><br><span class="line">            <span class="keyword">while</span>(le &lt; ri)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[le] + nums[ri] ;   </span><br><span class="line">                <span class="comment">//while(le &lt; ri &amp;&amp; nums[le] == nums[le+1]) le++;</span></span><br><span class="line">                <span class="comment">//while(le &lt; ri &amp;&amp; nums[ri] == nums[ri-1]) ri--;       </span></span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; &quot; sum: &quot; &lt;&lt; sum &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;    </span></span><br><span class="line">                <span class="keyword">if</span>(sum ==  target) <span class="keyword">return</span> target; <span class="comment">//已经最进了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    le++;</span><br><span class="line">                    <span class="keyword">if</span>(num &gt;=  target - sum)&#123;</span><br><span class="line">                        num = target -sum;</span><br><span class="line">                        ans = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ri--;</span><br><span class="line">                    <span class="keyword">if</span>(num &gt;= sum - target)&#123;</span><br><span class="line">                        num = sum - target;</span><br><span class="line">                        ans = sum;</span><br><span class="line">                    &#125;                 </span><br><span class="line">                &#125;                 </span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; &quot; i: &quot; &lt;&lt; i &lt;&lt; &quot; *&quot; &lt;&lt; endl;</span></span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h4><blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
</blockquote>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200115170558.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;23&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;ad&quot;</span>, <span class="string">&quot;ae&quot;</span>, <span class="string">&quot;af&quot;</span>, <span class="string">&quot;bd&quot;</span>, <span class="string">&quot;be&quot;</span>, <span class="string">&quot;bf&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;ce&quot;</span>, <span class="string">&quot;cf&quot;</span>].</span><br><span class="line">说明:</span><br><span class="line">尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</span><br></pre></td></tr></table></figure>

<p>我用的是广搜！这道搞人的地方是 :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;cao&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2 = str[<span class="number">0</span>] + <span class="string">&quot;&quot;</span>; <span class="comment">//不行</span></span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;b&#x27;</span>; <span class="comment">//不行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; m;  </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution()&#123;</span><br><span class="line">        m[<span class="string">&#x27;2&#x27;</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;3&#x27;</span>] = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;4&#x27;</span>] = <span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;5&#x27;</span>] = <span class="string">&quot;jkl&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;6&#x27;</span>] = <span class="string">&quot;mno&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;7&#x27;</span>] = <span class="string">&quot;pqrs&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;8&#x27;</span>] = <span class="string">&quot;tuv&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;9&#x27;</span>] = <span class="string">&quot;wxyz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;     </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans, next;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">string</span> str = m[digits[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">if</span>(digits.length() &gt; <span class="number">1</span>)</span><br><span class="line">            next = letterCombinations(digits.substr(<span class="number">1</span>, digits.length() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits.length() &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; next.size(); j ++)</span><br><span class="line">                    ans.push_back(str[i] + next[j]);     </span><br><span class="line">            <span class="keyword">else</span>    ans.push_back(str.substr(i,<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="18-做不出"><a href="#18-做不出" class="headerlink" title="18. 做不出"></a>18. 做不出</h4><h4 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h4><blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 n = <span class="number">2.</span></span><br><span class="line">当删除了倒数第二个节点后，链表变为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure>


<p>说明：</p>
<p>给定的 n 保证是有效的。</p>
<p>进阶：</p>
<p>你能尝试使用一趟扫描实现吗？使用hashmap</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* first= <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* second = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        first = second = head;</span><br><span class="line">        <span class="keyword">while</span>( first-&gt;next != <span class="literal">NULL</span> &amp;&amp;  n-- ) first = first-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(first-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            first = first-&gt;next, second = second-&gt;next;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h4><blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
</blockquote>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;()&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>思路：<br>使用一个栈来存就行了！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.size() == <span class="number">0</span> ||st.top() != <span class="string">&#x27;(&#x27;</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> st.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( s[i] == <span class="string">&#x27;]&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.size() == <span class="number">0</span> || st.top() != <span class="string">&#x27;[&#x27;</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> st.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( s[i] == <span class="string">&#x27;&#125;&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span>( st.size() == <span class="number">0</span> || st.top() != <span class="string">&#x27;&#123;&#x27;</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> st.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> st.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h4><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>思路没什么思路， 就是归并排序的最后一步！！！ 相当于又写了一遍归并排序！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* index = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        index = ans;</span><br><span class="line">		<span class="comment">//一步一步想！！！！</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="literal">NULL</span> ) index-&gt;next = l1, l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> ) index-&gt;next = l2, l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) index-&gt;next = l1, l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> index-&gt;next = l2, l2 = l2-&gt;next;</span><br><span class="line">            index = index-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简化后的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* index = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        index = ans;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="literal">NULL</span> ) index-&gt;next = l1, l1 = l1-&gt;next;</span><br><span class="line">            <span class="comment">//下面代码 l2 肯定不为空了， l1为空了 就直接跳过后面的了， 所以可以直接合并</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l1-&gt;val &gt;= l2-&gt;val ) index-&gt;next = l2, l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> index-&gt;next = l1, l1 = l1-&gt;next;</span><br><span class="line">            index = index-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="22-有效括号"><a href="#22-有效括号" class="headerlink" title="22.有效括号"></a>22.有效括号</h4><blockquote>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">例如，给出 n = <span class="number">3</span>，生成结果为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  <span class="string">&quot;((()))&quot;</span>,</span><br><span class="line">  <span class="string">&quot;(()())&quot;</span>,</span><br><span class="line">  <span class="string">&quot;(())()&quot;</span>,</span><br><span class="line">  <span class="string">&quot;()(())&quot;</span>,</span><br><span class="line">  <span class="string">&quot;()()()&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>思路： 一开始我想到的是广搜， 广搜虽好，但是会超内存， 因为要一个栈来存储答案， 于时就改成了深搜，深搜一定要剪枝！</p>
<p>广搜如果保留太多的信息会让内存超出限制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans = &#123;<span class="string">&quot;(&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span>  bfs(ans,<span class="number">1</span>,<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;  <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; m, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> len)</span></span>&#123;    </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans; </span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= len &amp;&amp; right == len) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp = m;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)&#123;          </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.size(); j++) temp[j] += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                temp = bfs(temp,left, right+<span class="number">1</span>,len);</span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.size(); i++) m[i] += <span class="string">&quot;(&quot;</span>;</span><br><span class="line">            ans =  bfs(m,left +<span class="number">1</span> , right,len);</span><br><span class="line">            <span class="keyword">if</span>(temp.size() != <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++)</span><br><span class="line">                    ans.push_back(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改一下不用临时变量， 还他么超了?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        bfs(ans,<span class="number">1</span>,<span class="number">0</span>,n,<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> len, <span class="built_in">string</span> cur)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= len &amp;&amp; right == len)&#123;</span><br><span class="line">            ans.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left != right)  </span><br><span class="line">                bfs(ans,left, right+<span class="number">1</span>, len,cur + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            bfs(ans,left+<span class="number">1</span>,right, len, cur + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再改！！</p>
<p>只有改dfs了, dfs的剪枝很重要</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        dfs(ans,n,<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="keyword">int</span> len, <span class="built_in">string</span> cur)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(!valid(len, cur)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(valid(len, cur) == <span class="number">1</span>)</span><br><span class="line">             ans.push_back(cur); </span><br><span class="line">        dfs(ans, len, cur+ <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        dfs(ans, len, cur+ <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> len, <span class="built_in">string</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        right = left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur[i] == <span class="string">&#x27;(&#x27;</span>) left++;</span><br><span class="line">            <span class="keyword">else</span> right++;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; len  || left &lt; right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == len &amp;&amp; right == len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23.合并K个排序链表"></a>23.合并K个排序链表</h4><blockquote>
<p> 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>解题思路， 每次将链表合并到一个总的链表上</p>
<p>时间复杂度分析：</p>
<p>前两个合并， 一共有n个节点，评分 n/k 个节点每条，</p>
<p>前两条合并为 n*2 / k ， 之后每次合并都要加上之前的</p>
<p>x + x + 2x + x + 3x  + x + 4x + x + ……..(k-1)x + x = kx + k^2 / 2 x = k^2 * x = k ^2 * (n*2/k) = kx</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!i) ans = lists[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                ListNode* index = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                head = index;</span><br><span class="line">                <span class="keyword">while</span>(lists[i] != <span class="literal">NULL</span> || ans!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(lists[i] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                            index-&gt;next = ans;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ans == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                            index-&gt;next = lists[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ans-&gt;val &gt;= lists[i]-&gt;val)&#123;</span><br><span class="line">                            index-&gt;next = lists[i];</span><br><span class="line">                            lists[i] = lists[i]-&gt;next;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            index-&gt;next = ans;</span><br><span class="line">                            ans = ans-&gt;next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        index = index-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = head-&gt;next;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="24-两两交换链表-todo"><a href="#24-两两交换链表-todo" class="headerlink" title="24.两两交换链表 todo"></a>24.两两交换链表 todo</h4><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例:</p>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> ListNode(<span class="number">0</span>),*tmp = res;</span><br><span class="line">        res-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next != <span class="literal">NULL</span> &amp;&amp; tmp-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode *start = tmp-&gt;next,*end = tmp-&gt;next-&gt;next;</span><br><span class="line">            tmp-&gt;next = end;</span><br><span class="line">            start-&gt;next = end-&gt;next;</span><br><span class="line">            end-&gt;next = start;</span><br><span class="line">            tmp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="25-k个一组翻转链表"><a href="#25-k个一组翻转链表" class="headerlink" title="25.k个一组翻转链表"></a>25.k个一组翻转链表</h4><blockquote>
<p> 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
</blockquote>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定这个链表：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">当 k = <span class="number">2</span> 时，应当返回: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">当 k = <span class="number">3</span> 时，应当返回: <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>说明 :</p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>思路： 其实就是暴力</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;   </span><br><span class="line">        ListNode * index = head;   </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(index == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> index = index-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(i == k <span class="number">-1</span> )  flag = <span class="number">1</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;       </span><br><span class="line">            <span class="keyword">while</span>(head != index)&#123;</span><br><span class="line">                next = head-&gt;next;</span><br><span class="line">                head-&gt;next = pre;</span><br><span class="line">                pre = head;</span><br><span class="line">                head = next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp-&gt;next = reverseKGroup(index,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pre = head;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="26-下一个排列"><a href="#26-下一个排列" class="headerlink" title="26. 下一个排列"></a>26. 下一个排列</h4><p>123的全排列为</p>
<p>123     132     213    231     312    321</p>
<p>123的下一排列为132， 321没有所以为123</p>
<p>直接思路：</p>
<p>从后面往前找，先找出最大的索引 k 满足 nums[k] &lt; nums[k+1]，如果不存在，就翻转整个数组；<br>从后面往前找，再找出另一个最大索引 l 满足 nums[l] &gt; nums[k]；一定有一个的<br>交换 nums[l] 和 nums[k]；<br>最后翻转 nums[k+1:]。</p>
<p>思路： 这道题主要理解排列的意思， 翻译过来就是上面的解法， </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!i) reverse(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//第一个前面大的</span></span><br><span class="line">            <span class="keyword">if</span>(i &amp;&amp; nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[j] &gt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                        nums[j] = nums[ i - <span class="number">1</span>];</span><br><span class="line">                        nums[i - <span class="number">1</span>] = temp;</span><br><span class="line">                        reverse(nums,i,nums.size() - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= (end + start) / <span class="number">2</span>; i++)&#123;</span><br><span class="line">           temp = nums[i];</span><br><span class="line">           nums[i] = nums[end - i + start];</span><br><span class="line">           nums[end - i + start]  = temp;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="27-最长有效括号"><a href="#27-最长有效括号" class="headerlink" title="27. 最长有效括号"></a>27. 最长有效括号</h4><blockquote>
<p> 给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>从左边向右遍历， 如果当前的左括号小于右括号证明是没有用的，从新开始计数， 如果当前的左括号等于右括号是一个有效值，判断是否为最大值， 右边一样！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ri, le, ans;</span><br><span class="line">        ri = le = ans = <span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) le++;</span><br><span class="line">            <span class="keyword">else</span> ri++;</span><br><span class="line">            <span class="keyword">if</span>(le == ri) ans = ans &gt; le * <span class="number">2</span> ? ans : le * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(le &lt; ri) le = ri = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ri = le = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) le++;</span><br><span class="line">            <span class="keyword">else</span> ri++;</span><br><span class="line">            <span class="keyword">if</span>(le == ri) ans = ans &gt; le * <span class="number">2</span> ? ans : le * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(le &gt; ri) le = ri = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="28-搜索旋转排序数组"><a href="#28-搜索旋转排序数组" class="headerlink" title="28. 搜索旋转排序数组"></a>28. 搜索旋转排序数组</h4><blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
</blockquote>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>这题主要理解的问题是，一个旋转之后的数组，拆成两半， 总有一个半是有效的！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> devideSearch(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">devideSearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> le, <span class="keyword">int</span> ri , <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ri == le) <span class="keyword">return</span> nums[ri] == target? ri : <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// if(ri - le == 1)&#123;</span></span><br><span class="line">        <span class="comment">//     if(nums[ri] == target) return  ri;</span></span><br><span class="line">        <span class="comment">//     else if( nums[le] == target) return le;</span></span><br><span class="line">        <span class="comment">//     return -1;</span></span><br><span class="line">        <span class="comment">// &#125;        </span></span><br><span class="line">        <span class="keyword">int</span> mid = (le + ri) / <span class="number">2</span>;</span><br><span class="line">       <span class="comment">// cout &lt;&lt; le &lt;&lt; &quot; &quot; &lt;&lt; ri &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// 左边有序</span></span><br><span class="line">        <span class="keyword">if</span>(nums[le] &lt; nums[mid] )&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[le] &lt;= target &amp;&amp; nums[mid] &gt;= target)</span><br><span class="line">                <span class="keyword">return</span> devideSearch(nums, le, mid,target);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> devideSearch(nums, mid + <span class="number">1</span>, ri,target);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid + <span class="number">1</span>] &lt;= target &amp;&amp; nums[ri] &gt;= target)</span><br><span class="line">                <span class="keyword">return</span> devideSearch(nums,mid + <span class="number">1</span>, ri,target);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> devideSearch(nums, le, mid,target);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="29-在排序数组中查找元素的第一个和最后一个位置"><a href="#29-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="29. 在排序数组中查找元素的第一个和最后一个位置"></a>29. 在排序数组中查找元素的第一个和最后一个位置</h4><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出: [<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>解题思路：<br> 这道题关键还是二分搜索， 当搜索到答案以后， 往两边找相同的！！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) &#123;</span><br><span class="line">             <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> mid = search(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">if</span>(mid == <span class="number">-1</span> ) &#123;</span><br><span class="line">            ans.push_back(mid);</span><br><span class="line">            ans.push_back(mid);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i = mid; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] != target) <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(i = mid; i &lt; nums.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] != target) <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(i<span class="number">-1</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> le, <span class="keyword">int</span> ri, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>] || target &gt; nums[ri]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ri == le) <span class="keyword">return</span> target == nums[le] ? le : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (le + ri) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) <span class="keyword">return</span> search(nums,mid + <span class="number">1</span>, ri, target);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> search(nums,le, mid, target);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="30-组数之和"><a href="#30-组数之和" class="headerlink" title="30.组数之和"></a>30.组数之和</h4><blockquote>
<p> 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
</blockquote>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>解题思路： 我觉得这个回溯算法好简单呀！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        vint temp;</span><br><span class="line">        <span class="comment">//sort(candidates.begin(), candidates.end());  </span></span><br><span class="line">        search(candidates,ans, target, <span class="number">0</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(vint&amp; c,<span class="built_in">vector</span>&lt;vint&gt;&amp; ans, <span class="keyword">int</span> target, <span class="keyword">int</span> len, vint cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len == c.size()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = addup(cur);</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ans.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i] == cur) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(len &lt; c.size())&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt;len &lt;&lt; &quot; &quot; &lt;&lt;  sum&lt;&lt;endl;</span></span><br><span class="line">            search(c, ans, target, len+<span class="number">1</span>, cur);</span><br><span class="line">            cur.push_back(c[len]);       </span><br><span class="line">            search(c,ans, target, len, cur); <span class="comment">// 这里说可以重复</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addup</span><span class="params">(vint a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)&#123;</span><br><span class="line">                sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="31-旋转图形"><a href="#31-旋转图形" class="headerlink" title="31.旋转图形"></a>31.旋转图形</h4><blockquote>
<p>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。</p>
</blockquote>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>解题思路：先转置， 然后 在进行横排的移动。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> x = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> y = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )&#123;</span><br><span class="line">                temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; x/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j++)&#123;</span><br><span class="line">                temp = matrix[j][i];</span><br><span class="line">                matrix[j][i] = matrix[j][x - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][x - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="32-字母异位词分组"><a href="#32-字母异位词分组" class="headerlink" title="32. 字母异位词分组"></a>32. 字母异位词分组</h4><blockquote>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;tea&quot;</span>, <span class="string">&quot;tan&quot;</span>, <span class="string">&quot;ate&quot;</span>, <span class="string">&quot;nat&quot;</span>, <span class="string">&quot;bat&quot;</span>],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">&quot;ate&quot;</span>,<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;tea&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;nat&quot;</span>,<span class="string">&quot;tan&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;bat&quot;</span>]</span><br><span class="line">]</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有输入均为小写字母。</span><br><span class="line">不考虑答案输出的顺序。</span><br></pre></td></tr></table></figure>

<p>解题思路： 可以说是暴力求解了， 把每一个单词都排序，排好序之后， map 一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; vvstr;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; str2vstr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        vvstr ans;</span><br><span class="line">        str2vstr str2vstr; for_ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strs.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> temp = strs[i];</span><br><span class="line">            sort(strs[i].begin(), strs[i].end());</span><br><span class="line">            for_ans[strs[i]].push_back(temp);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span>(str2vstr::iterator i = for_ans.begin(); i != for_ans.end(); i++)&#123;</span><br><span class="line">            ans.push_back(i-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="33-最大连续子数组"><a href="#33-最大连续子数组" class="headerlink" title="33.最大连续子数组"></a>33.最大连续子数组</h4><blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>],</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure>


<p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<p>解题思路： 使用dp的思想， 如果当前的连续和还是大于 0 的， 可以加到后面， 如果当前的连续和小于0了， 加到后面后面反而减小了， 所以不需要加到后面了！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans, cur;</span><br><span class="line">        cur =  <span class="number">0</span>;</span><br><span class="line">        ans = (<span class="keyword">unsigned</span>)(<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ans = ~ans;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size(); i ++ )&#123;</span><br><span class="line">             cur += nums[i];</span><br><span class="line">             ans = cur &gt; ans ? cur : ans;</span><br><span class="line">             <span class="keyword">if</span>( cur &lt; <span class="number">0</span>)</span><br><span class="line">                cur = <span class="number">0</span>;           </span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>分治法：暂无</p>
<h4 id="34-最大连续和"><a href="#34-最大连续和" class="headerlink" title="34. 最大连续和"></a>34. 最大连续和</h4><blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">解释: 我们可以先跳 <span class="number">1</span> 步，从位置 <span class="number">0</span> 到达 位置 <span class="number">1</span>, 然后再从位置 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个位置。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解题思路： 直接暴力就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == nums.size() - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            arr = i + nums[i] &gt; arr ? i + nums[i] : arr;</span><br><span class="line">            <span class="keyword">if</span>(arr &lt;= i ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="35-合并区间"><a href="#35-合并区间" class="headerlink" title="35. 合并区间"></a>35. 合并区间</h4><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>

<p>解题思路： 一开始想到的想到的是给 vector 的开始排序， 然后遍历一遍就可以知道结束的地方</p>
<p>后来发现， 这个是可以分开的， start 和 end 分开来也行！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vvint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = intervals.size();</span><br><span class="line">        vvint ans;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> start[len], end[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            start[i] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            end[i] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(start, start + len);</span><br><span class="line">        sort(end, end+ len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == len<span class="number">-1</span> || start[i + <span class="number">1</span>] &gt; end[i])&#123;<span class="comment">//最后一个直接放</span></span><br><span class="line">                vint tmp;</span><br><span class="line">                tmp.push_back(start[j]);</span><br><span class="line">                tmp.push_back(end[i]);</span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="34-不同路径"><a href="#34-不同路径" class="headerlink" title="34. 不同路径"></a>34. 不同路径</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200210100443.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">例如，上图是一个<span class="number">7</span> x <span class="number">3</span> 的网格。有多少可能的路径？</span><br><span class="line"></span><br><span class="line">说明：m 和 n 的值均不超过 <span class="number">100</span>。</span><br></pre></td></tr></table></figure>

<p>递归求解： 换来的是超时。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        search(ans,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> &amp;ans, <span class="keyword">int</span> curm, <span class="keyword">int</span> curn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curm &gt; m || curn &gt; n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(curn == n &amp;&amp; curm == m)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curm &lt; m) search(ans,curm + <span class="number">1</span>,curn);</span><br><span class="line">        <span class="keyword">if</span>(curn &lt; n) search(ans,curm, curn + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>换用dp：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[m][n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>)    dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)  dp[i][j]= dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>) dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="35-不同路径Ⅱ"><a href="#35-不同路径Ⅱ" class="headerlink" title="35. 不同路径Ⅱ"></a>35. 不同路径Ⅱ</h4><p>题目一样，但是加上一个障碍物的存在， 思路一样的， 这个测试样例坑人的， 返回型是int的， 但是中间值是超过int的， 坑！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.size();</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> dp[m][n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>)    dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)  dp[i][j]= dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>) dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">               <span class="keyword">if</span>(i &gt; <span class="number">8</span> &amp;&amp; j &gt; <span class="number">8</span>) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; dp[i][j] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="36-最小路径和"><a href="#36-最小路径和" class="headerlink" title="36.最小路径和"></a>36.最小路径和</h4><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p>解题思路： 这题也是dp 挺简单的， 值得注意的是  vvint 的速度执行 会 比  int 快！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = grid.size();</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function">vvint <span class="title">dp</span><span class="params">(y,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(x))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i ==<span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[i][j] = grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) dp[i][j] = min(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]) + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> ) dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span>  dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[y<span class="number">-1</span>][x<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="37-验证给定的字符串是否可以解释为十进制数字。"><a href="#37-验证给定的字符串是否可以解释为十进制数字。" class="headerlink" title="37.验证给定的字符串是否可以解释为十进制数字。"></a>37.验证给定的字符串是否可以解释为十进制数字。</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;0&quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot; 0.1 &quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;1 a&quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;2e10&quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot; -90e3   &quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot; 1e&quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;e3&quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot; 6e-1&quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot; 99e2.5 &quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;53.5e93&quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot; --6 &quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;-+3&quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;95a54e53&quot;</span> =&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>编译原理的自动机！！！ 状态难画！ </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">9</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">8</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">8</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">7</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">6</span>&#125;,&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">7</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">7</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> state=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            i+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j=s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[j]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            j-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>) state=a[state][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;e&#x27;</span>) state=a[state][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>) state=a[state][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>||s[i]==<span class="string">&#x27;-&#x27;</span>) state=a[state][<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(state==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(state==<span class="number">7</span>||state==<span class="number">1</span>||state==<span class="number">5</span>||state==<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="38-爬楼梯"><a href="#38-爬楼梯" class="headerlink" title="38. 爬楼梯"></a>38. 爬楼梯</h4><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方可以爬到楼顶呢？</p>
</blockquote>
<p>注意：给定 n 是一个正整数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1.  1 阶 + 1 阶  2 阶</span><br></pre></td></tr></table></figure>

<p>解题思路： 简单的dp问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> a[n];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>; a[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            a[i] = a[i<span class="number">-1</span>] + a[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="39-单词最短距离"><a href="#39-单词最短距离" class="headerlink" title="39. 单词最短距离"></a>39. 单词最短距离</h4><blockquote>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
</blockquote>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: word1 = <span class="string">&quot;horse&quot;</span>, word2 = <span class="string">&quot;ros&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>解题思路： 刚拿到这道题时完全没有思路可言， 我是看了题解才知道怎么做的！</p>
<p>还是dp， 又是dp！</p>
<p>dp [i] [j]: 表示  <code>word1</code> 到 <code>i</code> 位置转换成 <code>word2</code> 到 <code>j</code> 位置需要最少步数 </p>
<p>当 word1[i] == word2[j]，dp[i] [j] = dp[i-1] [j-1]；</p>
<p>当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1] [j-1], dp[i-1] [j], dp[i] [j-1]) + 1</p>
<p>其中，dp[i-1] [j-1] 表示替换操作，dp[i-1] [j] 表示删除操作，dp[i][j-1] 表示插入操作。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200214163734.png"></p>
<p>明白后还是挺简单的！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = word1.length();</span><br><span class="line">        <span class="keyword">int</span> y = word2.length();</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[x+<span class="number">1</span>][y+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= y; i++) dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i++) dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= y; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = min(min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]) , dp[i][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="40-颜色分类"><a href="#40-颜色分类" class="headerlink" title="40.颜色分类"></a>40.颜色分类</h4><blockquote>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
</blockquote>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p>解题思路： 三个指针， 分为三部分！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p0,cur,p2, len, tmp;</span><br><span class="line">        len = nums.size();</span><br><span class="line">        cur = p0 = <span class="number">0</span>;</span><br><span class="line">        p2 = len - <span class="number">1</span>;        </span><br><span class="line">        <span class="keyword">while</span>(cur &lt;= p2)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(nums[cur])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    cur++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    tmp = nums[cur];</span><br><span class="line">                    nums[cur++] = nums[p0];</span><br><span class="line">                    nums[p0++] = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    tmp = nums[p2];</span><br><span class="line">                    nums[p2--] = nums[cur];</span><br><span class="line">                    nums[cur] = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="42-单词搜索"><a href="#42-单词搜索" class="headerlink" title="42. 单词搜索"></a>42. 单词搜索</h4><blockquote>
<p> 给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
</blockquote>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">board &#x3D;</span><br><span class="line">[</span><br><span class="line">  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],</span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word &#x3D; &quot;ABCCED&quot;, 返回 true.</span><br><span class="line">给定 word &#x3D; &quot;SEE&quot;, 返回 true.</span><br><span class="line">给定 word &#x3D; &quot;ABCB&quot;, 返回 false.</span><br></pre></td></tr></table></figure>

<p>解题思路： 这道题最难的是， 回溯，   <strong>找过的路不能再找， 所以临时改变一下路径</strong>， 搜索完了后==重新恢复数据==，记得多看这道题， 经常出现！！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(backtrack(board, word, <span class="number">0</span>, i , j))&#123; <span class="comment">// 从二维表格的每一个格子出发</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word, <span class="keyword">int</span> wordIndex, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( board[x][y] != word[wordIndex])&#123; <span class="comment">// 当前位的字母不相等，此路不通</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(word.size() - <span class="number">1</span>  == wordIndex)&#123; <span class="comment">// 最后一个字母也相等, 返回成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> tmp = board[x][y]; </span><br><span class="line">        board[x][y] = <span class="number">0</span>; <span class="comment">// 避免该位重复使用</span></span><br><span class="line">        wordIndex++;</span><br><span class="line">        <span class="keyword">if</span>((x &gt; <span class="number">0</span> &amp;&amp; backtrack(board, word, wordIndex, x - <span class="number">1</span>, y)) <span class="comment">// 往左走</span></span><br><span class="line">        || (y &gt; <span class="number">0</span> &amp;&amp; backtrack(board, word, wordIndex, x, y - <span class="number">1</span>)) <span class="comment">// 往上走</span></span><br><span class="line">        || (x &lt; board.size() - <span class="number">1</span> &amp;&amp; backtrack(board, word, wordIndex, x + <span class="number">1</span>, y)) <span class="comment">// 往右走</span></span><br><span class="line">        || (y &lt; board[<span class="number">0</span>].size() - <span class="number">1</span> &amp;&amp; backtrack(board, word, wordIndex, x, y + <span class="number">1</span>)))&#123; <span class="comment">// 往下走</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">true</span>; <span class="comment">// 其中一条能走通，就算成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = tmp; <span class="comment">// 如果都不通，则回溯上一状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="43-pow-x-n"><a href="#43-pow-x-n" class="headerlink" title="43. pow(x, n)"></a>43. pow(<em>x</em>, <em>n</em>)</h4><blockquote>
<p>实现 pow(<em>x</em>, <em>n</em>) ，即计算 x 的 n 次幂函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>

<p>解题思路： </p>
<p>这道题我认为关键的地方是分治法， 把底层会重复计算的数据删除掉，不去计算！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = n &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> m = n;</span><br><span class="line">        m = m &lt; <span class="number">0</span> ? -m : m;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>) <span class="keyword">return</span> flag ? <span class="number">1</span>/x : x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> flag ? <span class="number">1</span> / (x * x) : x * x;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> temp = myPow(x, (flag ? - m/<span class="number">2</span>: m/<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">0</span>)&#123;             </span><br><span class="line">                <span class="keyword">return</span> temp * temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> temp * temp  * (flag ? <span class="number">1</span>/x : x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="44-八皇后问题"><a href="#44-八皇后问题" class="headerlink" title="44.八皇后问题"></a>44.八皇后问题</h4><blockquote>
<p> n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
</blockquote>
<p> <img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200223195130.png"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>解题思路： 回溯， 当此时是可以求解的， 把当前值置为1， 搜索完后恢复状态， 写了1.30 h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; vvstr;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvint;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="function">vvint <span class="title">m</span><span class="params">(n,vint(n))</span></span>;</span><br><span class="line">        vvstr ans;</span><br><span class="line">        search(<span class="number">0</span>, n,ans, m);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> line,<span class="keyword">int</span> n, vvstr&amp; ans, vvint&amp; m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(line == n)&#123;</span><br><span class="line">            <span class="built_in">string</span> temp;</span><br><span class="line">            vstr an;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(m[i][j] == <span class="number">0</span>) temp += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> temp += <span class="string">&quot;Q&quot;</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                an.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(an);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">// 对于这一行的每一个作为答案</span></span><br><span class="line">           <span class="comment">// cout &lt;&lt; line &lt;&lt; &quot; i: &quot; &lt;&lt; i  &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123; </span><br><span class="line">                <span class="keyword">if</span>(m[j][i] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 检查列</span></span><br><span class="line">                <span class="comment">// 斜</span></span><br><span class="line">                <span class="keyword">int</span> x1 = line - (i - j);</span><br><span class="line">                <span class="keyword">if</span>( x1 &gt;= <span class="number">0</span> &amp;&amp;  x1 &lt; n &amp;&amp;  m[x1][j] == <span class="number">1</span> ) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                x1 = line + (i - j);</span><br><span class="line">                <span class="keyword">if</span>(x1 &gt;= <span class="number">0</span> &amp;&amp; x1 &lt; n &amp;&amp; m[x1][j] == <span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">               <span class="comment">// cout &lt;&lt; &quot; &quot; &lt;&lt; j;        </span></span><br><span class="line">                <span class="keyword">if</span>(j == n - <span class="number">1</span>)&#123; <span class="comment">//列检查完毕</span></span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">                    m[line][i] = <span class="number">1</span>;</span><br><span class="line">                    search(line + <span class="number">1</span>, n, ans, m);</span><br><span class="line">                    m[line][i] = <span class="number">0</span>;</span><br><span class="line">                &#125;                  </span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//cout &lt;&lt; endl;       </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="44-二叉树的中序遍历"><a href="#44-二叉树的中序遍历" class="headerlink" title="44.  二叉树的中序遍历"></a>44.  二叉树的中序遍历</h4><p>给定一个二叉树，返回它的中序遍历。</p>
<p>示例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,null,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>解题思路： 递归太简单了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">            vint ans;</span><br><span class="line">            traverse(root,ans);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, vint&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            traverse(node-&gt;left, ans);</span><br><span class="line">            ans.push_back(node-&gt;val);</span><br><span class="line">            traverse(node-&gt;right, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归， 多看看！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//递归是使用了函数的栈， 迭代的话模拟出一个栈给它  </span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">          <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">while</span>(p || !st.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                st.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            ans.push_back(p-&gt;val);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="45-不同的二叉搜索树"><a href="#45-不同的二叉搜索树" class="headerlink" title="45.不同的二叉搜索树"></a>45.不同的二叉搜索树</h4><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<p><strong>示例:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释:</span><br><span class="line">给定 n = <span class="number">3</span>, 一共有 <span class="number">5</span> 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>      <span class="number">2</span></span><br><span class="line">    /     /       \                 \</span><br><span class="line">   <span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                 <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>这道题主要推导dp的递推式子！</p>
<p>问题是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p>
<ul>
<li><p>G(n): 长度为n的序列的不同二叉搜索树个数。</p>
</li>
<li><p>F(i,n): 以i为根的不同二叉搜索树个数(1 \leq i \leq n1≤i≤n)。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200301195813.png"></p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200301195932.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> g[n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        g[<span class="number">0</span>] = g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">                g[i] += g[j<span class="number">-1</span>] * g[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="46-验证二叉搜索树"><a href="#46-验证二叉搜索树" class="headerlink" title="46.验证二叉搜索树"></a>46.验证二叉搜索树</h4><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>思路不难： 递归处理， 中间的数据会超int， 带取值域搜索</p>
<p>或者  中序遍历， 带一个值搜索！！！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(TreeNode* current,<span class="keyword">long</span> left,<span class="keyword">long</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current-&gt;val&lt;=left||current-&gt;val&gt;=right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValid(current-&gt;left,left,current-&gt;val)</span><br><span class="line">            &amp;&amp;isValid(current-&gt;right,current-&gt;val,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValid(root,LONG_MIN,LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="47-对称二叉树"><a href="#47-对称二叉树" class="headerlink" title="47. 对称二叉树"></a>47. 对称二叉树</h4><blockquote>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
</blockquote>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>解题思路： </p>
<p>基于递归的解决方案！ 这个较为简单！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isValid(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(TreeNode* left, TreeNode* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">NULL</span> || right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt; val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValid(left-&gt;left, right-&gt;right) &amp;&amp; </span><br><span class="line">            isValid(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归的方法， 使用一个栈来模拟方法的递归过程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; le, ri;</span><br><span class="line">        le.push(root-&gt;left);</span><br><span class="line">        ri.push(root-&gt;right);</span><br><span class="line">        TreeNode * t1, * t2;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(le.empty() &amp;&amp; ri.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(le.empty() || ri.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            t1 = le.top(); t2 = ri.top();</span><br><span class="line">            le.pop(); ri.pop();</span><br><span class="line">            <span class="keyword">if</span>(t1 == <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(t1== <span class="literal">NULL</span> || t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            le.push(t1-&gt;right);ri.push(t2-&gt;left);</span><br><span class="line">            le.push(t1-&gt;left); ri.push(t2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="48-二叉树的层次遍历"><a href="#48-二叉树的层次遍历" class="headerlink" title="48. 二叉树的层次遍历"></a>48. 二叉树的层次遍历</h4><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>​    按照遍历的思想模拟</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vvint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vvint ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">set</span> = &#123;root&#125;;</span><br><span class="line">        solve(ans,<span class="built_in">set</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vvint &amp;ans, <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">set</span>)</span></span>&#123;</span><br><span class="line">        vint tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">set</span>.size(); i++)</span><br><span class="line">            tmp.push_back(<span class="built_in">set</span>[i]-&gt;val);</span><br><span class="line">        ans.push_back(tmp);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">set</span>.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>[i]-&gt;left) nodes.push_back(<span class="built_in">set</span>[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>[i]-&gt;right) nodes.push_back(<span class="built_in">set</span>[i]-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nodes.size() != <span class="number">0</span>) solve(ans, nodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="49-二叉树的最大深度"><a href="#49-二叉树的最大深度" class="headerlink" title="49. 二叉树的最大深度"></a>49. 二叉树的最大深度</h4><p>难度简单471收藏分享切换为英文关注反馈</p>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<p>解题思路： 练手题， 太简单了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        solve(ans,<span class="number">0</span>,root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> &amp;ans, <span class="keyword">int</span> cur, TreeNode* cu)</span></span>&#123;</span><br><span class="line">        ans = max(ans,cur);</span><br><span class="line">        <span class="keyword">if</span>(cu == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        solve(ans, cur + <span class="number">1</span>, cu-&gt;left);</span><br><span class="line">        solve(ans, cur + <span class="number">1</span>, cu-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="50-从前序与中序遍历序列构造二叉树"><a href="#50-从前序与中序遍历序列构造二叉树" class="headerlink" title="50. 从前序与中序遍历序列构造二叉树"></a>50. 从前序与中序遍历序列构造二叉树</h4><blockquote>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
</blockquote>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>解题思路： 按要求来！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> solve(preorder,inorder, <span class="number">0</span>,inorder.size(), <span class="number">0</span>,preorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode * <span class="title">solve</span><span class="params">(vint&amp; pre, vint&amp; ino, <span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> b1, <span class="keyword">int</span> b2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a1 &gt;= a2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> first = pre[a1];</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        TreeNode* root= <span class="keyword">new</span> TreeNode(first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = b1; i &lt; b2; i ++)</span><br><span class="line">            <span class="keyword">if</span>(ino[i] == first )&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; a1 &lt;&lt; &quot; &quot; &lt;&lt; a2  &lt;&lt; &quot; &quot; &lt;&lt; b1 &lt;&lt; &quot; &quot; &lt;&lt; b2 &lt;&lt; endl;</span></span><br><span class="line">        root-&gt;left = solve(pre,ino,a1 + <span class="number">1</span>, a1 + index - b1 + <span class="number">1</span>, b1, index);</span><br><span class="line">        root-&gt;right = solve(pre,ino,a1 + index - b1 + <span class="number">1</span>,a2, index + <span class="number">1</span>, b2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="51-只出现一次的数字"><a href="#51-只出现一次的数字" class="headerlink" title="51. 只出现一次的数字"></a>51. 只出现一次的数字</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>解题思路：真的没有想到这么巧， 使用位运算, 相同的异或了之后， 数据不变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">                num ^= nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="52-环形链表"><a href="#52-环形链表" class="headerlink" title="52. 环形链表"></a>52. 环形链表</h4><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p>快慢指针，快点指针会追上慢的指针！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fir = head;</span><br><span class="line">        ListNode* sec = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fir-&gt;next != <span class="literal">NULL</span>) fir = fir-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(sec-&gt;next != <span class="literal">NULL</span>) sec = sec-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(sec-&gt;next != <span class="literal">NULL</span>) sec = sec -&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fir == sec)&#123;<span class="comment">// 值有可能重复</span></span><br><span class="line">                <span class="keyword">if</span>(fir-&gt;next ==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="53-环形链表-II"><a href="#53-环形链表-II" class="headerlink" title="53. 环形链表 II"></a>53. 环形链表 II</h4><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p>解题思路： 我一开始想到的是让一个节点先走，然后面那个追相等的时候，判断有环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* fastPtr=head, *slowPtr=head;</span><br><span class="line">	<span class="comment">// 让fast与slow指针第一次相遇</span></span><br><span class="line">	<span class="keyword">while</span> (fastPtr!=<span class="literal">NULL</span> &amp;&amp; fastPtr-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		fastPtr = fastPtr-&gt;next-&gt;next;</span><br><span class="line">		slowPtr = slowPtr-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (fastPtr==slowPtr)&#123;</span><br><span class="line">			<span class="comment">// 从相遇点再走“非环部分长度”一定可以再次走到环起点</span></span><br><span class="line">			fastPtr = head;</span><br><span class="line">			<span class="keyword">while</span> (fastPtr != slowPtr)&#123;</span><br><span class="line">				fastPtr = fastPtr-&gt;next;</span><br><span class="line">				slowPtr = slowPtr-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fastPtr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="54-LRU缓存机制"><a href="#54-LRU缓存机制" class="headerlink" title="54. LRU缓存机制"></a>54. LRU缓存机制</h4><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:</p>
<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>模仿 redis 的设计思路，  索引用map， 然后移动使用 list， 找基于 map O（1）时间复杂度， 移动基于链表， 也是O（1）时间复杂度！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> key,val;</span><br><span class="line">        List* next, *pre;</span><br><span class="line">        List(<span class="keyword">int</span> key, <span class="keyword">int</span> v)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;val = v;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> capacity, max;</span><br><span class="line">    List *head, *tail;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, List*&gt; cap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;max = capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">        head = tail = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mv2head</span><span class="params">(List* tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp != head)&#123;                 <span class="comment">// 如果不是头结点, 头结点不用移动</span></span><br><span class="line">            List *p = tmp-&gt;pre;</span><br><span class="line">            <span class="keyword">if</span>(tmp == tail)&#123;</span><br><span class="line">                p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                tail = p;     </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = tmp-&gt;next;</span><br><span class="line">                tmp-&gt;next-&gt;pre = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//放到前面</span></span><br><span class="line">            tmp-&gt;next = head;</span><br><span class="line">            head-&gt;pre = tmp;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;capacity &gt; <span class="keyword">this</span>-&gt;max)&#123;</span><br><span class="line">            cap[tail-&gt;key] = <span class="literal">NULL</span>;  </span><br><span class="line">            capacity--;</span><br><span class="line">            tail = tail-&gt;pre;  <span class="comment">// 空的容器， 不考虑</span></span><br><span class="line">            <span class="keyword">delete</span> tail-&gt;next;</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        List* tmp = cap[key];</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;get key: &quot; &lt;&lt; key  &lt;&lt; &quot; &quot; &lt;&lt; tmp&lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        mv2head(tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        List* tmp = cap[key];</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="literal">NULL</span>)&#123;  <span class="comment">// 不存在键</span></span><br><span class="line">            List* newL = <span class="keyword">new</span> List(key,value);</span><br><span class="line">            cap[key] = newL;</span><br><span class="line">            <span class="keyword">this</span>-&gt;capacity++;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                tail = head = newL;</span><br><span class="line">                newL-&gt;pre = newL-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head-&gt;pre = newL;</span><br><span class="line">            newL-&gt;next = head;</span><br><span class="line">            head = newL;</span><br><span class="line">            rm();   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp-&gt;val = value;</span><br><span class="line">            mv2head(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



























]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
