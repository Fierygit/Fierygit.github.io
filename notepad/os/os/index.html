<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>操作系统学习笔记 - Firefly</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Firefly" /><meta name="description" content="操作系统复习指南 1.CPU 调度算法 了解CPU 调度算法，如先到先服务、最短作业优先、轮转、多级反馈队列等调度算法， 以及掌握多处理器调度的特殊性。 T~周" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.79.0 with theme even" />


<link rel="canonical" href="http://fireflying.top/notepad/os/os/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="操作系统学习笔记" />
<meta property="og:description" content="操作系统复习指南 1.CPU 调度算法 了解CPU 调度算法，如先到先服务、最短作业优先、轮转、多级反馈队列等调度算法， 以及掌握多处理器调度的特殊性。 T~周" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://fireflying.top/notepad/os/os/" />

<meta itemprop="name" content="操作系统学习笔记">
<meta itemprop="description" content="操作系统复习指南 1.CPU 调度算法 了解CPU 调度算法，如先到先服务、最短作业优先、轮转、多级反馈队列等调度算法， 以及掌握多处理器调度的特殊性。 T~周">

<meta itemprop="wordCount" content="8903">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="操作系统学习笔记"/>
<meta name="twitter:description" content="操作系统复习指南 1.CPU 调度算法 了解CPU 调度算法，如先到先服务、最短作业优先、轮转、多级反馈队列等调度算法， 以及掌握多处理器调度的特殊性。 T~周"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Firefly</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/notepad">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/notepad/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Firefly</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/notepad">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/notepad/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <div class="post-content">
    <h1 id="center操作系统复习指南center"><center>操作系统复习指南</center></h1>
<h2 id="1cpu-调度算法">1.CPU 调度算法</h2>
<blockquote>
<p>了解CPU 调度算法，如先到先服务、最短作业优先、轮转、多级反馈队列等调度算法，
以及掌握多处理器调度的特殊性。</p>
</blockquote>
<p>T~周转时间~  =  T~完成时间~  -  T ~到达时间~</p>
<p>FIFO：	 平均周转时间很大</p>
<p>SJF：	 	当一个长时间的任务先到达时，平均周转时间也会很大， 因为不能停止执行。</p>
<p>STCF： 	放宽假设条件， 进程可以上下切断， 周转时间很好。</p>
<p>T~响应时间~  =  T~首次运行~  -  T ~到达时间~</p>
<p>STCF 的响应时间不好 ， 引入RR。</p>
<p>RR：根据时间片切换进程，均摊上下文切换成本，RR响应时间好， 但周转时间不好， 陷入死循环。。。</p>
<p>于是引入MLFQ， 综合解决两个问题。</p>
<p>MLFQ：</p>
<ul>
<li>
<p>相同优先级的进程按RR调度</p>
</li>
<li>
<p>如果 优先级  A &gt; B ， 先运行A</p>
</li>
<li>
<p>初始工作时，放到最高优先级队列中</p>
</li>
<li>
<ul>
<li>工作用完优先级后，降低优先级</li>
<li>如果在工作在时间片内主动释放cpu， 优先级不变</li>
</ul>
</li>
<li>
<p>经过一段时间，重新把所有的的进程放到最高优先级</p>
</li>
</ul>
<p>进程可能恶意每次都在快运行完的时候主动释放cpu， 因此，更改第四条如下</p>
<ul>
<li>如果进程用完了，一个优先级上的时间片段， 则降低优先级，无论是否主动释放cpu</li>
</ul>
<p>确保每一个工作获得一定的比例的cpu时间， 而不是优化cpu的周转时间和响应时间， 引入比例份额调度。</p>
<p>彩票调度： 按彩票的数量多少来运行程序， 彩票多概率大运行多，当任务短的时候，有随机性， 引入步长调度</p>
<p>步长调度： 步伐短运行地多，无论怎样都是按比例，缺点是需要<strong>全局状态</strong>， 当一个新的进程加入时， 要更新全部进程的当前步长， 彩票调度只需要一个<strong>全局变量</strong>，总的彩票数。</p>
<p>多处理器调度： 处理缓存一致性问题， 硬件上，cpu监听总线更改缓存，软件上：</p>
<p>单队列调度（SQMS）： 简单，但是缓存不亲和</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200107152722.png" alt=""></p>
<p>多队列调度（MQMS）：天生缓存亲和， 但负载不均衡！（工作窃取）</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200107164327.png" alt=""></p>
<p>上图可以看出， A进程独占cpu， 工作窃取，就是定时查看其他cpu的工作负载。</p>
<h2 id="2进程和线程">2.进程和线程</h2>
<blockquote>
<p>掌握进程和线程的概念，熟练使用进程和线程相关编程接口，如fork，exec，wait，
pthread_create，pthread_join等。</p>
</blockquote>
<h3 id="进程api">进程API</h3>
<p>进程就是运行中的程序， 一个进程可以创建多个线程。</p>
<p>进程之间不共用内存， 线程之间可以共用内存， 但每一个线程都有自己的堆栈。</p>
<ul>
<li>fork()</li>
</ul>
<p>子进程改变全局变量不会改变父进程的值， 子进程有自己的程序运行空间， copy自父进程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#inclucde &lt;unistd.h&gt;
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello world(pid: %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="c1">// 创建失败
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error&#34;</span><span class="o">+</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span><span class="c1">// 子进程
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello, i am child (pid: %d)&#34;</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">//!!!!!!!! 注意父进程的 rc 值是 子进程的 pid
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello, i am parent of %d (pid: %d)&#34;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>waidpid（）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#inclucde &lt;unistd.h&gt;
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello world(pid: %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 创建失败
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error&#34;</span><span class="o">+</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span><span class="c1">// 子进程
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello, i am child (pid: %d)&#34;</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">//!!!!!!!! 注意父进程的 rc 值是 子进程的 pid
</span><span class="c1"></span>    	<span class="kt">int</span> <span class="n">wc</span> <span class="o">==</span> <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello, i am parent of %d (wc: %d) (pid: %d)&#34;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">wc</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>rc = wc</p>
<p>fork 用作相同程序的拷贝作用，执行不同的程序时， 可以用</p>
<ul>
<li>exec()</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argc</span><span class="p">[]){</span>
    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error&#34;</span> <span class="o">+</span> <span class="n">stderr</span><span class="p">);</span>
    	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">close</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">);</span><span class="c1">// 关闭标准输入与输出
</span><span class="c1"></span>        <span class="n">open</span><span class="p">(</span><span class="s">&#34;./p4,output&#34;</span><span class="p">,</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">S_IRWXU</span><span class="p">);</span>  
        <span class="kt">char</span> <span class="o">*</span> <span class="n">myargs</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">myargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;wc&#34;</span><span class="p">;</span> <span class="c1">// 可运行的程序
</span><span class="c1"></span>        <span class="n">myargs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;file.c&#34;</span><span class="p">;</span>
        <span class="n">myargs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">execvp</span><span class="p">(</span><span class="n">myargs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">myargs</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="c1">// this will be not ecec
</span><span class="c1"></span>    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>    
    <span class="n">retrun</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>// todo</p>
<h3 id="线程api">线程API</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span> <span class="n">pthread_t</span> <span class="o">*</span> <span class="kr">thread</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">pthread_attr_t</span> <span class="o">*</span> <span class="n">attr</span><span class="p">,</span>
                  <span class="kt">void</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
                  <span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">);</span>
<span class="cm">/*
</span><span class="cm">1、第一个是指向 pthread_t 的指针， 用于交互
</span><span class="cm">2、第二个是设置新的线程的，栈大小等等信息
</span><span class="cm">3、执行的函数
</span><span class="cm">4、参数
</span><span class="cm">*/</span>

<span class="kt">void</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span> <span class="kr">thread</span><span class="p">,</span><span class="kt">void</span> <span class="o">**</span> <span class="n">value_ptr</span><span class="p">)</span>
<span class="c1">//第一个参数为创建的时候，保留的指针， 第二个为返回值
</span></code></pre></td></tr></table>
</div>
</div><h2 id="3并发同步">3.并发同步</h2>
<blockquote>
<p>掌握进程并发同步相关概念，如死锁、活锁等概念，真实应用中存在的不同类型的同步
问题，熟练使用pthread库中的相关同步函数进行编程。</p>
</blockquote>
<p>题目说，进程并发同步的相关概念， 让我对进程和线程的理解再次产生怀疑，首先再次总结一下：</p>
<p>进程是为运行中的程序提供的一个抽象，线程是为单个运行的进程提供的抽象，多线程程序有多个执行点， 每个线程类似于进程， 唯一的区别是： 线程之间共享地址空间，能够访问相同的数据（在堆上的数据或者全局变量， 不是局部变量）。</p>
<p>非死锁：</p>
<ul>
<li>违反原子性</li>
<li>违反顺序缺陷</li>
</ul>
<h3 id="死锁">死锁：</h3>
<p>产生原因：</p>
<ul>
<li>
<p>组件之间会有复杂的依赖</p>
</li>
<li>
<p>模块化会封装细节</p>
</li>
</ul>
<p>解决方案：</p>
<p>所有的线程获取锁的顺序如果是相同的就不会产生死锁</p>
<p>产生条件：</p>
<ul>
<li>互斥</li>
</ul>
<p>使用硬件支持， 使用不用锁的数据结构！</p>
<ul>
<li>持有并等待</li>
</ul>
<p>或取多个锁时： 可以用一个把大的锁锁住， 即使防止获取锁的过程中，上下文切换！</p>
<ul>
<li>非抢占</li>
</ul>
<p>获取第一个锁后，查看第二个锁是否被占有， 如果占有直接放弃第一个锁，再次获取第一个锁， 这样存在一个问题， 两个锁一直重复这个问题， 倒置<strong>活锁</strong></p>
<ul>
<li>循环等待</li>
</ul>
<p>锁的获取按照一定的顺序获取等待</p>
<h2 id="4地址空间">4.地址空间</h2>
<blockquote>
<p>掌握地址空间的概念，以及用户态堆内存的管理。</p>
</blockquote>
<p>一个进程的地址空间应该包含运行的程序的所有内存状态，操作系统给程序的抽象， 包括代码块， 堆，栈，真实的<strong>物理空间</strong>可能在任意的地方，地址空间是连续的0KB -&gt; 16KB 。如下图：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104151718.png" alt=""></p>
<p>所谓堆内存（属于地址空间）， 申请和释放都是又程序猿自己自己自己完成（注意这里操作的是地址空间，虚拟的）。java不用</p>
<h3 id="分配">分配：</h3>
<p>void malloc（size_t size） , size大小一般为宏来设定， 比如 sizeof(double),  注意 void 的返回类型 是返回地址的指针，可以强转， 如下：</p>
<p>int *x = malloc(sizeof(int));</p>
<h3 id="释放">释放：</h3>
<p>free(x)   , 分配的大小不会被用户传入， 必须由<strong>内存分配库</strong>本身记录追踪。</p>
<h3 id="常见错误">常见错误：</h3>
<ul>
<li>
<p>忘记分配内存（这个常犯， 常犯， 给一个指针赋值！！！！指针是存放在栈中的， 4个字节的）</p>
</li>
<li>
<p>没有分配足够的内存</p>
</li>
<li>
<p>忘记初始化分配的内存， NULL 一般输出为 0， 但0 不等于 NULL ，默认都是0</p>
</li>
<li>
<p>忘记释放内存（这个我一般都不是释放 ^ _ ^，web、操作系统等长时间运行的程序一定需要！！）</p>
</li>
<li>
<p>反复释放内存（内存都不释放， 这个绝对不会发生的）</p>
</li>
<li>
<p>用完之前释放内存</p>
</li>
<li>
<p>错误调用free（）， 参数传入错误的值。</p>
</li>
</ul>
<h2 id="5同步原语">5.同步原语</h2>
<p>掌握锁、条件变量、信号量三种同步机制（熟练使用pthread库中的函数），并使用这些
机制解决实际应用问题，如生产者消费者问题。</p>
<h3 id="锁">锁：</h3>
<p>锁就是一个<strong>变量</strong>， 锁为程序员提供了最小程度的调度控制，线程是操作系统的cpu调度的最小单位。</p>
<h4 id="实现锁">实现锁</h4>
<h5 id="控制中断">控制中断</h5>
<p>通过控制中断， 让代码原子执行</p>
<p>缺点很多， 不支持多cpu， 出现系统问题，操作系统需要控制中断来获取控制权。。。</p>
<h5 id="testandset">TestAndSet</h5>
<p>这条指令基于硬件的支持，等价于下面代码是<strong>原子执行</strong>的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">TestAndSet</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">old_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span><span class="p">){</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">old_ptr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">old_ptr</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>实现自旋锁</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">lock_t</span> <span class="p">{</span>
 	<span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>
 <span class="p">}</span> <span class="n">lock_t</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">lock_init</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
 	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">){</span>
    <span class="k">while</span><span class="p">(</span><span class="n">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">//上面会一直自旋，浪费cpu资源， 也可能一直自旋永远得不到执行
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">){</span>
    <span class="n">lock</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="fetchandadd">FetchAndAdd</h5>
<p>这也是一个硬件支持的原语，这一条指令等价于下面原子执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">FetchAndAdd</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">old</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>实现一个公平的自旋锁</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">lock_t</span> <span class="p">{</span>
 	<span class="kt">int</span> <span class="n">ticket</span><span class="p">;</span>
 	<span class="kt">int</span> <span class="n">turn</span><span class="p">;</span>
 <span class="p">}</span> <span class="n">lock_t</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">lock_init</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
 	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">ticket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">myturn</span> <span class="o">=</span> <span class="n">FetchAndAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ticket</span><span class="p">);</span>
    <span class="c1">// 这里每一一次测试都会增加， 让每一个线程都能得到执行！
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">trun</span> <span class="o">!=</span> <span class="n">myturn</span><span class="p">);</span>
    <span class="c1">//这里还是会自旋
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">){</span>
    <span class="n">FetchAndAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">turn</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面硬件原语的支持虽然实现了简单的公平锁， 但是它会自旋，下面实现不自旋的公平锁</p>
<h4 id="实现公平不自旋锁">实现公平不自旋锁</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">__lock_t</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>
 	<span class="kt">int</span> <span class="n">guard</span><span class="p">;</span>
	<span class="n">queue_t</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
<span class="p">}</span> <span class="n">lock_t</span><span class="p">;</span>

 <span class="kt">void</span> <span class="nf">lock_init</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
 	<span class="n">m</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 	<span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 	<span class="n">queue_init</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="kt">void</span> <span class="nf">lock</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
 	<span class="k">while</span> <span class="p">(</span><span class="n">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">// 这里虽然也会自旋， 但是这个guard，在一个线程获取锁后（后面的else），guard也设置成了0，
</span><span class="c1"></span>     <span class="c1">//也就是说，即使已经有线程获取了锁， 这条指令还是有可能通过的， 不会一直在这里自旋，只会自旋几个周期
</span><span class="c1"></span>	<span class="c1">// guard的作用是保证后面的flag的设置是原子进行的
</span><span class="c1"></span>     
     <span class="c1">// 这里保证的原子的执行了， 因为其它指令的gurad为1，进不来这里， 不会有两个线程同时进入这里
</span><span class="c1"></span> 	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="c1">// 如果能获取到锁
</span><span class="c1"></span> 		<span class="n">m</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
 		<span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// 重置为0
</span><span class="c1"></span> 	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="c1">// 如果没有获取到锁
</span><span class="c1"></span> 		<span class="n">queue_add</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">gettid</span><span class="p">());</span><span class="c1">// 加入队列，休眠队列
</span><span class="c1"></span> 		<span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// guard这里也重置为0
</span><span class="c1"></span> 		<span class="n">park</span><span class="p">();</span>
        <span class="c1">//这个是操作系统提供给程序员的函数， 休眠自己，在c语言中， 每种操作系统可以提供不同的
</span><span class="c1"></span>        <span class="c1">//函数库供程序猿调度，在 java统一为yeild（）， linux中使用c也为 yeild（）
</span><span class="c1"></span> 	<span class="p">}</span>
 <span class="p">}</span>

<span class="kt">void</span> <span class="nf">unlock</span><span class="p">(</span><span class="n">lock_t</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
 	<span class="k">while</span> <span class="p">(</span><span class="n">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//通过自旋获取guard
</span><span class="c1"></span> 
 	<span class="k">if</span> <span class="p">(</span><span class="n">queue_empty</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">))</span>
		 <span class="n">m</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 空的话flag直接设置0
</span><span class="c1"></span> 	<span class="k">else</span>
		 <span class="n">unpark</span><span class="p">(</span><span class="n">queue_remove</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">));</span> 
 		<span class="c1">// 这里并没有将 flag设置0， 因为要保证公平性， 按照队列的线程来进行唤醒，这样
</span><span class="c1"></span>    <span class="c1">// 队列里的每一个线程都能够得到执行，直接将flag的1 使用权传给了队列的第一个线程
</span><span class="c1"></span> 	<span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码还有一个很微妙的竞态条件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"> 		<span class="n">queue_add</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">,</span> <span class="n">gettid</span><span class="p">());</span>
 		<span class="n">m</span><span class="o">-&gt;</span><span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 		<span class="n">park</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>假设这段代码执行完前两句语句， 此时guard 变成了0，  释放锁的线程可以运行了， 而这个线程已经在休眠队列里面，但是它却还没有休眠， 这是如果唤醒了它，相当于白唤醒， 之后它执行park又再次休眠，而没加入队列里面了。结果就是永久休眠。 所以linux的实现有一个再次确认的代码！！！</p>
<p>linux 也是使用这种思想， 但是提供的原语不同。</p>
<p>锁的实现已经完成了，但是还有一种情况，当父进程等待子进程结束的时候，就要用到下面的同步原语：</p>
<h3 id="条件变量">条件变量</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">pthread_cond_wait</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">m</span><span class="p">);</span>
<span class="n">pthread_cond_signal</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>实现子进程等带父进程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pthread_mutex_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">c</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">thr_exit</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
   <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="n">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
   <span class="c1">//唤醒因为条件c而休眠你的线程
</span><span class="c1"></span>   <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">child</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&#34;child</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
   <span class="n">thr_exit</span><span class="p">();</span>
   <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thr_join</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
   <span class="c1">//为什么要锁呢？ 因为下面wait函数有释放锁！！！！！！！！！！！
</span><span class="c1"></span>   <span class="k">while</span> <span class="p">(</span><span class="n">done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>			
   <span class="n">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
   <span class="cm">/**
</span><span class="cm">   1、 这里要使用一个done来标记时候是否完成， 如果不用， 子进程先于父进程完成的时候，就会卡主
</span><span class="cm">   因为子进程已经过了唤醒父进程，而父进程又重新休眠，这样没有线程唤醒父进程
</span><span class="cm">   2、当调用了这条命令之后， 线程首先会将** 锁释放 **，然后调用线程休眠自己，（原子操作）
</span><span class="cm">   3、要用while， 而不能用if，在这里使用if正确， 但是有多个信号的时候， 可能会出现1 的情况
</span><span class="cm">   */</span>
   <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&#34;parent: begin</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
   <span class="n">pthread_t</span> <span class="n">p</span><span class="p">;</span>
   <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span><span class="c1">//创建新的线程
</span><span class="c1"></span>   <span class="n">thr_join</span><span class="p">();</span>		<span class="c1">//等待子线程完成
</span><span class="c1"></span>   <span class="n">printf</span><span class="p">(</span><span class="s">&#34;parent: end</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>书上没有给出条件变量的实现方法，但是通过其功能描述结合锁的实现应该也略知一二！</p>
<h3 id="信号量">信号量</h3>
<p>信号量是dijkstra提出的，可以用作为锁和条件变量， 让同步原语更加通用。</p>
<p>信号量是一个<strong>整形数值</strong>的对象, 下面是POSIX库的使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#incldue &lt;semaphore.h&gt;
</span><span class="cp"></span><span class="n">sem_s</span> <span class="n">s</span><span class="p">;</span>
<span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="n">sem_wait</span><span class="p">(</span><span class="n">sem_s</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="n">sem_post</span><span class="p">(</span><span class="n">sem_s</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>

<span class="cm">/*
</span><span class="cm">一共有三个参数：
</span><span class="cm">1、 s是传入一个信号量
</span><span class="cm">2、0表示同一进程多个线程共享， 当为其它的时候， 可以在不同的进程中通知
</span><span class="cm">3、初始化信号量的值为 1
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="实现信号量">实现信号量</h4>
<p>基于锁和信号量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Zem_t</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">pthread_cond_t</span> <span class="n">cond</span><span class="p">;</span>
	<span class="n">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Zem_t</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Zem_init</span><span class="p">(</span><span class="n">Zem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">Cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">);</span>
	<span class="n">Mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Zem_wait</span><span class="p">(</span><span class="n">Zem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
 	<span class="n">Mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
 	<span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="c1">//当初始化的value小于等于0 的时候等待当前的线程
</span><span class="c1"></span> 		<span class="n">Cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
 	<span class="n">s</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">--</span><span class="p">;</span>			<span class="c1">// value 减去1不能放到上面，原因在下面
</span><span class="c1"></span> 	<span class="n">Mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

 <span class="kt">void</span> <span class="nf">Zem_post</span><span class="p">(</span><span class="n">Zem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
 	<span class="n">s</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>  		<span class="c1">//唤醒一个等待着的线程，对应的value 加上1
</span><span class="c1"></span> 	<span class="n">Cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">);</span>
 	<span class="n">Mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>看了实现之后， 很容易就能用一个信号量实现一个锁</p>
<h4 id="信号量实现条件变量">信号量实现条件变量</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">sem_t</span> <span class="n">s</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">child</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
 	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;child</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> 
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 这里初始化为0，
</span><span class="c1"></span>	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;parent: begin</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="n">pthread_t</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span> 
    <span class="cm">/*
</span><span class="cm">    有两种情况考虑：
</span><span class="cm">    1、 当父进程线运行时， 信号量的值为0，休眠自己，此时不会减去1
</span><span class="cm">    	子进程运行post的时候，唤醒了父进程，value加上了1，变成1
</span><span class="cm">    	********* 父进程继续运行，减去1 ， 信号量重新变为0， 这就是value - 1 不能放上面的原因！！
</span><span class="cm">    2、 当子进程先运行的时候， value加上了1， 等于1
</span><span class="cm">    	当父进程运行的时候， value为1， 不用等了
</span><span class="cm">    */</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;parent: end</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="二值信号量锁">二值信号量（锁）</h4>
<p>初始化信号量的值为1，这就实现了一个锁！！！</p>
<p>当有一个进程获取锁之后， value 就变成了0， 其它线程要进入必须等待被唤醒。</p>
<p>当有多个线程在休眠时， 多个线程同时被唤醒， 多个线程会抢占锁，谁先抢到谁先起来， 这里应该是存在不公平现象的， 有可能有些线程一直得不到执行！？？？？？？？应该只有一个线程会被唤醒！！！？？？</p>
<p>上面理解错误！！！！不会有多个被唤醒的情况， 条件变量目前只有一个在等待</p>
<p>应该是按照fifo来的</p>
<h3 id="生产者消费者">生产者消费者</h3>
<h4 id="基于条件变量和锁">基于条件变量和锁</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">fill_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">use_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">buffer</span><span class="p">[</span><span class="n">fill_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
 	<span class="n">fill_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">fill_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX</span><span class="p">;</span>
 	<span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
 	<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">use_ptr</span><span class="p">];</span>
 	<span class="n">use_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">use_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX</span><span class="p">;</span>
 	<span class="n">count</span><span class="o">--</span><span class="p">;</span>
 	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

 <span class="n">cond_t</span> <span class="n">empty</span><span class="p">,</span> <span class="n">fill</span><span class="p">;</span>
 <span class="n">mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
<span class="cm">/*
</span><span class="cm">这里要使用两个条件变量， 如果只使用一个， 而条件变量的唤醒不是按照队列来的，这时
</span><span class="cm">假设有两个消费者因为没有count休眠
</span><span class="cm">而生产者生产满了之后， 就去休眠了， 等待唤醒
</span><span class="cm">此时一个消费者先被唤醒，消费完count后， 唤醒了另一个消费者，发现count已经没了，也去休眠，
</span><span class="cm">此时没人唤醒生产者了。。。
</span><span class="cm">*/</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
 		<span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p1
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">MAX</span><span class="p">)</span> <span class="c1">// p2
</span><span class="c1"></span>            <span class="n">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p3
</span><span class="c1"></span>        <span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// p4
</span><span class="c1"></span>        <span class="n">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fill</span><span class="p">);</span> <span class="c1">// p5
</span><span class="c1"></span>        <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// p6
</span><span class="c1"></span>	 <span class="p">}</span>
 <span class="p">}</span>

 <span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c1
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// c2
</span><span class="c1"></span>         	<span class="n">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fill</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c3
</span><span class="c1"></span>        <span class="cm">/*
</span><span class="cm">        这里使用while，而不是if， 原因：
</span><span class="cm">        当有多个消费者时， 其中一个消费者先运行，发现count = 0，休眠， 接下来生产者生产一个
</span><span class="cm">        count = 1， 这时另一个消费者运行， 把数据取走， 此时count = 0； 假设接下来是
</span><span class="cm">        刚才那个休眠的消费者继续运行，此时count已经是0了， 而如果使用if， if只会判断一次， 
</span><span class="cm">        刚才休眠的时候已经判断过了，所以这个消费者会继续运行， count -= 1； = -1！！！
</span><span class="cm">        所以要使用while ， while 会重新回来判断！！
</span><span class="cm">        */</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">get</span><span class="p">();</span> <span class="c1">// c4
</span><span class="c1"></span>        <span class="n">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// c5
</span><span class="c1"></span>        <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// c6
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>
 <span class="p">}</span>


</code></pre></td></tr></table>
</div>
</div><h4 id="基于信号量">基于信号量</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
 	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
 		<span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line P0 (NEW LINE)
</span><span class="c1"></span>        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// Line P1
</span><span class="c1"></span>        <span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// Line P2
</span><span class="c1"></span>        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span> <span class="c1">// Line P3
</span><span class="c1"></span>        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line P4 (NEW LINE)
</span><span class="c1"></span> 	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
 	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
 	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line C0 (NEW LINE)
</span><span class="c1"></span>         <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span> <span class="c1">// Line C1
</span><span class="c1"></span>         <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">get</span><span class="p">();</span> <span class="c1">// Line C2
</span><span class="c1"></span>         <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// Line C3
</span><span class="c1"></span>         <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// Line C4 (NEW LINE)
</span><span class="c1"></span>         <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
 	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="6分段与分页">6.分段与分页</h2>
<blockquote>
<p>掌握虚拟内存管理中的分段与分页机制的原理，以及比较其优缺点。</p>
</blockquote>
<h3 id="动态重定位"><strong>动态重定位</strong>：</h3>
<p>基于硬件的动态重定位，使用内存管理单元（MMU）给<strong>地址空间</strong>分配内存，效率低下， 造成很多内部碎片（图中allocated but not use）。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20200104152143704.png" alt=""></p>
<h3 id="分段">分段：</h3>
<p>因此引入分段解决内部碎片问题：MMU给<strong>地址空间</strong>内的每一个逻辑段都分配内存。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20200104152706215.png" alt=""></p>
<p>段的引用： 显示方式</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104153148.png" style="zoom:80%;" /></p>
<p>于是乎， 在内存上产生很多<strong>外部碎片</strong>， 解决方法，基于空闲列表 和 各种管理算法：</p>
<p>这里我觉得不会考，但列一列：</p>
<ul>
<li>
<p>最优匹配</p>
</li>
<li>
<p>最差匹配</p>
</li>
<li>
<p>首次匹配</p>
</li>
<li>
<p>下次匹配</p>
</li>
<li>
<p>分离空闲列表：经常申请的内存空间，给它一个独立的列表</p>
</li>
<li>
<p>伙伴系统： 二分分配， 合并和分配的时候很方便， 二进制与二叉树的巧合</p>
</li>
</ul>
<p>可以看出分段会产生外部碎片， 这是一个很根本的问题，不通用， 即使有管理内存算法！</p>
<p>以上不会考的，应该考二级页表！</p>
<h3 id="分页">分页：</h3>
<p>分页不是将一个<strong>地址空间</strong>按逻辑段分， 而是分割成固定大小的单元，称为 <strong>页帧</strong>。</p>
<p>页表： 记录每一个地址空间的每一个<strong>虚拟页</strong>（<strong>页帧</strong>）在物理内存中的位置，==页表是每一个进程数据结构==。</p>
<p>物理帧号（PFN）或称 物理页号（PPN physical page number）： 真实的物理 <strong>页帧</strong> 地址。</p>
<ul>
<li>地址空间划分：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104162855.png" alt=""></p>
<ul>
<li>物理地址划分</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104162939.png" alt=""></p>
<p>页表项（PTE page table entry）： 记录 PFN</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104160826.png" alt=""></p>
<p>上图中中间的地址转换（address translation）就通过页表来存储！！</p>
<h4 id="例子">例子：</h4>
<p><strong>地址空间</strong> 地址 21  -&gt; 010101  <img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104160907.png" alt=""></p>
<p>从物理地址 （vpn 01 推出 ）中拿出PTE，取出 PFN 得到地址空间的真实的物理地址， 偏移量不变， 因为页帧一样大。</p>
<p>如何拿出vpn对应的PTE：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">VPN</span> <span class="o">=</span> <span class="p">(</span><span class="n">VirtualAddress</span> <span class="o">&amp;</span> <span class="n">VPN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT</span>             <span class="c1">//取出VPN
</span><span class="c1"></span><span class="n">PTEAddr</span> <span class="o">=</span> <span class="n">PageTableBaseRegister</span> <span class="o">+</span> <span class="p">(</span><span class="n">VPN</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PTE</span><span class="p">))</span>  <span class="c1">// 算出物理地址， 拿到PTE的物理地址
</span></code></pre></td></tr></table>
</div>
</div><p>于是呢， 有两次的内存访问， ==慢==！</p>
<p>页表存放：</p>
<p>简单的存放线性页表， 32 位的地址空间， 4KB（2^ 12）的页大小（大部分os，windows，linux），PTE个数：2^32 / 2^12 = 2^20,  PTE大小（假设）4B， 线性页表大小 4B * 2^20 = 4MB, 所以一个进程就 4MB内存， 10个就==。。。==</p>
<p>以上就是页表的两个缺点！</p>
<p>先比较优缺点：</p>
<table>
<thead>
<tr>
<th style="text-align:center">策略</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">分段</td>
<td style="text-align:center">很好支持稀疏地址空间，很快，算法简单，适合硬件完成，地址转换的开销极小， 代码共享（如果代码独立的段中，可以被多个运行程序共享）。</td>
<td style="text-align:center">不支持<strong>一般化</strong>的稀疏地址，产生外部碎片问题很根本，难以避免，随时间推移，管理难，分配也困难。</td>
</tr>
<tr>
<td style="text-align:center">分页</td>
<td style="text-align:center">不会导致外部碎片， 很灵活，支持稀疏的地址空间</td>
<td style="text-align:center">速度较慢，要两次访问内存，<strong>有可能</strong>产生内存浪费</td>
</tr>
</tbody>
</table>
<h2 id="7tlb-多级页表">7.TLB， 多级页表</h2>
<blockquote>
<p>掌握TLB 与多级页表，掌握多级页表相关的计算，比如根据地址位、页面大小、PTE 大
小等条件，进行虚拟地址到物理地址的转换；掌握多级页表的访问过程。</p>
</blockquote>
<p>第6点的页表的两个问题需要解决！</p>
<h3 id="解决问题1-慢">解决问题1： 慢</h3>
<h4 id="tlb">TLB：</h4>
<p>TLB（地址转换旁路缓冲储存器）也叫 地址转换缓存， 频繁发生虚拟到物理地址的硬件缓存。</p>
<h5 id="原理注意加粗--">原理（注意加粗， ** **）：</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">VPN</span> <span class="o">=</span> <span class="p">(</span><span class="n">VirtualAddress</span> <span class="o">&amp;</span> <span class="n">VPN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT</span>
 <span class="p">(</span><span class="n">Success</span><span class="p">,</span> <span class="n">TlbEntry</span><span class="p">)</span> <span class="o">=</span> <span class="n">TLB_Lookup</span><span class="p">(</span><span class="n">VPN</span><span class="p">)</span>  <span class="c1">// TLB里面找VPN对应的物理地址
</span><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">Success</span> <span class="o">==</span> <span class="n">True</span><span class="p">)</span> <span class="c1">// TLB Hit
</span><span class="c1"></span>	 <span class="k">if</span> <span class="p">(</span><span class="n">CanAccess</span><span class="p">(</span><span class="n">TlbEntry</span><span class="p">.</span><span class="n">ProtectBits</span><span class="p">)</span> <span class="o">==</span> <span class="n">True</span><span class="p">)</span>
		<span class="n">Offset</span> <span class="o">=</span> <span class="n">VirtualAddress</span> <span class="o">&amp;</span> <span class="n">OFFSET_MASK</span>
 		<span class="n">PhysAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">TlbEntry</span><span class="p">.</span><span class="n">PFN</span> <span class="o">&lt;&lt;</span> <span class="n">SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">Offset</span>
 		<span class="n">Register</span> <span class="o">=</span> <span class="n">AccessMemory</span><span class="p">(</span><span class="n">PhysAddr</span><span class="p">)</span>  <span class="c1">// 直接从** 缓存地址**中拿到实际的物理地址
</span><span class="c1"></span>	 <span class="k">else</span>
		 <span class="n">RaiseException</span><span class="p">(</span><span class="n">PROTECTION_FAULT</span><span class="p">)</span>
 <span class="k">else</span> 			<span class="c1">// TLB Miss
</span><span class="c1"></span>	 <span class="n">PTEAddr</span> <span class="o">=</span> <span class="n">PTBR</span> <span class="o">+</span> <span class="p">(</span><span class="n">VPN</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PTE</span><span class="p">))</span>
	 <span class="n">PTE</span> <span class="o">=</span> <span class="n">AccessMemory</span><span class="p">(</span><span class="n">PTEAddr</span><span class="p">)</span>    <span class="c1">//没有找到就多了一次PTE ** 内存 **的寻址， 多了一次一次就一次
</span><span class="c1"></span>  	<span class="k">if</span> <span class="p">(</span><span class="n">PTE</span><span class="p">.</span><span class="n">Valid</span> <span class="o">==</span> <span class="n">False</span><span class="p">)</span>
	 	<span class="n">RaiseException</span><span class="p">(</span><span class="n">SEGMENTATION_FAULT</span><span class="p">)</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">CanAccess</span><span class="p">(</span><span class="n">PTE</span><span class="p">.</span><span class="n">ProtectBits</span><span class="p">)</span> <span class="o">==</span> <span class="n">False</span><span class="p">)</span>
		<span class="n">RaiseException</span><span class="p">(</span><span class="n">PROTECTION_FAULT</span><span class="p">)</span>
	<span class="k">else</span>
		<span class="n">TLB_Insert</span><span class="p">(</span><span class="n">VPN</span><span class="p">,</span> <span class="n">PTE</span><span class="p">.</span><span class="n">PFN</span><span class="p">,</span> <span class="n">PTE</span><span class="p">.</span><span class="n">ProtectBits</span><span class="p">)</span>
		<span class="n">RetryInstruction</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="缓存">缓存：</h4>
<p>计算机中有很多缓存，有指令、数据、地址转换， 上面是地址转换的缓存TLB，缓存要小，越小越快（物理限制），有时间和空间局部性。cpu的数据缓存也分为多级。</p>
<p>曾看到一道题， TLB 和 cache 有什么不同？？？？</p>
<h4 id="问题里面的问题">问题里面的问题：</h4>
<p>当TLB中有两条相同的VPN索引两个不同的物理地址， 可以通过ASID标记（进程号）来标记， 这样就不用覆盖掉之前的VPN了， 当两个进程交互运行时， 相同的VPN可以存在于TLB中，还是上一张图。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104165558.png" alt=""></p>
<h5 id="tlb覆盖问题">TLB覆盖问题：</h5>
<p>如果程序短时间内访问的页数超过了 TLB中的页数， 会产生大量未命中，因为要重写，因此要支持更大的页， 才不会访问很多页！！</p>
<h5 id="tlb的替换策略lru">TLB的替换策略：LRU</h5>
<p>难道是问题8的？ 不是的，问题8是页的替换， 这里是TLB的替换，思路应该一样的！！</p>
<p>听说腾讯的面试有要求写一个LRU算法！ 基于哈希，哈希每次访问的地址，用一个链表存储哈希后的地址数值，有新的访问就把他放到链表的头结点（包括在链表中的），满了删队尾。（脑子里想起链表的操作删除，插入操作）</p>
<h3 id="解决问题2-页表很大">解决问题2： 页表很大！</h3>
<h4 id="更大的页">更大的页</h4>
<p>页变大， 页表条目减少， 页表也就小了， 但是页变大有内部碎片产生！因为每一页都用不完积累就多</p>
<h4 id="分段分页">分段+分页</h4>
<p>分段与分页相结合，外部碎片再次产生， 页表就是为了解决外部碎片的！！！分段产生外部碎片的根源，无可避免！！</p>
<h4 id="多级页表">多级页表</h4>
<p>于是乎，只有引入多级页表：</p>
<p>问题所在： 页表中存在很多无效区域。</p>
<p>基本思想：将<strong>页表</strong>分成<strong>页</strong>大小的单元，如果整页的PTE无效，就完全不分配该页的页表（很重要！）于是引入:</p>
<p>PDE(页目录)： 记录页表的页是否有效， 包含有效位和页帧号。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104215751.png" alt=""></p>
<p>详细深入具体仔细的一个书上的例子： 完美非无可增，乃不可减，老师说必考。</p>
<p>首先题目： 地址空间 16KB（2^14)，地址位数14位， 页大小 64B（2^6),   偏移位数6 位，VPN位数： 14 - 4 = 8 位，页表项条数为 2^8条 , PTE的大小为 4B（假设），如果是线性页表大小为： 4 * 256B = 1KB，如果分配到PDE中， 每页存 64B/4B = <font color="red">16</font> 条PTE，一共要256/16 = ==16==页来存储PTE，于是页目录的索引要 4位（来自黄色的数字），如下图：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104221733.png" alt=""></p>
<p>计算PTE的PFN算法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">PDEAddr</span> <span class="o">=</span> <span class="n">PageDirBase</span> <span class="o">+</span> <span class="p">(</span><span class="n">PDIndex</span><span class="p">(</span><span class="mi">4</span><span class="err">位就可以找到！</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PDE</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>于是找到了PTE所在的物理页帧PFN！（第一步）</p>
<p>因为VPN一共8位， 找PTE所在的页用了4位， 还有4位就索引属于该页所有的PTE的那一条（来自红色的数字）！</p>
<p>通过下面的这条式子找到， 实际物理地址的PFN！(第二步)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">PTEAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PDE</span><span class="p">.</span><span class="n">PFN</span> <span class="o">&lt;&lt;</span> <span class="n">SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">PTIndex</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PTE</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>最后,计算实际的物理地址！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">PhysAddr = (PTE.PFN &lt;&lt; SHIFT) + offset
</code></pre></td></tr></table>
</div>
</div><p>总结，二级页表的访问内存数目达到了两次，访问速度慢， 但是解决了页表大的问题， 是一个时空的折中。</p>
<h2 id="8页面置换算法">8.页面置换算法</h2>
<p>掌握页面置换算法，比如FIFO，LRU等，要求能根据给定的页面访问序列，给出特定算
法的计算过程；掌握CLOCK算法。</p>
<p>这一块课，没有去听，^ _ ^</p>
<h3 id="fifo">FIFO</h3>
<p>这个好实现， 先进先出，用一个队列就行！</p>
<h3 id="lru">LRU</h3>
<p>这个在TLB的替换页面中写了。</p>
<p>LRU 也有问题， 当内存大的时候， LRU的实现代价很大，比如存储LRU的数据结构，因此引入一个近似LRU：</p>
<h3 id="近似lru">近似LRU</h3>
<p>近似LRU 要硬件的帮助， 给页增加一个使用位， 如果为1， 则认为当前页正在被使用。</p>
<h4 id="clock算法">clock算法</h4>
<p>算法思路： 当要进行页替换的时候，检查当前的页的使用位，如果为1， 则意味着当前页在被使用，不适合替换，然后将这个位设置为0， 接着检查下一个页的使用位。 如果为0， 则直接替换。 算法的最坏情况是所有的页都是在被使用的， 把所有的1 都换为 0， 此时再来一遍循环选第一个替换， 实际上这种情况很少出现！</p>
<h4 id="arc算法">ARC算法</h4>
<p>书上没有介绍！</p>
<p>//todo</p>
<h2 id="9磁盘驱动器">9.磁盘驱动器</h2>
<blockquote>
<p>掌握磁盘寻道、旋转、传输时间的概念及计算过程。</p>
</blockquote>
<p>寻道： 就是寻道，一般有偏斜</p>
<p>旋转：就是旋转</p>
<p>T ~I/O~ = T ~寻道~ + T ~旋转~ + T ~传输~</p>
<p>R~I/O~（传输速度） = 文件大小 / T ~I/O~</p>
<h2 id="10磁盘调度算法">10.磁盘调度算法</h2>
<blockquote>
<p>了解各种磁盘调度算法的原理。</p>
</blockquote>
<h3 id="sjf">SJF</h3>
<p>最短任务优先， 计算 I/O的时间，选择最短的！</p>
<h3 id="sstf">SSTF</h3>
<p>最短寻道时间优先， 可能产生饥饿，一直在同一道内请求</p>
<h3 id="scan">SCAN</h3>
<p>到一层的时候， 将请求加入队列， 处理完再寻道，这样避免饥饿</p>
<h3 id="sptf">SPTF</h3>
<p>最短定位时间</p>
<h2 id="11raid">11.RAID</h2>
<blockquote>
<p>掌握磁盘阵列RAID-0，RAID-1，RAID-4，RAID-5的原理，并分析各种RAID在容量、可
靠性、吞吐量三个层面的特性。熟练使用RAID的这些特性进行设计。</p>
</blockquote>
<p>RAID:  廉价冗余磁盘阵列</p>
<p>用于使用多个磁盘构建更大、更快、更可靠的磁盘系统</p>
<h3 id="raid0">RAID0</h3>
<p>条带化</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174035.png" alt=""></p>
<p>计算公式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">Disk</span> <span class="o">=</span> <span class="n">A</span> <span class="o">%</span> <span class="n">number_of_disks</span>
<span class="n">Offset</span> <span class="o">=</span> <span class="n">A</span> <span class="o">/</span> <span class="n">number_of_disks</span>
</code></pre></td></tr></table>
</div>
</div><p>容量最好， 性能优， 不可靠！</p>
<h3 id="raid1">RAID1</h3>
<p>一半用作镜像</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174309.png" alt=""></p>
<p>容量减半， 速度也减半， 因为并发io，少了一半，可靠！</p>
<h3 id="raid4">RAID4</h3>
<p>专门用一个磁盘用来奇偶校验</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174532.png" alt=""></p>
<p>可靠， 速度（n-1）S， 容量大</p>
<p>当一校验盘同时有两个块需要校验时， 速度会减慢， 因此引入：</p>
<h3 id="raid5">RAID5</h3>
<p>旋转奇偶校验</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174917.png" alt=""></p>
<p>可靠， 速度（n-1）S，容量大</p>
<h3 id="性能比较">性能比较：</h3>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174957.png" alt=""></p>
<h2 id="12文件系统接口">12.文件系统接口</h2>
<blockquote>
<p>了解文件系统接口，如open，read，write，在实现时对元数据和文件内容的读写过程。</p>
</blockquote>
<p>都说不考喽！！！</p>
<h2 id="13操作系统历史">13.操作系统历史</h2>
<blockquote>
<p>了解课堂上讲到的跟操作系统发展史相关的重要人物，并能介绍其主要贡献。</p>
</blockquote>
<ul>
<li>图灵</li>
</ul>
<p>计算机之父</p>
<ul>
<li>冯·诺伊曼</li>
</ul>
<p>提出了“存储程序”的概念和二进制原理</p>
<ul>
<li>linus</li>
</ul>
<p>编写第一个linux</p>
<ul>
<li>阿兰·马西森·图灵（1912-1917年6月23日）</li>
</ul>
<p>他在计算机科学的发展，提供概念的形式化“算法”和“计算”的图灵机，可以考虑通用计算机的模型。</p>
<p>图灵被广泛认为是理论计算机之父！</p>
<ul>
<li>Dijkstra</li>
</ul>
<p>同步进程通信的信号量</p>
<ul>
<li>Thompson</li>
</ul>
<p>用B语言写了第一个UNIX操作系统</p>
<h2 id="14其它">14.其它</h2>
<blockquote>
<p>作业中的难点问题需要掌握其解题方法。</p>
</blockquote>
<p>都包含在上面了。</p>

  </div>
</article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="http://github.com/fierygit" class="iconfont icon-github" title="github"></a>
  <a href="http://fireflying.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>Firefly</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
