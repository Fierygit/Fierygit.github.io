<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title> - Firefly</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Firefly" /><meta name="description" content="集合总结 copy from zengsiyan Java对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储（内存上的存储）。 然而使用数组存储对象存在一" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.79.0 with theme even" />


<link rel="canonical" href="http://fireflying.top/notepad/java/javanote/java-basic-study/target/classes/basic/collection/readme/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="" />
<meta property="og:description" content="集合总结 copy from zengsiyan Java对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储（内存上的存储）。 然而使用数组存储对象存在一" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://fireflying.top/notepad/java/javanote/java-basic-study/target/classes/basic/collection/readme/" />

<meta itemprop="name" content="">
<meta itemprop="description" content="集合总结 copy from zengsiyan Java对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储（内存上的存储）。 然而使用数组存储对象存在一">

<meta itemprop="wordCount" content="13678">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="集合总结 copy from zengsiyan Java对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储（内存上的存储）。 然而使用数组存储对象存在一"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Firefly</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/notepad">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/notepad/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Firefly</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/notepad">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/notepad/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <div class="post-content">
    <h2 id="集合总结">集合总结</h2>
<blockquote>
<p>copy from zengsiyan</p>
</blockquote>
<p>Java对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储<font color=red>（内存上的存储）</font>。</p>
<p>然而使用数组存储对象存在一些弊端，因此，Java引入集合框架，实现<font color=red><strong>动态</strong></font>的存储对象的容器。</p>
<ul>
<li>首先，了解<font color=red>数组</font>的<strong>特点</strong>与<strong>局限性</strong>：</li>
</ul>
<blockquote>
<ul>
<li>数组在内存存储方面的特点：
<ul>
<li>数组初始化以后，<strong>长度就确定了</strong>。</li>
<li>数组声明的类型就决定了元素初始化的<strong>类型</strong>。</li>
</ul>
</li>
<li>数组在存储数据方面的弊端：
<ul>
<li>数组初始化以后长度不可改变，<strong>无法扩展</strong>。</li>
<li>数组提供的属性和方法相对较少，不便于增、删（或<strong>效率不高</strong>）</li>
<li>数组存储数据有序可重复（或<strong>存储数据的特点单一</strong>）</li>
</ul>
</li>
</ul>
</blockquote>
<p>而数组的弊端在Java集合上都得到了解决。</p>
<ul>
<li>Java集合分为<font color=red><strong>Collection接口</strong></font>和<font color=red><strong>Map接口</strong></font>两大块：</li>
</ul>
<p>$$
x \begin{cases}Collection：单列数据，定义了存取一组对象的方法的集合\\Map：双列数据，保存具有映射关系“key-value对”的集合\end{cases}
$$</p>
<p>​					
​</p>
<p><img src="assert/collection" alt="clooetion"></p>
<p><img src="assert/005PzEdegy1g5iw4w2ksuj30f6083gls.jpg" alt="map"></p>
<h2 id="1-list接口">1. List接口</h2>
<h3 id="11-arraylist源码分析">1.1 ArrayList源码分析</h3>
<ol>
<li><strong>底层的物理存储结构：</strong></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// non-private to simplify nested class access
</span><span class="c1"></span><span class="kd">transient</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">elementData</span><span class="o">;</span> 
</code></pre></td></tr></table>
</div>
</div><p>可见，ArrayList的物理存储结构为Object类型的数组——elementData。</p>
<p>然后，一个私有整型变量记录elementData中真实存放的元素的个数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * The size of the ArrayList (the number of elements it contains).
</span><span class="cm">  *
</span><span class="cm">  * @serial
</span><span class="cm">  */</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li><strong>构造器：</strong></li>
</ol>
<ul>
<li><strong>空参构造</strong>：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Constructs an empty list with an initial capacity of ten.
</span><span class="cm">  * 这个注释是JDK7的注释，如果是JDK7，那么这里会创建出一个默认长度为10的Object[]数组
</span><span class="cm">  * 而JDK8没有直接创建长度为10的数组。
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="nf">ArrayList</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 直接将elementData赋值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">elementData</span> <span class="o">=</span> <span class="n">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Shared empty array instance used for default sized empty instances. We
</span><span class="cm">  * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
</span><span class="cm">  * first element is added.
</span><span class="cm">  */</span>
<span class="c1">// DEFAULTCAPACITY_EMPTY_ELEMENTDATA是全局常量，长度为0的Object数组，JDK8这样做的好处是最大限度的节省了内存空间，它会等到真正添加元素时再创建数组。
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="o">=</span> <span class="o">{};</span>
</code></pre></td></tr></table>
</div>
</div><p>意即：调用ArrayList的空参构造器，底层会将全局常量（一个长度为0的Object数组）赋给elementData。</p>
<ul>
<li><strong>定容构造：</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Constructs an empty list with the specified initial capacity.
</span><span class="cm">  *
</span><span class="cm">  * @param  initialCapacity  the initial capacity of the list
</span><span class="cm">  * @throws IllegalArgumentException if the specified initial capacity
</span><span class="cm">  *         is negative
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="nf">ArrayList</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 初始容量大于0，那么创建指定容量的Object数组赋值给elementData
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">elementData</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">initialCapacity</span><span class="o">];</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>	<span class="c1">// 指定容量为0，将elementData赋值为空数组
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">elementData</span> <span class="o">=</span> <span class="n">EMPTY_ELEMENTDATA</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>	<span class="c1">// 指定容量为负数，抛出异常
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal Capacity: &#34;</span><span class="o">+</span>
                                           <span class="n">initialCapacity</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Shared empty array instance used for empty instances.
</span><span class="cm">  */</span>
<span class="c1">// 如果定容构造器的容量被指定为0，那么elementData也被赋值为一个全局常量。（长度为0的Object数组）。
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">EMPTY_ELEMENTDATA</span> <span class="o">=</span> <span class="o">{};</span>
</code></pre></td></tr></table>
</div>
</div><p>注意：</p>
<blockquote>
<p><font color=red><strong>EMPTY_ELEMENTDATA</strong></font> 与 <font color=red><strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong></font>均是长度为0的Object数组，且均是全局常量。</p>
<p>但是前者是在定容构造器容量为0时为elementData赋值（理论上的容量是0）。</p>
<p>后者是空参构造器为elementData赋值（理论上的容量是10，只是现在没有创建）。它实际上是在add时再创建。</p>
</blockquote>
<ol start="3">
<li><strong>add(E e)方法</strong></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Appends the specified element to the end of this list.
</span><span class="cm">  *
</span><span class="cm">  * @param e element to be appended to this list
</span><span class="cm">  * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add})
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ensureCapacityInternal</span><span class="o">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>  <span class="c1">// Increments modCount!!
</span><span class="c1"></span>    <span class="n">elementData</span><span class="o">[</span><span class="n">size</span><span class="o">++]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>		<span class="c1">// 容量满足需求了，那将指定的这个元素追加到原数组末尾
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>首先是确定增加一个元素后，需不需要扩容。然后在满足容量的elementData中新增元素便可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 将必须存储的最小容量值作为参数（minCapacity）传入，以判断是否有扩容的必要
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">ensureCapacityInternal</span><span class="o">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ensureExplicitCapacity</span><span class="o">(</span><span class="n">calculateCapacity</span><span class="o">(</span><span class="n">elementData</span><span class="o">,</span> <span class="n">minCapacity</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 计算一次容量，实际上是顺应空参构造中的DEFAULTCAPACITY_EMPTY_ELEMENTDATA
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">calculateCapacity</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">elementData</span><span class="o">,</span> <span class="kt">int</span> <span class="n">minCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这里就体现了JDK8与JDK7不同的地方，对于空参构造，JDK8是在这里为默认长度为10的Object开辟空间的。即如果elementData是被空参构造赋值过且数组未使用过，那么返回默认长度和最小长度中最大的那个值作为新的最小长度。
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">elementData</span> <span class="o">==</span> <span class="n">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// DEFAULT_CAPACITY是类中定义的全局常量，它的值为10
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">DEFAULT_CAPACITY</span><span class="o">,</span> <span class="n">minCapacity</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 如果elementData不是默认空参构造过未初始化的，那么直接返回最小容量
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">minCapacity</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">ensureExplicitCapacity</span><span class="o">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">modCount</span><span class="o">++;</span>
	
    <span class="c1">// overflow-conscious code
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">minCapacity</span> <span class="o">-</span> <span class="n">elementData</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span>	<span class="c1">// 判断是否有扩容的必要
</span><span class="c1"></span>        <span class="n">grow</span><span class="o">(</span><span class="n">minCapacity</span><span class="o">);</span>	<span class="c1">// 扩容方法的具体实现
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Increases the capacity to ensure that it can hold at least the
</span><span class="cm">  * number of elements specified by the minimum capacity argument.
</span><span class="cm">  *
</span><span class="cm">  * @param minCapacity the desired minimum capacity
</span><span class="cm">  */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">grow</span><span class="o">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// overflow-conscious code
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">oldCapacity</span> <span class="o">=</span> <span class="n">elementData</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>	<span class="c1">// 绑定原有长度
</span><span class="c1"></span>    <span class="c1">// 将新长度扩容为原有长度的1.5倍（原长+原长/2）
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">oldCapacity</span> <span class="o">+</span> <span class="o">(</span><span class="n">oldCapacity</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">);</span>
    <span class="c1">// 如果新长度还是小于最小容量，那么最小容量就作为新长度（默认空参构造会在这里被指定为10）
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">newCapacity</span> <span class="o">-</span> <span class="n">minCapacity</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
        <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">minCapacity</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">newCapacity</span> <span class="o">-</span> <span class="n">MAX_ARRAY_SIZE</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span>	<span class="c1">// 极端的大于整数界限的情况
</span><span class="c1"></span>        <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">hugeCapacity</span><span class="o">(</span><span class="n">minCapacity</span><span class="o">);</span>
    <span class="c1">// minCapacity is usually close to size, so this is a win:
</span><span class="c1"></span>    <span class="n">elementData</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">elementData</span><span class="o">,</span> <span class="n">newCapacity</span><span class="o">);</span>	<span class="c1">// 数组扩容方法，将elementData扩容为newCapacity，并且原有数据不变，返回值更新elementData
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>至此，ArrayList的一次add就完成了。</p>
<p><strong>小结：JDK8在处理ArrayList的空参构造上使用<font color=red>延迟创建</font>的方式，较大限度的节省了内存空间。</strong></p>
<h3 id="12-linkedlist源码分析">1.2 LinkedList源码分析</h3>
<ol>
<li><strong>底层的物理存储结构：</strong></li>
</ol>
<p>底层的物理存储结构是<font color=red>双向链表</font>，其定义了名为Node的内部类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// 三个属性元素、后序节点、前序节点
</span><span class="c1"></span>    <span class="n">E</span> <span class="n">item</span><span class="o">;</span>		
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">;</span>
	<span class="c1">// 构造器
</span><span class="c1"></span>    <span class="n">Node</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">,</span> <span class="n">E</span> <span class="n">element</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">element</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>LinkedList中比较核心的<font color=red>三个属性</font>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">transient</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>		<span class="c1">// 记录双向链表中元素的个数
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Pointer to first node.
</span><span class="cm">  * Invariant: (first == null &amp;&amp; last == null) ||
</span><span class="cm">  *            (first.prev == null &amp;&amp; first.item != null)
</span><span class="cm">  */</span>
<span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">;</span>	<span class="c1">// 标识双向链表中第一个元素所在的节点
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Pointer to last node.
</span><span class="cm">  * Invariant: (first == null &amp;&amp; last == null) ||
</span><span class="cm">  *            (last.next == null &amp;&amp; last.item != null)
</span><span class="cm">  */</span>
<span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">last</span><span class="o">;</span>		<span class="c1">// 标识双向链表中最后一个元素所在的节点
</span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li><strong>构造器：</strong></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Constructs an empty list.
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="nf">LinkedList</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如上，空参构造器调Object的空参构造，它们什么都不会做，也就是那三个属性都将是默认值：</p>
<blockquote>
<ul>
<li>
<p>size = 0;</p>
</li>
<li>
<p>first = null;</p>
</li>
<li>
<p>last = null;</p>
</li>
</ul>
</blockquote>
<ol start="3">
<li><strong>add(E e)：</strong></li>
</ol>
<p>因为双向链表本身就是动态的，因此不在需要频繁的去考虑扩容、缩容等问题了。其add方法就是新建一个节点，然后将这个节点的指针与链表末尾节点的指针绑定好就可以了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Appends the specified element to the end of this list.
</span><span class="cm">  *
</span><span class="cm">  * &lt;p&gt;This method is equivalent to {@link #addLast}.
</span><span class="cm">  *
</span><span class="cm">  * @param e element to be appended to this list
</span><span class="cm">  * @return {@code true} (as specified by {@link Collection#add})
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">linkLast</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>	<span class="c1">// 在双向链表的尾部添加元素
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Links e as last element.
</span><span class="cm">  */</span>
<span class="kt">void</span> <span class="nf">linkLast</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>		<span class="c1">// 绑定双向链表的尾节点
</span><span class="c1"></span>    <span class="c1">// 创建待添加的新节点，前序节点为双向链表的尾节点，后序节点为空
</span><span class="c1"></span>    <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;(</span><span class="n">l</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>	
    <span class="c1">// 更新双向链表的尾节点
</span><span class="c1"></span>    <span class="n">last</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="c1">// 如果原双向链表为空（原尾节点为null代表链表空）
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>	<span class="c1">// 那么首节点和尾节点都会指向这个新增的第一个节点
</span><span class="c1"></span>    <span class="k">else</span>					<span class="c1">// 如果原双向链表非空，那么原尾节点的后续指向新增节点
</span><span class="c1"></span>        <span class="n">l</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="n">size</span><span class="o">++;</span>					<span class="c1">// 双向链表元素个数加一
</span><span class="c1"></span>    <span class="n">modCount</span><span class="o">++;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="13-collectionssynchronizedlist和vector的区别">1.3 Collections.SynchronizedList和Vector的区别</h3>
<ul>
<li>
<p>如果使用add方法，那么他们的扩容机制不一样。</p>
</li>
<li>
<p>SynchronizedList可以指定锁定的对象。</p>
</li>
</ul>
<p>（Collections.SynchronizedList只是使用同步代码块包裹了ArrayList的方法，而ArrayList和Vector中同名方法的方法体内容并无太大差异，所以在锁定范围和锁的作用域上两者并无却别。 在锁定的对象区别上，SynchronizedList的同步代码块锁定的是mutex对象，Vector锁定的是this对象。那么mutex对象是SynchronizedList在使用构造函数时可以传入一个Object,如果在调用的时候显示的传入一个对象，那么锁定的就是用户传入的对象。如果没有指定，那么锁定的也是this对象。）</p>
<h2 id="2-set接口">2. Set接口</h2>
<ul>
<li>
<p>Set接口继承了Collection接口，而且Set接口内没有额外的提供方法。</p>
</li>
<li>
<p>Set接口代表了<strong>无序、不可重复</strong>的集合。</p>
</li>
<li>
<p>Set的主要实现类有：<font color=red>HashSet、LinkedHashSet、TreeSet</font>。</p>
</li>
</ul>
<blockquote>
<ul>
<li>HashSet：
<ul>
<li>Set接口的主要实现类。</li>
<li>线程不安全，效率高。</li>
<li>能够存储null值。</li>
</ul>
</li>
<li>LinkedHashSet：
<ul>
<li>是HashSet的子类。</li>
<li>以链表的方式组织，可以<font color=red>按照添加时的顺序</font>遍历LinkedHashSet中的数据。</li>
</ul>
</li>
<li>TreeSet：
<ul>
<li>底层使用HashMap，即，实际采用<font color=red><strong>红黑树</strong></font>存储。</li>
<li>要求TreeSet中存放的对象均属于同一个类。</li>
<li>可以按照对象指定的属性进行排序。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>理解Set的无序性：</strong></li>
</ul>
<blockquote>
<p>Set的无序性不等同于随机性，它存储的数据在底层不是依次存放的，<font color=red>而是根据数据的Hash值决定元素的存放位置。</font></p>
</blockquote>
<ul>
<li><strong>理解Set的不可重复性：</strong></li>
</ul>
<blockquote>
<p>Set中保证添加的元素在使用equals()方法判断时不能返回true，即相同的元不能被添加进来。</p>
<p><font color=red><strong>注意</strong>：Set判断重复元素的方法是先根据hashCode方法返回的hash值确定元素要存放的位置索引，然后再与具有相同索引的所有元素去equals()。</font>这样做可以大大减少比较次数，提高效率。</p>
</blockquote>
<p><strong><font color=red>由此也可知，Set中存放的元素类型应该是重写了equals()和hashCode()的类型。意即，使用HashSet及其子类，必定需要重写equals()和hashCode()方法，而且equals()和hashCode()方法的重写应当要满足相等的对象应该具有相等的hash值的原则。</font></strong></p>
<h3 id="21-重写hashcode">2.1 重写hashCode()</h3>
<p>使用IDEA自动重写hashCode()方法时，会发现有系数<font color=red>31</font>，原因：</p>
<ul>
<li>选择系数的时候要选择尽量大的系数，因为如果计算出来的hash地址越大，所谓的“冲突”就会越少，查找起来的效率就会越高。<font color=red>(所以一般要乘以一个系数)</font></li>
<li>并且31只占用5bits，<strong>相乘造成数据溢出的概率较小</strong>。</li>
<li>i*31可以由<font color=red>( i &laquo; 5 ) - 1</font>来表示，现在很多虚拟机都有相关的优化，能够提高算法效率。</li>
<li>31是一个素数，素数的作用就是某个数乘以一个素数，那么结果只能被被乘数、素数本身和1整除，同样可以减少冲突。</li>
</ul>
<p>比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span><span class="o">{</span>
    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="n">Person</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">age</span> <span class="o">==</span> <span class="n">person</span><span class="o">.</span><span class="na">age</span> <span class="o">&amp;&amp;</span>
                <span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">person</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="o">}</span>
	<span class="c1">// 重写Object类的hashCode方法
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Object.hash(name, age)实际上调用的是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="n">Object</span><span class="o">...</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>	<span class="c1">// 可变长参数
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">values</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="n">Object</span> <span class="n">a</span><span class="o">[])</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
    <span class="c1">// 这里可见其生成hash值的过程
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="n">element</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span>
        <span class="c1">// 如果elemenet是null，那么返回0，如果不是那么返回这个类型重写的hashCode值然后与乘了31的result进行累和
</span><span class="c1"></span>        <span class="n">result</span> <span class="o">=</span> <span class="n">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="o">(</span><span class="n">element</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">element</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>重写hashCode与equals应该要具有一致性，即<font color=red><strong>equals()中比较的属性在hashCode中也要用到。</strong></font></li>
</ul>
<h3 id="22--主要实现类">2.2  主要实现类</h3>
<ol>
<li><strong>HashSet</strong></li>
</ol>
<ul>
<li>HashSet底层是以<font color=red>”数组+链表“</font>的方式实现的。</li>
<li>HashSet中元素添加的过程：<strong>【必须理解这个过程，这也是HashMap的过程】</strong></li>
</ul>
<blockquote>
<ul>
<li>想要在HashSet中添加元素a，那么<strong>首先要调用元素a所在类的hashCode方法</strong>，计算元素a的hash值。</li>
<li>此hash值通过某种hash函数确定（计算出）<strong>HashSet底层数组中的存放位置</strong>。判断该位置是否有其他元素。
<ul>
<li>如果没有其他元素，那么直接添加，返回<font color=red><strong>添加成功</strong></font>。</li>
<li>如果有其他元素<font color=red><strong>（并且这些元素会以链表形式存放）</strong></font>，那么针对链表上的每个元素调用a元素所在类的equals方法<font color=red>比较两个元素内容是否相等</font>
<ul>
<li>如果equals返回true，那么<font color=red><strong>添加失败</strong></font>。</li>
<li>a.equals(链上所有元素)均返回false，那么元素a**<font color=red>添加成功</font>**。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<ol start="2">
<li><strong>LinkedHashSet</strong></li>
</ol>
<p>LinkedHashSet作为HashSet的子类，在添加数据<font color=red>（添加数据的操作与HashSet一样）</font>的同时每个数据还维护了<font color=red>两个引用</font>，记录此数据的前序数据和后序数据。</p>
<p>优点： 在需要对集合进行频繁的遍历时，LinkedHashSet效率高于HashSet。</p>
<ol start="3">
<li><strong>TreeSet</strong></li>
</ol>
<ul>
<li>
<p>TreeSet的底层实现是红黑树。</p>
</li>
<li>
<p>向TreeSet中添加的元素必须是同一个类的对象。（因为TreeSet是实现排序类的，如果要排序，那么集合中存储的元素应该都具有相同的属性）。</p>
</li>
<li>
<p>使用TreeSet的空参构造 —— 自然排序。</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="n">Comparable</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Person{&#34;</span> <span class="o">+</span>
                <span class="s">&#34;name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
                <span class="s">&#34;, age=&#34;</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span>
                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="n">Person</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Person</span> <span class="n">that</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;illegal argument!&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 空参构造，以自然排序为依据
</span><span class="c1"></span>    <span class="n">Set</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeSet</span><span class="o">();</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;tina&#34;</span><span class="o">,</span> <span class="n">15</span><span class="o">));</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;tony&#34;</span><span class="o">,</span> <span class="n">19</span><span class="o">));</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;kobe&#34;</span><span class="o">,</span> <span class="n">23</span><span class="o">));</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;jhon&#34;</span><span class="o">,</span> <span class="n">17</span><span class="o">));</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;jhon&#34;</span><span class="o">,</span> <span class="n">13</span><span class="o">));</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">set</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">jhon</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">17</span><span class="o">}</span>
<span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">kobe</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">23</span><span class="o">}</span>
<span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">tina</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">15</span><span class="o">}</span>
<span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">tony</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">19</span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>分析：</p>
<blockquote>
<p>输出的结果中，最后一条记录new Person(&ldquo;jhon&rdquo;, 13)没有加入集合。原因：</p>
<ul>
<li><strong><font color=red>特别注意</font></strong>，如果TreeSet中的元素使用的是自然排序（实现Comparable接口），<font color=red>那么TreeSet认为比较两个元素是否相等的标准为Comparable接口中compareTo方法的返回值（返回值为0则相等，不为0则不等）</font>。不再是equals方法了。然而，TreeSet中是不允许存放相等的元素的（这是Set集合的共性），所以最后这条名为jhon的记录就没有被添加到集合中。</li>
</ul>
</blockquote>
<ul>
<li>使用TreeSet的比较器构造 —— 定制排序</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 不让Person类实现Comparable接口，而是在实例化TreeSet对象的时候使用Comparator构造器，便可实现定制排序。
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 将Comparator实现类的对象作为参数来实现定制排序
</span><span class="c1"></span>    <span class="n">Set</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeSet</span><span class="o">(</span><span class="k">new</span> <span class="n">Comparator</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Object</span> <span class="n">o1</span><span class="o">,</span> <span class="n">Object</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o1</span> <span class="k">instanceof</span> <span class="n">Person</span> <span class="o">&amp;&amp;</span> <span class="n">o2</span> <span class="k">instanceof</span> <span class="n">Person</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Person</span> <span class="n">person1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">o1</span><span class="o">;</span>
                <span class="n">Person</span> <span class="n">person2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Person</span><span class="o">)</span> <span class="n">o2</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">person1</span><span class="o">.</span><span class="na">age</span><span class="o">,</span> <span class="n">person2</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;illegal argument!&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">});</span>

    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;tina&#34;</span><span class="o">,</span> <span class="n">15</span><span class="o">));</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;tony&#34;</span><span class="o">,</span> <span class="n">19</span><span class="o">));</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;kobe&#34;</span><span class="o">,</span> <span class="n">23</span><span class="o">));</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;jhon&#34;</span><span class="o">,</span> <span class="n">17</span><span class="o">));</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;jhon&#34;</span><span class="o">,</span> <span class="n">13</span><span class="o">));</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">set</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>同样，使用定制排序来实例化TreeSet对象，它内部比较两个元素是否相等的依据也是比较器中compare方法，而不是equals。</li>
<li>其实**<font color=red>排序的属性不能重复</font>**的原理很简单，**因为TreeSet底层是红黑树实现的（二叉树），父节点的左子节点必定小于父节点，右子节点必定大于父节点。不会存在两个节点相同的情况！**</li>
</ul>
<h3 id="23-面试题">2.3 面试题</h3>
<p>假设Person类重写了equals()与hashCode()方法，考虑如下程序的运行结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">HashSet</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>
    <span class="n">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="n">1001</span><span class="o">,</span> <span class="s">&#34;AA&#34;</span><span class="o">);</span>
    <span class="n">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="n">1002</span><span class="o">,</span> <span class="s">&#34;BB&#34;</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p1</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p2</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span>
    <span class="n">p1</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">&#34;CC&#34;</span><span class="o">;</span>
    <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">p1</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="n">1001</span><span class="o">,</span> <span class="s">&#34;CC&#34;</span><span class="o">));</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="n">1001</span><span class="o">,</span> <span class="s">&#34;AA&#34;</span><span class="o">));</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="o">[</span><span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">BB</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">1002</span><span class="o">},</span> <span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">AA</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">1001</span><span class="o">}]</span>
<span class="o">[</span><span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">BB</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">1002</span><span class="o">},</span> <span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">CC</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">1001</span><span class="o">}]</span>
<span class="o">[</span><span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">BB</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">1002</span><span class="o">},</span> <span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">CC</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">1001</span><span class="o">},</span> <span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">CC</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">1001</span><span class="o">}]</span>
<span class="o">[</span><span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">BB</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">1002</span><span class="o">},</span> <span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">CC</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">1001</span><span class="o">},</span> <span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">CC</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">1001</span><span class="o">},</span> <span class="n">Person</span><span class="o">{</span><span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">AA</span><span class="err">&#39;</span><span class="o">,</span> <span class="n">age</span><span class="o">=</span><span class="n">1001</span><span class="o">}]</span>
</code></pre></td></tr></table>
</div>
</div><p>分析：</p>
<blockquote>
<ul>
<li>第一行输出没有疑问，显然p1和p2的哈希值是不同的，直接输出集合中的两个元素p1和p2。</li>
<li>程序在执行p1.name = &ldquo;CC&rdquo;;后再去调用remove方法，那么系统就会根据p1对象生成的新的哈希值去找底层存储p1对象的位置。
<ul>
<li>然而，<font color=red>之前存放位置的哈希值是根据AA生成的，现在是以CC生成的哈希值去寻找，自然位置不同，那么HashSet会认为集合中根本就没有这个p1这个对象，</font>因此直接没有进行删除操作。所以得到第二行的输出。</li>
</ul>
</li>
<li>程序在执行set.add(new Person(1001, &ldquo;CC&rdquo;));后，会根据1001和CC两个属性去生成哈希值，然后去存放这个新的Person对象。
<ul>
<li>然而之前的程序并<font color=red>没有在这个哈希值的位置存放任何内容</font>，因此这个对象将被成功放入集合中。所以得到第三行输出。</li>
</ul>
</li>
<li>程序在执行set.add(new Person(1001, &ldquo;AA&rdquo;));后，会根据1001和AA两个属性生成哈希值，然后去存放这个新的Person对象。
<ul>
<li>然而这个位置已经存放了对象Person(1001, &ldquo;CC&rdquo;)，<font color=red>因此系统会转而去判断equals()的返回值</font>。很显然，返回值为false，因此Person(1001, &ldquo;AA&rdquo;)对象被成功添加到集合中。所以得到第四行输出。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3-map接口">3. Map接口</h2>
<p>Map接口作为双列数据的主接口，主要用于存放键值对数据。</p>
<p>Map接口的主要实现类：</p>
<blockquote>
<ul>
<li>HashMap：作为Map接口的<font color=red>主要实现类</font>。线程不安全，效率高。能够存储null的key和value。<font color=red>底层实现，JDK7为数组+链表，JDK8为数组+链表+红黑树。</font>
<ul>
<li>LinkedHashMap：HashMap的子类。保证在遍历Map元素时，可以按照添加的顺序实现遍历**（原因，在HashMap的底层结构基础上，添加了一对指针，指向前一个和后一个元素）**。<font color=red>对于频繁的遍历操作，此类的执行效率高于HashMap。</font></li>
</ul>
</li>
<li>TreeMap：保证按照添加的key-value对进行排序，实现排序遍历。排序依据为key（比较key是唯一的、不重复的）。<font color=red>底层使用红黑树实现。</font></li>
<li>Hashtable：作为Map接口的古老实现类。线程安全，效率相对较低。不能够存储null的key和value。<font color=red>（基本不会使用，即使需要线程安全的也会找Collections的方法替代）</font>
<ul>
<li>Properties：Hashtable的子类，其key和value都是String类型的。常用来处理配置文件。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>理解Map结构</strong></li>
</ul>
<p>$$
\begin{cases}</p>
<ol>
<li>key\<br>
\</li>
<li>value\<br>
\</li>
<li>Entry
\end{cases}
$$</li>
</ol>
<blockquote>
<ul>
<li><strong><font color=red>key 是无序的不可重复的，其主要使用Set来存储所有的key</font></strong>。但是具体是什么类型的Set就要看是什么类型的Map了。（比如，如果是HashMap，那么key就用HashSet，如果是LinkedHasMap，那么key就用LinkedHashSet）。</li>
<li><strong><font color=red>value是无序可重复的</font></strong>，泛泛来说就是用Collection存储的。</li>
<li>**<font color=red>Entry是无序不可重复的，</font>**使用Set进行存储。注意，一个key-value(键值对)就构成一个Entry对象。</li>
</ul>
</blockquote>
<h3 id="31-hashmap源码分析">3.1 HashMap源码分析</h3>
<ul>
<li>
<p>JDK7的与JDK8的HashMap实现略有不同，主要以JDK8为准，然后选择性提示JDK7中的区别部分。</p>
</li>
<li>
<p>JDK8中HashMap的底层实现主要是：<font color=red>数组 + 链表 + 红黑树</font>。</p>
</li>
</ul>
<p>HashMap中一些主要常量与结构：</p>
<ul>
<li>常量：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * The default initial capacity - MUST be a power of two.
</span><span class="cm">  * 全局常量，默认初始化数组容量，定义为16.
</span><span class="cm">  */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">4</span><span class="o">;</span> <span class="c1">// aka 16
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * The maximum capacity, used if a higher value is implicitly specified
</span><span class="cm">  * by either of the constructors with arguments.
</span><span class="cm">  * MUST be a power of two &lt;= 1&lt;&lt;30.
</span><span class="cm">  * 全局常量，数组能够承受的最大容量，定义为2^30。
</span><span class="cm">  */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">30</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * The load factor used when none specified in constructor.
</span><span class="cm">  * 全局常量，默认加载因子0.75，其作用是用于判断数组是否需要扩容
</span><span class="cm">  */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">float</span> <span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="n">0</span><span class="o">.</span><span class="na">75f</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * The bin count threshold for using a tree rather than list for a
</span><span class="cm">  * bin.  Bins are converted to trees when adding an element to a
</span><span class="cm">  * bin with at least this many nodes. The value must be greater
</span><span class="cm">  * than 2 and should be at least 8 to mesh with assumptions in
</span><span class="cm">  * tree removal about conversion back to plain bins upon
</span><span class="cm">  * shrinkage.
</span><span class="cm">  * 全局常量，如果某个数组位置的链表长度大于这个默认阈值8，那么就将链表转化成红黑树
</span><span class="cm">  */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="n">8</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * The bin count threshold for untreeifying a (split) bin during a
</span><span class="cm">  * resize operation. Should be less than TREEIFY_THRESHOLD, and at
</span><span class="cm">  * most 6 to mesh with shrinkage detection under removal.
</span><span class="cm">  * 全局常量，如果某个数组位置的红黑树节点个数小于这个阈值，那么就将红黑树转换成链表
</span><span class="cm">  */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">UNTREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="n">6</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>结构</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * basic hash bin node, used for most entries.  (See below for
</span><span class="cm">  * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
</span><span class="cm">  * 静态内部类，存放键值对的基本结构Node（JDK7直接是Entry类），Node同样也是实现了Map.Entry接口。
</span><span class="cm">  * 主要的属性是一个标识Node的hash值，一个键，一个值，一个指向下一节点的引用。
</span><span class="cm">  */</span>
<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>
    <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span>	<span class="c1">// 注意，键赋值后不能改变，值可以改变
</span><span class="c1"></span>    <span class="n">V</span> <span class="n">value</span><span class="o">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
	<span class="c1">// 构造方法
</span><span class="c1"></span>    <span class="n">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
	<span class="c1">// get方法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">K</span> <span class="nf">getKey</span><span class="o">()</span>        <span class="o">{</span> <span class="k">return</span> <span class="n">key</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">V</span> <span class="nf">getValue</span><span class="o">()</span>      <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
    <span class="c1">// 重写toString方法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">key</span> <span class="o">+</span> <span class="s">&#34;=&#34;</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
	<span class="c1">// 重写hashCode
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">^</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
	<span class="c1">// set方法（只有value能够set，key不能set）
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">V</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">V</span> <span class="n">newValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
    <span class="o">}</span>
	<span class="c1">// 重写equals()方法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,?&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,?&gt;)</span><span class="n">o</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">())</span> <span class="o">&amp;&amp;</span>
                <span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">()))</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * The table, initialized on first use, and resized as
</span><span class="cm">  * necessary. When allocated, length is always a power of two.
</span><span class="cm">  * (We also tolerate length zero in some operations to allow
</span><span class="cm">  * bootstrapping mechanics that are currently not needed.)
</span><span class="cm">  * 核心数组。Node&lt;K,V&gt;类型的数组
</span><span class="cm">  */</span>
<span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Holds cached entrySet(). Note that AbstractMap fields are used
</span><span class="cm">  * for keySet() and values().
</span><span class="cm">  * 键的存放是以Set的方式（不可重复是关键）
</span><span class="cm">  */</span>
<span class="kd">transient</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">entrySet</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * The number of key-value mappings contained in this map.
</span><span class="cm">  * 真实元素的长度
</span><span class="cm">  */</span>
<span class="kd">transient</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * The next size value at which to resize (capacity * load factor).
</span><span class="cm">  * 判断数组是否需要扩容的阈值
</span><span class="cm">  * @serial
</span><span class="cm">  */</span>
<span class="c1">// (The javadoc description is true upon serialization.
</span><span class="c1">// Additionally, if the table array has not been allocated, this
</span><span class="c1">// field holds the initial array capacity, or zero signifying
</span><span class="c1">// DEFAULT_INITIAL_CAPACITY.)
</span><span class="c1"></span><span class="kt">int</span> <span class="n">threshold</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * The load factor for the hash table.
</span><span class="cm">  * 加载因子，主要用于判断数组是否需要扩容
</span><span class="cm">  * @serial
</span><span class="cm">  */</span>
<span class="kd">final</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li><strong><font color=red>空参构造</font></strong></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity
</span><span class="cm">  * (16) and the default load factor (0.75).
</span><span class="cm">  * 这些注释是JDK7的，如果是JDK7，那么空参构造就会创建一个Entry数组，且默认初始长度为16
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 空参构造中只是简单的指示下加载因子为DEFAULT_LOAD_FACTOR（0.75）; 
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">;</span> <span class="c1">// all other fields defaulted
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li><font color=red><strong>定容构造</strong></font></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial 
</span><span class="cm">  * capacity and the default load factor (0.75).
</span><span class="cm">  *
</span><span class="cm">  * @param  initialCapacity the initial capacity.
</span><span class="cm">  * @throws IllegalArgumentException if the initial capacity is negative.   
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 给定默认的加载因子后，转而调用带加载因子的构造器
</span><span class="c1"></span>    <span class="k">this</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial
</span><span class="cm">  * capacity and load factor.
</span><span class="cm">  *
</span><span class="cm">  * @param  initialCapacity the initial capacity
</span><span class="cm">  * @param  loadFactor      the load factor
</span><span class="cm">  * @throws IllegalArgumentException if the initial capacity is negative
</span><span class="cm">  *         or the load factor is nonpositive
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 给定初始容量小于0，抛非法参数异常
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal initial capacity: &#34;</span> <span class="o">+</span>
                                           <span class="n">initialCapacity</span><span class="o">);</span>
    <span class="c1">// 给定初始容量大于数组最大，那么数组最大就作为初始常量
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span>
        <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">;</span>
    <span class="c1">// 如果加载因子小于0或加载因子不是合法的浮点数，抛非法参数异常
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="o">||</span> <span class="n">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal load factor: &#34;</span> <span class="o">+</span>
                                           <span class="n">loadFactor</span><span class="o">);</span>
    <span class="c1">// 为加载因子赋值，并计算阈值（数组是否需要扩容的阈值）
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>
<p>loadFactor与threshold的值直接决定数组是否需要扩容。</p>
</li>
<li>
<p>HashMap的扩容不是简单的数组用完了就扩，因为由于Hash冲突等原因，可能在某个数组的索引位置，一个链会拉的很长很长。而其余的数组索引根本就没有使用。所以要引入加载因子。</p>
</li>
<li>
<p><font color=red>加载因子太大可能导致一个位置上链很长，加载因子太小可能导致数组的利用率太低。</font>可能根据统计学的等计算加载因子为0.75时较合适。</p>
</li>
</ul>
</blockquote>
<ol start="3">
<li><font color=red><strong>put方法</strong></font></li>
</ol>
<p>可以发现，不论是空参构造，还是两个定容构造，HashMap构造器中并没有创建核心的底层数组。这是JDK8区别与JDK7的地方（JDK7是直接在构造器中就创建了）。与之前的ArrayList类似，JDK8使用了<font color=red>延迟创建机制</font>，<strong>它会在真正需要使用数组的时候再去创建数组，目的是最大限度的减少了内存空间</strong>。</p>
<p>HashMap的put方法主要考虑三个方面的问题：<font color=red>底层数组的创建、数组扩容、红黑树转换</font>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Associates the specified value with the specified key in this map.
</span><span class="cm">  * If the map previously contained a mapping for the key, the old
</span><span class="cm">  * value is replaced.
</span><span class="cm">  *
</span><span class="cm">  * @param key key with which the specified value is to be associated
</span><span class="cm">  * @param value value to be associated with the specified key
</span><span class="cm">  * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
</span><span class="cm">  *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.
</span><span class="cm">  *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map
</span><span class="cm">  *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
</span><span class="cm">  * put方法的最外层调用，注意，他是有返回值的，如果当前添加的键值对的键在map中已经存在，那么将旧值替换为新值，并且返回旧值。如果不存在，那么返回null。
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="cm">/** 转而调用putVal方法完成处理，参数是：
</span><span class="cm">      * 根据key计算得到的hash值
</span><span class="cm">      * key
</span><span class="cm">      * value
</span><span class="cm">      * 后面两个忽略。。
</span><span class="cm">      **/</span>
    <span class="k">return</span> <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Implements Map.put and related methods.
</span><span class="cm">  * 该方法是实现put方法的主体，主要流程如下：
</span><span class="cm">  * 	1. 看是否是没有初始化的数组。如果是，那么就转到扩容方法进行初始化。
</span><span class="cm">  * 	2. 计算hash值对应的数组索引位置，如果该位置上没有元素，直接插入成功。
</span><span class="cm">  * 	3. 如果有元素了，那么用当前key的hash值和该索引位置上链表的所有节点的hash值进行比较。如果全都不同，那么插入成功。如果其中有相同的，那么比较调用当前节点的equals()方法进行比较，如果equals()返回false，那么仍然可以插入，如果equals（）返回true那么用当前节点的value去更新旧值。
</span><span class="cm">  * @param hash hash for key
</span><span class="cm">  * @param key the key
</span><span class="cm">  * @param value the value to put
</span><span class="cm">  * @param onlyIfAbsent if true, don&#39;t change existing value
</span><span class="cm">  * @param evict if false, the table is in creation mode.
</span><span class="cm">  * @return previous value, or null if none
</span><span class="cm">  */</span>
<span class="kd">final</span> <span class="n">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span>
               <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 创建一个tab作为属性table的副本，节点p用来作为某个节点的副本
</span><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
    <span class="c1">// 如果属性table为空，或者map的长度为0，那么就表示底层数组没有初始化，转而就去调扩容方法来将数组进行初始化。
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
    <span class="c1">// 节点p指向key的hash值计算得到的数组索引位置上的节点，如果这个索引位置上没有元素
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="c1">// 那么直接调用插入方法，将新节点插入在这个索引位置上
</span><span class="c1"></span>        <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// 如果计算得到的数组索引上有元素了
</span><span class="c1"></span>        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span> <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
        <span class="c1">// 如果链表上的头结点和待插入节点的hash值相等且equals也是true，那么后面是直接会执行更新value操作的，这里给e赋值是标志。
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="c1">// 如果这个数组索引上不是链表而是红黑树，那么调用红黑树的put操作
</span><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 如果待插入节点和头结点没有同一个key，那么比较链表上之后的所有节点的hash值和equals方法。
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 如果全部比较完，还是没有相同的key那么这里e会是null（就是需要直接插入的情况）
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 将新节点插在链表最末尾（七上八下，JDK7是插在头节点前面，JDK8是插在最末尾）
</span><span class="c1"></span>                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                    <span class="c1">// 判断一下新节点插入后，链表是否需要转化称红黑树
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="c1">// -1 for 1st
</span><span class="c1"></span>                        <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// 如果存在与待插入节点相等的key
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="c1">// 循环增量
</span><span class="c1"></span>                <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// e有值，那就是存在与待插入的节点相同的key，那么执行更新旧value的操作
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// existing mapping for key
</span><span class="c1"></span>            <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
    <span class="c1">// 如果执行了直接插入的操作，那么这里判断一下要不要扩容。且插入节点（没有更新旧value）返回null
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="n">resize</span><span class="o">();</span>
    <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>有一点需要注意</strong>，<font color=red>即使是同一个数组索引位置上同一链表上的节点，也是会hash值不同的，而且很常见。</font>因为这个索引位置的确定是通过hash值取与运算得到的，所以任然有将待插入元素的key与链表上的所有元素的key比较hash值的必要。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Initializes or doubles table size.  If null, allocates in
</span><span class="cm">  * accord with initial capacity target held in field threshold.
</span><span class="cm">  * Otherwise, because we are using power-of-two expansion, the
</span><span class="cm">  * elements from each bin must either stay at same index, or move
</span><span class="cm">  * with a power of two offset in the new table.
</span><span class="cm">  * 数组扩容的主体方法
</span><span class="cm">  * @return the table
</span><span class="cm">  */</span>
<span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="nf">resize</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// oldTab作为属性table的副本
</span><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="c1">// 如果是空参构造来的这里（数组没有赋值），那么原容量为0，否则就是取原数组的容量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">oldCap</span> <span class="o">=</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">oldTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="c1">// 属性阈值的副本oldThr
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">oldThr</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">newCap</span><span class="o">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="c1">// 如果不是还未使用过的数组
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 如果原容量已经（或者大于）最大容量了
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 那么容量不变，阈值更新为整型的最大值
</span><span class="c1"></span>            <span class="n">threshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">oldTab</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 否则，新容量扩容为原来的两倍。
</span><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">newCap</span> <span class="o">=</span> <span class="n">oldCap</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span>
                 <span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">)</span>
            <span class="c1">// 如果扩容后小于最大容量，并且原容量是大于默认容量的，那么将阈值扩大一倍（原来的两倍）
</span><span class="c1"></span>            <span class="n">newThr</span> <span class="o">=</span> <span class="n">oldThr</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">;</span> <span class="c1">// double threshold
</span><span class="c1"></span>    <span class="o">}</span>
    <span class="c1">// 定容构造器初始化了阈值，但是如果数组未定义过，因此数组新容量取阈值
</span><span class="c1"></span>    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">oldThr</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// initial capacity was placed in threshold
</span><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">oldThr</span><span class="o">;</span>
    <span class="c1">// 空参构造来到这里（数组没定义过，阈值没初始化过）
</span><span class="c1"></span>    <span class="k">else</span> <span class="o">{</span>               <span class="c1">// zero initial threshold signifies using defaults
</span><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span>	<span class="c1">// 新容量为默认容量值：16
</span><span class="c1"></span>        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 如果新阈值为0，（定容构造调用会来到这里）那么，重新计算阈值
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">newThr</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>	
        <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">newCap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">;</span>
        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">MAXIMUM_CAPACITY</span> <span class="o">?</span>
                  <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">ft</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 将属性阈值更新
</span><span class="c1"></span>    <span class="n">threshold</span> <span class="o">=</span> <span class="n">newThr</span><span class="o">;</span>
    <span class="c1">// 容量确定后，用新容量创建新的底层数组，然后完成将原有数组中的元素嫁接到新数组中的一系列工作
</span><span class="c1"></span>    <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">&#34;rawtypes&#34;</span><span class="o">,</span><span class="s">&#34;unchecked&#34;</span><span class="o">})</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">newCap</span><span class="o">];</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="o">;</span>		<span class="c1">// 数组统一是在这里造的
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldCap</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">newTab</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">-</span> <span class="n">1</span><span class="o">)]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
                    <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">e</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">newTab</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">oldCap</span><span class="o">);</span>
                <span class="k">else</span> <span class="o">{</span> <span class="c1">// preserve order
</span><span class="c1"></span>                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
                    <span class="k">do</span> <span class="o">{</span>
                        <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">oldCap</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                                <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="k">else</span>
                                <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="k">else</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                                <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="k">else</span>
                                <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">oldCap</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">newTab</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="32-linkedhashmap源码分析">3.2 LinkedHashMap源码分析</h3>
<p>搞懂HashMap的底层实现后LinkedHashMap的底层实现就很简单了。</p>
<p><font color=red>LinkedHashMap是HashMap的子类，而且LinkedHashMap中很方法并没有重写，而是直接用了父类的方法。</font>因此只需重点关注不同部分。</p>
<ul>
<li>空参构造</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance
</span><span class="cm">  * with the default initial capacity (16) and load factor (0.75).
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="nf">LinkedHashMap</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">();</span>	<span class="c1">// 直接调的父类HashMap的空参构造方法
</span><span class="c1"></span>    <span class="n">accessOrder</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>定容构造</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance
</span><span class="cm">  * with the specified initial capacity and a default load factor (0.75).
</span><span class="cm">  *
</span><span class="cm">  * @param  initialCapacity the initial capacity
</span><span class="cm">  * @throws IllegalArgumentException if the initial capacity is negative
</span><span class="cm">  */</span>
<span class="kd">public</span> <span class="nf">LinkedHashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>	<span class="c1">// 同样是父类HashMap定容构造方法
</span><span class="c1"></span>    <span class="n">accessOrder</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因此，重点关注他的put方法如何实现在遍历Map元素时，可以按照添加的顺序实现遍历便可了。</p>
<p>但是</p>
<blockquote>
<ul>
<li>LinkedHashMap没有重写父类的put方法，因此子类对象调用put方法是直接去调的父类的put方法。</li>
<li>LinkedHashMap也没有重写父类的putValue方法，因此也是直接用的父类方法。</li>
</ul>
</blockquote>
<p>但是，LinkedHashMap重写了父类的newNode方法，即，在向数组（或数组索引位置上的链表）添加元素时，会调用子类自己的newNode方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">newNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 调的是LinkedHashMap中自定义的结构Entry
</span><span class="c1"></span>    <span class="n">LinkedHashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span>
        <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="n">linkNodeLast</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm">  * HashMap.Node subclass for normal LinkedHashMap entries.
</span><span class="cm">  * Entry是HashMap中Node结构的子类，它继承了父类Node的结构外还定义了两个指针before和after，这样就在底层数组存放的同时，一个指向他的前序一个指向它的后序。
</span><span class="cm">  */</span>
<span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">before</span><span class="o">,</span> <span class="n">after</span><span class="o">;</span>
    <span class="n">Entry</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>意即，虽然LinkedHashMap底层的存储仍然是数组+链表+红黑树，<font color=red>但是每个元素节点都配有指向前序和后序的节点。</font>这样，在遍历起来就靠前序、后序找了。针对需要频繁遍历的map而言，提高的效率（遍历效率）。<strong>其余的与HashMap无异。</strong></li>
</ul>
<h3 id="33-treemap">3.3 TreeMap</h3>
<p>向TreeMap中添加键值对，<font color=red>要求key必须是由同一个类创建的对象</font>。因为要按照&lt;key进行排序，因此便要考虑比较器**（Comparable或Comparator）**。</p>
<p>注意，只能按照key中的属性来排序，不能按照value排序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Student{&#34;</span> <span class="o">+</span>
            <span class="s">&#34;name=&#39;&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
            <span class="s">&#34;, age=&#34;</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span>
            <span class="sc">&#39;}&#39;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 匿名内部类
</span><span class="c1"></span>        <span class="n">Map</span> <span class="n">treeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">(</span><span class="k">new</span> <span class="n">Comparator</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Object</span> <span class="n">o1</span><span class="o">,</span> <span class="n">Object</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">o1</span> <span class="k">instanceof</span> <span class="n">Student</span> <span class="o">&amp;&amp;</span> <span class="n">o2</span> <span class="k">instanceof</span> <span class="n">Student</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">Student</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">(</span><span class="n">Student</span><span class="o">)</span> <span class="n">o1</span><span class="o">;</span>
                    <span class="n">Student</span> <span class="n">s2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Student</span><span class="o">)</span> <span class="n">o2</span><span class="o">;</span>
                    <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">age</span><span class="o">,</span> <span class="n">s2</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;illegal argument exception!&#34;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
		<span class="c1">// 按照键的age属性进行排序。切记，不可按值排序
</span><span class="c1"></span>        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;tom&#34;</span><span class="o">,</span> <span class="n">10</span><span class="o">),</span> <span class="n">1</span><span class="o">);</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;mary&#34;</span><span class="o">,</span> <span class="n">9</span><span class="o">),</span> <span class="n">2</span><span class="o">);</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;kobe&#34;</span><span class="o">,</span> <span class="n">12</span><span class="o">),</span> <span class="n">3</span><span class="o">);</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="n">Student</span><span class="o">(</span><span class="s">&#34;jerff&#34;</span><span class="o">,</span> <span class="n">20</span><span class="o">),</span> <span class="n">4</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">treeMap</span><span class="o">);</span>
<span class="c1">// 运行结果： {Student{name=&#39;mary&#39;, age=9}=2, Student{name=&#39;tom&#39;, age=10}=1, Student{name=&#39;kobe&#39;, age=12}=3, Student{name=&#39;jerff&#39;, age=20}=4}
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong><font color=red>注意</font>区别LinkedHashMap的顺序和有TreeMap的有序。前者是能够保证输出的时候能够按照输入的顺序输出，后者是真正的排序。</strong></p>
<h3 id="34-properties">3.4 Properties</h3>
<ul>
<li>
<p>Properties类是Hashtable类的子类，虽然说Hashtable不怎么用了，但是Properties用于处理属性（配置）文件帮助很大。</p>
</li>
<li>
<p>Properties的<font color=red>键值对都是String类型</font>。</p>
</li>
<li>
<p>存取数据建议使用<font color=red>setProperties(String key, String value)方法</font>和<font color=red>getProperties(String key)方法</font>。</p>
</li>
</ul>
<p>考虑如下实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Properties</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PropertiesTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">Properties</span> <span class="n">properties</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
        <span class="c1">// 操作文件需要读取文件流（配置文件为.properties结尾的文件）
</span><span class="c1"></span>        <span class="n">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&#34;config.properties&#34;</span><span class="o">);</span>
        <span class="c1">// 加载流对应的文件
</span><span class="c1"></span>        <span class="n">properties</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>
        <span class="c1">// 获取配置信息
</span><span class="c1"></span>        <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">age</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">&#34;age&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;name :&#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&#34;,&#34;</span> <span class="o">+</span> <span class="s">&#34;age:&#34;</span> <span class="o">+</span> <span class="n">age</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="4-collections工具类">4. Collections工具类</h2>
<ul>
<li>Collections是一个操作Set、List和Map等集合的工具类。</li>
<li>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</li>
</ul>
<ol>
<li><font color=red><strong>void reverse(List )</strong></font> ：反转List中元素的顺序。</li>
<li><font color=red><strong>void shuffle(List )</strong> </font>： 对List集合元素进行随机排序。</li>
<li><font color=red><strong>void sort(List )</strong></font> ： 根据元素的自然顺序对指定List集合元素按升序排序。</li>
<li><font color=red><strong>void sort(List , Comparator )</strong></font>： 根据指定的Comparator产生的顺序对List集合元素进行排序。</li>
<li><font color=red><strong>void swap(List , int , int )</strong> </font>： 将指定List集合中的两元素顺序进行交换。</li>
<li><font color=red><strong>Object max(Collection )</strong> </font>： 根据元素的自然顺序(Comparable接口)，返回给定集合中的最大元素。</li>
<li><font color=red><strong>Object max(Collection , Comparator )</strong> </font>：根据Comparator指定的顺序，返回给定集合中的最大元素。</li>
<li><font color=red><strong>Object min(Collection )</strong> </font>： 根据元素的自然顺序(Comparable接口)，返回给定集合中的最小元素。</li>
<li><font color=red><strong>Object max(Collection , Comparator)</strong> </font>： 根据元素的自然顺序(Comparable接口)，返回给定集合中的最小元素。</li>
<li><font color=red><strong>int frequency(Collection , Object )</strong> </font>：返回指定集合中指定元素的出现次数。</li>
<li><font color=red><strong>void copy(List dest, List src)</strong> </font>： 将src中的内容复制到dest中。<strong>（注意，dest的长度要大于src才行）</strong></li>
<li><font color=red><strong>boolean replaceAll(Lits list, Object oldVal, Object newVal)</strong></font>：使用新值替换list对象中的所有旧值。</li>
</ol>
<p><strong>注意：使用copy方法一定要确保dest的长度不小于src：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span> <span class="n">src</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>
        <span class="n">src</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;ok&#34;</span><span class="o">);</span>
        <span class="n">src</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">15</span><span class="o">);</span>
        <span class="n">src</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">16</span><span class="o">);</span>
        <span class="c1">// 现要将src的复制到dest中,注意将dest的长度设置为src长度的这个操作
</span><span class="c1"></span>        <span class="n">List</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">src</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
        <span class="n">Collections</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">dest</span><span class="o">,</span> <span class="n">src</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dest</span><span class="o">);</span>   <span class="c1">// [ok, 15, 16]
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>    <span class="c1">// [ok, 15, 16]
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ol start="13">
<li><font color=red><strong>List synchronizedList(List )</strong></font>：将参数List转换为一个线程安全的List，这个线程安全的List作为返回值输出。所有根本不需要用Vector。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">List</span> <span class="n">list1</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><ol start="14">
<li><font color=red><strong>Map synchronizedMap(Map )</strong></font>：将参数Map转换为一个线程安全的Map，这个线程安全的Map作为返回值输出。所以根本不需要用Hashtable。</li>
</ol>

  </div>
</article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="http://github.com/fierygit" class="iconfont icon-github" title="github"></a>
  <a href="http://fireflying.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>Firefly</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
