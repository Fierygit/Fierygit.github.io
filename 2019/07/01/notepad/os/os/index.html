<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <title>
        操作系统学习笔记 |
        
        Firefly
    </title>
    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true},"style":{"primary_color":"#0066CC","avatar":"images/avatar.png","favicon":"images/logo.svg","img_position":"left","left_side_width":"260px","content_max_width":"900px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":false,"description":"Welcome"}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"version":"3.0.3"};
    KEEP.language = {"search":"Search...","prev":"Prev","next":"Next","prev_posts":"Prev posts","next_posts":"Next posts","page":"Page %d","recent_posts":"Recent Posts","share":"Share","powered_by":"Powered by %s","theme":"Theme","rss_feed":"RSS Feed","category":"Category","categories":"Categories","tag":"Tag","tags":"Tags","tagcloud":"Tag Cloud","comment":"Comment","home":"Home","archive":"Archive","archives":"Archives","about":"About","site_uv":"Visitor Count","site_pv":"Totalview","links":"Links","link":"Link","top":"TOP","read_more":"Read more","wordcount":"Words","min2read":"Mins","changelog":"Changelog","copyright":{"author":"Post author","title":"Post title","link":"Post link","create_time":"Create time","license_title":"Copyright Notice","license_content":"All articles in this blog are licensed under %s unless stating additionally."},"ago":{"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days age","week":"%s weeks age","month":"%s months age","year":"%s years age"}};
  </script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
<div class="page-container">

    

    <header class="page-header">
        <div class="header-progress"></div>
    </header>

    <main class="page-main">

        <div class="page-main-content">

            <div class="page-main-content-top">
                <header class="header-wrapper">

    <div class="header-content">
        <a class="logo-title" href="/">
            Firefly
        </a>

        <ul class="menu-list">
            
                <li class="menu-item">
                    <a class=""
                       href="/"
                    >
                        HOME
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/archives"
                    >
                        ARCHIVES
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/categories"
                    >
                        CATEGORIES
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/links"
                    >
                        LINKS
                    </a>
                </li>
            
        </ul>

        <div class="menu-bar">
            <div class="menu-bar-middle"></div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">LINKS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


            </div>

            <div class="page-main-content-middle">

                <main class="main-content normal-code-theme">

                    
                        <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">操作系统学习笔记</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span>Firefly</span>
                        <span class="level">Lv5</span>
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-calendar"></i> 2019-07-01 00:00:00
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>
            <ul>
                
                    <li>
                        <a href="/categories/os/">os</a>
                    </li>
                
            </ul>
        </span>
    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i> <span>7.3k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i> <span>28 Mins</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="操作系统复习指南"><a href="#操作系统复习指南" class="headerlink" title="操作系统复习指南"></a><center>操作系统复习指南</center></h1><h2 id="1-CPU-调度算法"><a href="#1-CPU-调度算法" class="headerlink" title="1.CPU 调度算法"></a>1.CPU 调度算法</h2><blockquote>
<p>了解CPU 调度算法，如先到先服务、最短作业优先、轮转、多级反馈队列等调度算法，<br>以及掌握多处理器调度的特殊性。</p>
</blockquote>
<p>T<del>周转时间</del>  =  T<del>完成时间</del>  -  T <del>到达时间</del></p>
<p>FIFO：     平均周转时间很大</p>
<p>SJF：         当一个长时间的任务先到达时，平均周转时间也会很大， 因为不能停止执行。</p>
<p>STCF：     放宽假设条件， 进程可以上下切断， 周转时间很好。</p>
<p>T<del>响应时间</del>  =  T<del>首次运行</del>  -  T <del>到达时间</del></p>
<p>STCF 的响应时间不好 ， 引入RR。</p>
<p>RR：根据时间片切换进程，均摊上下文切换成本，RR响应时间好， 但周转时间不好， 陷入死循环。。。</p>
<p>于是引入MLFQ， 综合解决两个问题。</p>
<p>MLFQ：</p>
<ul>
<li><p>相同优先级的进程按RR调度</p>
</li>
<li><p>如果 优先级  A &gt; B ， 先运行A</p>
</li>
<li><p>初始工作时，放到最高优先级队列中</p>
</li>
<li><ul>
<li>工作用完优先级后，降低优先级</li>
<li>如果在工作在时间片内主动释放cpu， 优先级不变</li>
</ul>
</li>
<li><p>经过一段时间，重新把所有的的进程放到最高优先级</p>
</li>
</ul>
<p>进程可能恶意每次都在快运行完的时候主动释放cpu， 因此，更改第四条如下</p>
<ul>
<li>如果进程用完了，一个优先级上的时间片段， 则降低优先级，无论是否主动释放cpu</li>
</ul>
<p>确保每一个工作获得一定的比例的cpu时间， 而不是优化cpu的周转时间和响应时间， 引入比例份额调度。</p>
<p>彩票调度： 按彩票的数量多少来运行程序， 彩票多概率大运行多，当任务短的时候，有随机性， 引入步长调度</p>
<p>步长调度： 步伐短运行地多，无论怎样都是按比例，缺点是需要<strong>全局状态</strong>， 当一个新的进程加入时， 要更新全部进程的当前步长， 彩票调度只需要一个<strong>全局变量</strong>，总的彩票数。</p>
<p>多处理器调度： 处理缓存一致性问题， 硬件上，cpu监听总线更改缓存，软件上：</p>
<p>单队列调度（SQMS）： 简单，但是缓存不亲和</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200107152722.png"></p>
<p>多队列调度（MQMS）：天生缓存亲和， 但负载不均衡！（工作窃取）</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200107164327.png"></p>
<p>上图可以看出， A进程独占cpu， 工作窃取，就是定时查看其他cpu的工作负载。</p>
<h2 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2.进程和线程"></a>2.进程和线程</h2><blockquote>
<p>掌握进程和线程的概念，熟练使用进程和线程相关编程接口，如fork，exec，wait，<br>pthread_create，pthread_join等。</p>
</blockquote>
<h3 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h3><p>进程就是运行中的程序， 一个进程可以创建多个线程。</p>
<p>进程之间不共用内存， 线程之间可以共用内存， 但每一个线程都有自己的堆栈。</p>
<ul>
<li>fork()</li>
</ul>
<p>子进程改变全局变量不会改变父进程的值， 子进程有自己的程序运行空间， copy自父进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#inclucde <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world(pid: %d)\n&quot;</span>,(<span class="keyword">int</span>)getpid);</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc &lt; <span class="number">0</span>) &#123;<span class="comment">// 创建失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>+ <span class="built_in">stderr</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;<span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am child (pid: %d)&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//!!!!!!!! 注意父进程的 rc 值是 子进程的 pid</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am parent of %d (pid: %d)&quot;</span>, rc, (<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>waidpid（）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#inclucde <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world(pid: %d)\n&quot;</span>,(<span class="keyword">int</span>)getpid);</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc &lt; <span class="number">0</span>) &#123;  <span class="comment">// 创建失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>+ <span class="built_in">stderr</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;<span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am child (pid: %d)&quot;</span>,(<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//!!!!!!!! 注意父进程的 rc 值是 子进程的 pid</span></span><br><span class="line">    	<span class="keyword">int</span> wc == wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, i am parent of %d (wc: %d) (pid: %d)&quot;</span>, rc, wc, (<span class="keyword">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rc = wc </p>
<p>fork 用作相同程序的拷贝作用，执行不同的程序时， 可以用</p>
<ul>
<li>exec()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argc[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span> + <span class="built_in">stderr</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;</span><br><span class="line">        close(STDOUT_FILENO);<span class="comment">// 关闭标准输入与输出</span></span><br><span class="line">        open(<span class="string">&quot;./p4,output&quot;</span>,O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);  </span><br><span class="line">        <span class="keyword">char</span> * myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>; <span class="comment">// 可运行的程序</span></span><br><span class="line">        myargs[<span class="number">1</span>] = <span class="string">&quot;file.c&quot;</span>;</span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        execvp(myargs[<span class="number">0</span>],myargs);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);<span class="comment">// this will be not ecec</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>// todo</p>
<h3 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">( <span class="keyword">pthread_t</span> * thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> * attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> * (*start_routine)(<span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> * arg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、第一个是指向 pthread_t 的指针， 用于交互</span></span><br><span class="line"><span class="comment">2、第二个是设置新的线程的，栈大小等等信息</span></span><br><span class="line"><span class="comment">3、执行的函数</span></span><br><span class="line"><span class="comment">4、参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> * thread,<span class="keyword">void</span> ** value_ptr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//第一个参数为创建的时候，保留的指针， 第二个为返回值</span></span></span><br></pre></td></tr></table></figure>









<h2 id="3-并发同步"><a href="#3-并发同步" class="headerlink" title="3.并发同步"></a>3.并发同步</h2><blockquote>
<p>掌握进程并发同步相关概念，如死锁、活锁等概念，真实应用中存在的不同类型的同步<br>问题，熟练使用pthread库中的相关同步函数进行编程。</p>
</blockquote>
<p>题目说，进程并发同步的相关概念， 让我对进程和线程的理解再次产生怀疑，首先再次总结一下：</p>
<p>进程是为运行中的程序提供的一个抽象，线程是为单个运行的进程提供的抽象，多线程程序有多个执行点， 每个线程类似于进程， 唯一的区别是： 线程之间共享地址空间，能够访问相同的数据（在堆上的数据或者全局变量， 不是局部变量）。</p>
<p>非死锁：</p>
<ul>
<li>违反原子性</li>
<li>违反顺序缺陷</li>
</ul>
<h3 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h3><p>产生原因：</p>
<ul>
<li><p>组件之间会有复杂的依赖</p>
</li>
<li><p>模块化会封装细节</p>
</li>
</ul>
<p>解决方案：</p>
<p>所有的线程获取锁的顺序如果是相同的就不会产生死锁</p>
<p>产生条件：</p>
<ul>
<li>互斥</li>
</ul>
<p>使用硬件支持， 使用不用锁的数据结构！</p>
<ul>
<li>持有并等待</li>
</ul>
<p>或取多个锁时： 可以用一个把大的锁锁住， 即使防止获取锁的过程中，上下文切换！</p>
<ul>
<li>非抢占</li>
</ul>
<p>获取第一个锁后，查看第二个锁是否被占有， 如果占有直接放弃第一个锁，再次获取第一个锁， 这样存在一个问题， 两个锁一直重复这个问题， 倒置<strong>活锁</strong></p>
<ul>
<li>循环等待</li>
</ul>
<p>锁的获取按照一定的顺序获取等待</p>
<h2 id="4-地址空间"><a href="#4-地址空间" class="headerlink" title="4.地址空间"></a>4.地址空间</h2><blockquote>
<p>掌握地址空间的概念，以及用户态堆内存的管理。</p>
</blockquote>
<p>一个进程的地址空间应该包含运行的程序的所有内存状态，操作系统给程序的抽象， 包括代码块， 堆，栈，真实的<strong>物理空间</strong>可能在任意的地方，地址空间是连续的0KB -&gt; 16KB 。如下图：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104151718.png"></p>
<p>所谓堆内存（属于地址空间）， 申请和释放都是又程序猿自己自己自己完成（注意这里操作的是地址空间，虚拟的）。java不用</p>
<h3 id="分配："><a href="#分配：" class="headerlink" title="分配："></a>分配：</h3><p> void malloc（size_t size） , size大小一般为宏来设定， 比如 sizeof(double),  注意 void 的返回类型 是返回地址的指针，可以强转， 如下：</p>
<p>int *x = malloc(sizeof(int));</p>
<h3 id="释放："><a href="#释放：" class="headerlink" title="释放："></a>释放：</h3><p> free(x)   , 分配的大小不会被用户传入， 必须由<strong>内存分配库</strong>本身记录追踪。</p>
<h3 id="常见错误："><a href="#常见错误：" class="headerlink" title="常见错误："></a>常见错误：</h3><ul>
<li><p>忘记分配内存（这个常犯， 常犯， 给一个指针赋值！！！！指针是存放在栈中的， 4个字节的）</p>
</li>
<li><p>没有分配足够的内存</p>
</li>
<li><p>忘记初始化分配的内存， NULL 一般输出为 0， 但0 不等于 NULL ，默认都是0</p>
</li>
<li><p>忘记释放内存（这个我一般都不是释放 ^ _ ^，web、操作系统等长时间运行的程序一定需要！！）</p>
</li>
<li><p>反复释放内存（内存都不释放， 这个绝对不会发生的）</p>
</li>
<li><p>用完之前释放内存</p>
</li>
<li><p>错误调用free（）， 参数传入错误的值。</p>
</li>
</ul>
<h2 id="5-同步原语"><a href="#5-同步原语" class="headerlink" title="5.同步原语"></a>5.同步原语</h2><p>掌握锁、条件变量、信号量三种同步机制（熟练使用pthread库中的函数），并使用这些<br>机制解决实际应用问题，如生产者消费者问题。</p>
<h3 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h3><p>锁就是一个<strong>变量</strong>， 锁为程序员提供了最小程度的调度控制，线程是操作系统的cpu调度的最小单位。</p>
<h4 id="实现锁"><a href="#实现锁" class="headerlink" title="实现锁"></a>实现锁</h4><h5 id="控制中断"><a href="#控制中断" class="headerlink" title="控制中断"></a>控制中断</h5><p>通过控制中断， 让代码原子执行</p>
<p>缺点很多， 不支持多cpu， 出现系统问题，操作系统需要控制中断来获取控制权。。。</p>
<h5 id="TestAndSet"><a href="#TestAndSet" class="headerlink" title="TestAndSet"></a>TestAndSet</h5><p>这条指令基于硬件的支持，等价于下面代码是<strong>原子执行</strong>的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *old_ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *old = old_ptr;</span><br><span class="line">	*old_ptr = <span class="keyword">new</span>;</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自旋锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line"> 	<span class="keyword">int</span> flag;</span><br><span class="line"> &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line"> 	lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//上面会一直自旋，浪费cpu资源， 也可能一直自旋永远得不到执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> * lock)</span></span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FetchAndAdd"><a href="#FetchAndAdd" class="headerlink" title="FetchAndAdd"></a>FetchAndAdd</h5><p>这也是一个硬件支持的原语，这一条指令等价于下面原子执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FetchAndAdd(<span class="keyword">int</span> *ptr)&#123;</span><br><span class="line">	<span class="keyword">int</span> old = *ptr;</span><br><span class="line">	*ptr = old + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个公平的自旋锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line"> 	<span class="keyword">int</span> ticket;</span><br><span class="line"> 	<span class="keyword">int</span> turn;</span><br><span class="line"> &#125; <span class="keyword">lock_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line"> 	lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="comment">// 这里每一一次测试都会增加， 让每一个线程都能得到执行！</span></span><br><span class="line">    <span class="keyword">while</span>(lock-&gt;trun != myturn);</span><br><span class="line">    <span class="comment">//这里还是会自旋</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span>&#123;</span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面硬件原语的支持虽然实现了简单的公平锁， 但是它会自旋，下面实现不自旋的公平锁</p>
<h4 id="实现公平不自旋锁"><a href="#实现公平不自旋锁" class="headerlink" title="实现公平不自旋锁"></a>实现公平不自旋锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> flag;</span><br><span class="line"> 	<span class="keyword">int</span> guard;</span><br><span class="line">	<span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"> 	m-&gt;flag = <span class="number">0</span>;</span><br><span class="line"> 	m-&gt;guard = <span class="number">0</span>;</span><br><span class="line"> 	queue_init(m-&gt;q);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 这里虽然也会自旋， 但是这个guard，在一个线程获取锁后（后面的else），guard也设置成了0，</span></span><br><span class="line">     <span class="comment">//也就是说，即使已经有线程获取了锁， 这条指令还是有可能通过的， 不会一直在这里自旋，只会自旋几个周期</span></span><br><span class="line">	<span class="comment">// guard的作用是保证后面的flag的设置是原子进行的</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 这里保证的原子的执行了， 因为其它指令的gurad为1，进不来这里， 不会有两个线程同时进入这里</span></span><br><span class="line"> 	<span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;<span class="comment">// 如果能获取到锁</span></span><br><span class="line"> 		m-&gt;flag = <span class="number">1</span>; </span><br><span class="line"> 		m-&gt;guard = <span class="number">0</span>;<span class="comment">// 重置为0</span></span><br><span class="line"> 	&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果没有获取到锁</span></span><br><span class="line"> 		queue_add(m-&gt;q, gettid());<span class="comment">// 加入队列，休眠队列</span></span><br><span class="line"> 		m-&gt;guard = <span class="number">0</span>;<span class="comment">// guard这里也重置为0</span></span><br><span class="line"> 		park();</span><br><span class="line">        <span class="comment">//这个是操作系统提供给程序员的函数， 休眠自己，在c语言中， 每种操作系统可以提供不同的</span></span><br><span class="line">        <span class="comment">//函数库供程序猿调度，在 java统一为yeild（）， linux中使用c也为 yeild（）</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">//通过自旋获取guard</span></span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">		 m-&gt;flag = <span class="number">0</span>; <span class="comment">// 空的话flag直接设置0</span></span><br><span class="line"> 	<span class="keyword">else</span></span><br><span class="line">		 unpark(queue_remove(m-&gt;q)); </span><br><span class="line"> 		<span class="comment">// 这里并没有将 flag设置0， 因为要保证公平性， 按照队列的线程来进行唤醒，这样</span></span><br><span class="line">    <span class="comment">// 队列里的每一个线程都能够得到执行，直接将flag的1 使用权传给了队列的第一个线程</span></span><br><span class="line"> 	m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码还有一个很微妙的竞态条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue_add(m-&gt;q, gettid());</span><br><span class="line">m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">park();</span><br></pre></td></tr></table></figure>

<p>假设这段代码执行完前两句语句， 此时guard 变成了0，  释放锁的线程可以运行了， 而这个线程已经在休眠队列里面，但是它却还没有休眠， 这是如果唤醒了它，相当于白唤醒， 之后它执行park又再次休眠，而没加入队列里面了。结果就是永久休眠。 所以linux的实现有一个再次确认的代码！！！ </p>
<p>linux 也是使用这种思想， 但是提供的原语不同。</p>
<p>锁的实现已经完成了，但是还有一种情况，当父进程等待子进程结束的时候，就要用到下面的同步原语：</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(<span class="keyword">pthread_cond_t</span> *c, <span class="keyword">pthread_mutex_t</span> *m);</span><br><span class="line">pthread_cond_signal(<span class="keyword">pthread_cond_t</span> *c);</span><br></pre></td></tr></table></figure>

<p>实现子进程等带父进程：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;m);</span><br><span class="line"> 	done = <span class="number">1</span>;</span><br><span class="line"> 	Pthread_cond_signal(&amp;c);</span><br><span class="line">    <span class="comment">//唤醒因为条件c而休眠你的线程</span></span><br><span class="line"> 	Pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line"> 	thr_exit();</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Pthread_mutex_lock(&amp;m);</span><br><span class="line">    <span class="comment">//为什么要锁呢？ 因为下面wait函数有释放锁！！！！！！！！！！！</span></span><br><span class="line"> 	<span class="keyword">while</span> (done == <span class="number">0</span>)			</span><br><span class="line"> 	Pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    1、 这里要使用一个done来标记时候是否完成， 如果不用， 子进程先于父进程完成的时候，就会卡主</span></span><br><span class="line"><span class="comment"> 	因为子进程已经过了唤醒父进程，而父进程又重新休眠，这样没有线程唤醒父进程</span></span><br><span class="line"><span class="comment"> 	2、当调用了这条命令之后， 线程首先会将** 锁释放 **，然后调用线程休眠自己，（原子操作）</span></span><br><span class="line"><span class="comment">	3、要用while， 而不能用if，在这里使用if正确， 但是有多个信号的时候， 可能会出现1 的情况</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line"> 	Pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line"> 	<span class="keyword">pthread_t</span> p;</span><br><span class="line"> 	Pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);<span class="comment">//创建新的线程</span></span><br><span class="line"> 	thr_join();		<span class="comment">//等待子线程完成</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书上没有给出条件变量的实现方法，但是通过其功能描述结合锁的实现应该也略知一二！</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是dijkstra提出的，可以用作为锁和条件变量， 让同步原语更加通用。</p>
<p>信号量是一个<strong>整形数值</strong>的对象, 下面是POSIX库的使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line">sem_s s;</span><br><span class="line">sem_init(&amp;s,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">sem_wait(sem_s *s);</span><br><span class="line">sem_post(sem_s *s);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一共有三个参数：</span></span><br><span class="line"><span class="comment">1、 s是传入一个信号量</span></span><br><span class="line"><span class="comment">2、0表示同一进程多个线程共享， 当为其它的时候， 可以在不同的进程中通知</span></span><br><span class="line"><span class="comment">3、初始化信号量的值为 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="实现信号量"><a href="#实现信号量" class="headerlink" title="实现信号量"></a>实现信号量</h4><p>基于锁和信号量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Zem_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">	<span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; Zem_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_init</span><span class="params">(Zem_t *s, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	s-&gt;value = value;</span><br><span class="line">	Cond_init(&amp;s-&gt;cond);</span><br><span class="line">	Mutex_init(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Zem_wait</span><span class="params">(Zem_t *s)</span> </span>&#123;</span><br><span class="line"> 	Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line"> 	<span class="keyword">while</span> (s-&gt;value &lt;= <span class="number">0</span>)<span class="comment">//当初始化的value小于等于0 的时候等待当前的线程</span></span><br><span class="line"> 		Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);</span><br><span class="line"> 	s-&gt;value--;			<span class="comment">// value 减去1不能放到上面，原因在下面</span></span><br><span class="line"> 	Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Zem_post</span><span class="params">(Zem_t *s)</span> </span>&#123;</span><br><span class="line">	Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line"> 	s-&gt;value++;  		<span class="comment">//唤醒一个等待着的线程，对应的value 加上1</span></span><br><span class="line"> 	Cond_signal(&amp;s-&gt;cond);</span><br><span class="line"> 	Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>看了实现之后， 很容易就能用一个信号量实现一个锁</p>
<h4 id="信号量实现条件变量"><a href="#信号量实现条件变量" class="headerlink" title="信号量实现条件变量"></a>信号量实现条件变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">	sem_post(&amp;s); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	sem_init(&amp;s, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 这里初始化为0，</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> c;</span><br><span class="line">	Pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">	sem_wait(&amp;s); </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    有两种情况考虑：</span></span><br><span class="line"><span class="comment">    1、 当父进程线运行时， 信号量的值为0，休眠自己，此时不会减去1</span></span><br><span class="line"><span class="comment">    	子进程运行post的时候，唤醒了父进程，value加上了1，变成1</span></span><br><span class="line"><span class="comment">    	********* 父进程继续运行，减去1 ， 信号量重新变为0， 这就是value - 1 不能放上面的原因！！</span></span><br><span class="line"><span class="comment">    2、 当子进程先运行的时候， value加上了1， 等于1</span></span><br><span class="line"><span class="comment">    	当父进程运行的时候， value为1， 不用等了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二值信号量（锁）"><a href="#二值信号量（锁）" class="headerlink" title="二值信号量（锁）"></a>二值信号量（锁）</h4><p>初始化信号量的值为1，这就实现了一个锁！！！</p>
<p>当有一个进程获取锁之后， value 就变成了0， 其它线程要进入必须等待被唤醒。</p>
<p>当有多个线程在休眠时， 多个线程同时被唤醒， 多个线程会抢占锁，谁先抢到谁先起来， 这里应该是存在不公平现象的， 有可能有些线程一直得不到执行！？？？？？？？应该只有一个线程会被唤醒！！！？？？</p>
<p>上面理解错误！！！！不会有多个被唤醒的情况， 条件变量目前只有一个在等待</p>
<p>应该是按照fifo来的</p>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><h4 id="基于条件变量和锁"><a href="#基于条件变量和锁" class="headerlink" title="基于条件变量和锁"></a>基于条件变量和锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> buffer[MAX];</span><br><span class="line"><span class="keyword">int</span> fill_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> use_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	buffer[fill_ptr] = value;</span><br><span class="line"> 	fill_ptr = (fill_ptr + <span class="number">1</span>) % MAX;</span><br><span class="line"> 	count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> tmp = buffer[use_ptr];</span><br><span class="line"> 	use_ptr = (use_ptr + <span class="number">1</span>) % MAX;</span><br><span class="line"> 	count--;</span><br><span class="line"> 	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">cond_t</span> empty, fill;</span><br><span class="line"> <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里要使用两个条件变量， 如果只使用一个， 而条件变量的唤醒不是按照队列来的，这时</span></span><br><span class="line"><span class="comment">假设有两个消费者因为没有count休眠</span></span><br><span class="line"><span class="comment">而生产者生产满了之后， 就去休眠了， 等待唤醒</span></span><br><span class="line"><span class="comment">此时一个消费者先被唤醒，消费完count后， 唤醒了另一个消费者，发现count已经没了，也去休眠，</span></span><br><span class="line"><span class="comment">此时没人唤醒生产者了。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"> 		Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1</span></span><br><span class="line">        <span class="keyword">while</span> (count == MAX) <span class="comment">// p2</span></span><br><span class="line">            Pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">// p3</span></span><br><span class="line">        put(i); <span class="comment">// p4</span></span><br><span class="line">        Pthread_cond_signal(&amp;fill); <span class="comment">// p5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6</span></span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// c2</span></span><br><span class="line">         	Pthread_cond_wait(&amp;fill, &amp;mutex); <span class="comment">// c3</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里使用while，而不是if， 原因：</span></span><br><span class="line"><span class="comment">        当有多个消费者时， 其中一个消费者先运行，发现count = 0，休眠， 接下来生产者生产一个</span></span><br><span class="line"><span class="comment">        count = 1， 这时另一个消费者运行， 把数据取走， 此时count = 0； 假设接下来是</span></span><br><span class="line"><span class="comment">        刚才那个休眠的消费者继续运行，此时count已经是0了， 而如果使用if， if只会判断一次， </span></span><br><span class="line"><span class="comment">        刚才休眠的时候已经判断过了，所以这个消费者会继续运行， count -= 1； = -1！！！</span></span><br><span class="line"><span class="comment">        所以要使用while ， while 会重新回来判断！！</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> tmp = get(); <span class="comment">// c4</span></span><br><span class="line">        Pthread_cond_signal(&amp;empty); <span class="comment">// c5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="基于信号量"><a href="#基于信号量" class="headerlink" title="基于信号量"></a>基于信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"> 		sem_wait(&amp;mutex); <span class="comment">// Line P0 (NEW LINE)</span></span><br><span class="line">        sem_wait(&amp;empty); <span class="comment">// Line P1</span></span><br><span class="line">        put(i); <span class="comment">// Line P2</span></span><br><span class="line">        sem_post(&amp;full); <span class="comment">// Line P3</span></span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// Line P4 (NEW LINE)</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">         sem_wait(&amp;mutex); <span class="comment">// Line C0 (NEW LINE)</span></span><br><span class="line">         sem_wait(&amp;full); <span class="comment">// Line C1</span></span><br><span class="line">         <span class="keyword">int</span> tmp = get(); <span class="comment">// Line C2</span></span><br><span class="line">         sem_post(&amp;empty); <span class="comment">// Line C3</span></span><br><span class="line">         sem_post(&amp;mutex); <span class="comment">// Line C4 (NEW LINE)</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="6-分段与分页"><a href="#6-分段与分页" class="headerlink" title="6.分段与分页"></a>6.分段与分页</h2><blockquote>
<p>掌握虚拟内存管理中的分段与分页机制的原理，以及比较其优缺点。</p>
</blockquote>
<h3 id="动态重定位："><a href="#动态重定位：" class="headerlink" title="动态重定位："></a><strong>动态重定位</strong>：</h3><p>基于硬件的动态重定位，使用内存管理单元（MMU）给<strong>地址空间</strong>分配内存，效率低下， 造成很多内部碎片（图中allocated but not use）。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20200104152143704.png"></p>
<h3 id="分段："><a href="#分段：" class="headerlink" title="分段："></a>分段：</h3><p>因此引入分段解决内部碎片问题：MMU给<strong>地址空间</strong>内的每一个逻辑段都分配内存。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/image-20200104152706215.png"></p>
<p>段的引用： 显示方式</p>
<img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104153148.png" style="zoom:80%;" />

<p>于是乎， 在内存上产生很多<strong>外部碎片</strong>， 解决方法，基于空闲列表 和 各种管理算法：</p>
<p>这里我觉得不会考，但列一列：</p>
<ul>
<li><p>最优匹配</p>
</li>
<li><p>最差匹配</p>
</li>
<li><p>首次匹配</p>
</li>
<li><p>下次匹配</p>
</li>
<li><p>分离空闲列表：经常申请的内存空间，给它一个独立的列表</p>
</li>
<li><p>伙伴系统： 二分分配， 合并和分配的时候很方便， 二进制与二叉树的巧合</p>
</li>
</ul>
<p>可以看出分段会产生外部碎片， 这是一个很根本的问题，不通用， 即使有管理内存算法！</p>
<p>以上不会考的，应该考二级页表！</p>
<h3 id="分页："><a href="#分页：" class="headerlink" title="分页："></a>分页：</h3><p>分页不是将一个<strong>地址空间</strong>按逻辑段分， 而是分割成固定大小的单元，称为 <strong>页帧</strong>。</p>
<p>页表： 记录每一个地址空间的每一个<strong>虚拟页</strong>（<strong>页帧</strong>）在物理内存中的位置，==页表是每一个进程数据结构==。</p>
<p>物理帧号（PFN）或称 物理页号（PPN physical page number）： 真实的物理 <strong>页帧</strong> 地址。</p>
<ul>
<li>地址空间划分：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104162855.png"></p>
<ul>
<li>物理地址划分</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104162939.png"></p>
<p>页表项（PTE page table entry）： 记录 PFN </p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104160826.png"></p>
<p>上图中中间的地址转换（address translation）就通过页表来存储！！</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p><strong>地址空间</strong> 地址 21  -&gt; 010101  <img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104160907.png"></p>
<p>从物理地址 （vpn 01 推出 ）中拿出PTE，取出 PFN 得到地址空间的真实的物理地址， 偏移量不变， 因为页帧一样大。</p>
<p>如何拿出vpn对应的PTE：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT             <span class="comment">//取出VPN</span></span><br><span class="line">PTEAddr = PageTableBaseRegister + (VPN * <span class="keyword">sizeof</span>(PTE))  <span class="comment">// 算出物理地址， 拿到PTE的物理地址</span></span><br></pre></td></tr></table></figure>

<p>于是呢， 有两次的内存访问， ==慢==！</p>
<p>页表存放：</p>
<p>简单的存放线性页表， 32 位的地址空间， 4KB（2^ 12）的页大小（大部分os，windows，linux），PTE个数：2^32 / 2^12 = 2^20,  PTE大小（假设）4B， 线性页表大小 4B * 2^20 = 4MB, 所以一个进程就 4MB内存， 10个就==。。。==</p>
<p>以上就是页表的两个缺点！</p>
<p>先比较优缺点：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分段</td>
<td align="center">很好支持稀疏地址空间，很快，算法简单，适合硬件完成，地址转换的开销极小， 代码共享（如果代码独立的段中，可以被多个运行程序共享）。</td>
<td align="center">不支持<strong>一般化</strong>的稀疏地址，产生外部碎片问题很根本，难以避免，随时间推移，管理难，分配也困难。</td>
</tr>
<tr>
<td align="center">分页</td>
<td align="center">不会导致外部碎片， 很灵活，支持稀疏的地址空间</td>
<td align="center">速度较慢，要两次访问内存，<strong>有可能</strong>产生内存浪费</td>
</tr>
</tbody></table>
<h2 id="7-TLB，-多级页表"><a href="#7-TLB，-多级页表" class="headerlink" title="7.TLB， 多级页表"></a>7.TLB， 多级页表</h2><blockquote>
<p>掌握TLB 与多级页表，掌握多级页表相关的计算，比如根据地址位、页面大小、PTE 大<br>小等条件，进行虚拟地址到物理地址的转换；掌握多级页表的访问过程。</p>
</blockquote>
<p>第6点的页表的两个问题需要解决！</p>
<h3 id="解决问题1：-慢"><a href="#解决问题1：-慢" class="headerlink" title="解决问题1： 慢"></a>解决问题1： 慢</h3><h4 id="TLB："><a href="#TLB：" class="headerlink" title="TLB："></a>TLB：</h4><p>TLB（地址转换旁路缓冲储存器）也叫 地址转换缓存， 频繁发生虚拟到物理地址的硬件缓存。</p>
<h5 id="原理（注意加粗，-）："><a href="#原理（注意加粗，-）：" class="headerlink" title="原理（注意加粗， ** **）："></a>原理（注意加粗， ** **）：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line"> (Success, TlbEntry) = TLB_Lookup(VPN)  <span class="comment">// TLB里面找VPN对应的物理地址</span></span><br><span class="line"> <span class="keyword">if</span> (Success == True) <span class="comment">// TLB Hit</span></span><br><span class="line">	 <span class="keyword">if</span> (CanAccess(TlbEntry.ProtectBits) == True)</span><br><span class="line">		Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line"> 		PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span><br><span class="line"> 		Register = AccessMemory(PhysAddr)  <span class="comment">// 直接从** 缓存地址**中拿到实际的物理地址</span></span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">		 RaiseException(PROTECTION_FAULT)</span><br><span class="line"> <span class="keyword">else</span> 			<span class="comment">// TLB Miss</span></span><br><span class="line">	 PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br><span class="line">	 PTE = AccessMemory(PTEAddr)    <span class="comment">//没有找到就多了一次PTE ** 内存 **的寻址， 多了一次一次就一次</span></span><br><span class="line">  	<span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">	 	RaiseException(SEGMENTATION_FAULT)</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">		RaiseException(PROTECTION_FAULT)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)</span><br><span class="line">		RetryInstruction()</span><br></pre></td></tr></table></figure>

<h4 id="缓存："><a href="#缓存：" class="headerlink" title="缓存："></a>缓存：</h4><p>计算机中有很多缓存，有指令、数据、地址转换， 上面是地址转换的缓存TLB，缓存要小，越小越快（物理限制），有时间和空间局部性。cpu的数据缓存也分为多级。</p>
<p>曾看到一道题， TLB 和 cache 有什么不同？？？？  </p>
<h4 id="问题里面的问题："><a href="#问题里面的问题：" class="headerlink" title="问题里面的问题："></a>问题里面的问题：</h4><p>当TLB中有两条相同的VPN索引两个不同的物理地址， 可以通过ASID标记（进程号）来标记， 这样就不用覆盖掉之前的VPN了， 当两个进程交互运行时， 相同的VPN可以存在于TLB中，还是上一张图。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104165558.png"></p>
<h5 id="TLB覆盖问题："><a href="#TLB覆盖问题：" class="headerlink" title="TLB覆盖问题："></a>TLB覆盖问题：</h5><p> 如果程序短时间内访问的页数超过了 TLB中的页数， 会产生大量未命中，因为要重写，因此要支持更大的页， 才不会访问很多页！！</p>
<h5 id="TLB的替换策略：LRU"><a href="#TLB的替换策略：LRU" class="headerlink" title="TLB的替换策略：LRU"></a>TLB的替换策略：LRU</h5><p>难道是问题8的？ 不是的，问题8是页的替换， 这里是TLB的替换，思路应该一样的！！</p>
<p>听说腾讯的面试有要求写一个LRU算法！ 基于哈希，哈希每次访问的地址，用一个链表存储哈希后的地址数值，有新的访问就把他放到链表的头结点（包括在链表中的），满了删队尾。（脑子里想起链表的操作删除，插入操作）</p>
<h3 id="解决问题2：-页表很大！"><a href="#解决问题2：-页表很大！" class="headerlink" title="解决问题2： 页表很大！"></a>解决问题2： 页表很大！</h3><h4 id="更大的页"><a href="#更大的页" class="headerlink" title="更大的页"></a>更大的页</h4><p>页变大， 页表条目减少， 页表也就小了， 但是页变大有内部碎片产生！因为每一页都用不完积累就多</p>
<h4 id="分段-分页"><a href="#分段-分页" class="headerlink" title="分段+分页"></a>分段+分页</h4><p>分段与分页相结合，外部碎片再次产生， 页表就是为了解决外部碎片的！！！分段产生外部碎片的根源，无可避免！！</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>于是乎，只有引入多级页表：</p>
<p>问题所在： 页表中存在很多无效区域。</p>
<p>基本思想：将<strong>页表</strong>分成<strong>页</strong>大小的单元，如果整页的PTE无效，就完全不分配该页的页表（很重要！）于是引入:</p>
<p>PDE(页目录)： 记录页表的页是否有效， 包含有效位和页帧号。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104215751.png"></p>
<p>详细深入具体仔细的一个书上的例子： 完美非无可增，乃不可减，老师说必考。</p>
<p>首先题目： 地址空间 16KB（2^14)，地址位数14位， 页大小 64B（2^6),   偏移位数6 位，VPN位数： 14 - 4 = 8 位，页表项条数为 2^8条 , PTE的大小为 4B（假设），如果是线性页表大小为： 4 * 256B = 1KB，如果分配到PDE中， 每页存 64B/4B = <font color="red">16</font> 条PTE，一共要256/16 = ==16==页来存储PTE，于是页目录的索引要 4位（来自黄色的数字），如下图：</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200104221733.png"></p>
<p>计算PTE的PFN算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PDEAddr = PageDirBase + (PDIndex(<span class="number">4</span>位就可以找到！) - <span class="keyword">sizeof</span>(PDE))</span><br></pre></td></tr></table></figure>

<p>于是找到了PTE所在的物理页帧PFN！（第一步）</p>
<p>因为VPN一共8位， 找PTE所在的页用了4位， 还有4位就索引属于该页所有的PTE的那一条（来自红色的数字）！</p>
<p>通过下面的这条式子找到， 实际物理地址的PFN！(第二步)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTEAddr = (PDE.PFN &lt;&lt; SHIFT) + (PTIndex * <span class="keyword">sizeof</span>(PTE))</span><br></pre></td></tr></table></figure>

<p>最后,计算实际的物理地址！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhysAddr &#x3D; (PTE.PFN &lt;&lt; SHIFT) + offset</span><br></pre></td></tr></table></figure>

<p>总结，二级页表的访问内存数目达到了两次，访问速度慢， 但是解决了页表大的问题， 是一个时空的折中。</p>
<h2 id="8-页面置换算法"><a href="#8-页面置换算法" class="headerlink" title="8.页面置换算法"></a>8.页面置换算法</h2><p>掌握页面置换算法，比如FIFO，LRU等，要求能根据给定的页面访问序列，给出特定算<br>法的计算过程；掌握CLOCK算法。</p>
<p>这一块课，没有去听，^ _ ^</p>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>这个好实现， 先进先出，用一个队列就行！</p>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>这个在TLB的替换页面中写了。</p>
<p>LRU 也有问题， 当内存大的时候， LRU的实现代价很大，比如存储LRU的数据结构，因此引入一个近似LRU：</p>
<h3 id="近似LRU"><a href="#近似LRU" class="headerlink" title="近似LRU"></a>近似LRU</h3><p>近似LRU 要硬件的帮助， 给页增加一个使用位， 如果为1， 则认为当前页正在被使用。</p>
<h4 id="clock算法"><a href="#clock算法" class="headerlink" title="clock算法"></a>clock算法</h4><p>算法思路： 当要进行页替换的时候，检查当前的页的使用位，如果为1， 则意味着当前页在被使用，不适合替换，然后将这个位设置为0， 接着检查下一个页的使用位。 如果为0， 则直接替换。 算法的最坏情况是所有的页都是在被使用的， 把所有的1 都换为 0， 此时再来一遍循环选第一个替换， 实际上这种情况很少出现！</p>
<h4 id="ARC算法"><a href="#ARC算法" class="headerlink" title="ARC算法"></a>ARC算法</h4><p>书上没有介绍！</p>
<p>//todo</p>
<h2 id="9-磁盘驱动器"><a href="#9-磁盘驱动器" class="headerlink" title="9.磁盘驱动器"></a>9.磁盘驱动器</h2><blockquote>
<p>掌握磁盘寻道、旋转、传输时间的概念及计算过程。</p>
</blockquote>
<p>寻道： 就是寻道，一般有偏斜</p>
<p>旋转：就是旋转</p>
<p>T <del>I/O</del> = T <del>寻道</del> + T <del>旋转</del> + T <del>传输</del></p>
<p>R<del>I/O</del>（传输速度） = 文件大小 / T <del>I/O</del></p>
<h2 id="10-磁盘调度算法"><a href="#10-磁盘调度算法" class="headerlink" title="10.磁盘调度算法"></a>10.磁盘调度算法</h2><blockquote>
<p>了解各种磁盘调度算法的原理。</p>
</blockquote>
<h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p>最短任务优先， 计算 I/O的时间，选择最短的！</p>
<h3 id="SSTF"><a href="#SSTF" class="headerlink" title="SSTF"></a>SSTF</h3><p>最短寻道时间优先， 可能产生饥饿，一直在同一道内请求</p>
<h3 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h3><p>到一层的时候， 将请求加入队列， 处理完再寻道，这样避免饥饿</p>
<h3 id="SPTF"><a href="#SPTF" class="headerlink" title="SPTF"></a>SPTF</h3><p>最短定位时间</p>
<h2 id="11-RAID"><a href="#11-RAID" class="headerlink" title="11.RAID"></a>11.RAID</h2><blockquote>
<p> 掌握磁盘阵列RAID-0，RAID-1，RAID-4，RAID-5的原理，并分析各种RAID在容量、可<br>靠性、吞吐量三个层面的特性。熟练使用RAID的这些特性进行设计。</p>
</blockquote>
<p>RAID:  廉价冗余磁盘阵列</p>
<p>用于使用多个磁盘构建更大、更快、更可靠的磁盘系统</p>
<h3 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h3><p>条带化</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174035.png"></p>
<p>计算公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Disk = A % number_of_disks</span><br><span class="line">Offset = A / number_of_disks</span><br></pre></td></tr></table></figure>

<p>容量最好， 性能优， 不可靠！</p>
<h3 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h3><p>一半用作镜像</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174309.png"></p>
<p>容量减半， 速度也减半， 因为并发io，少了一半，可靠！</p>
<h3 id="RAID4"><a href="#RAID4" class="headerlink" title="RAID4"></a>RAID4</h3><p>专门用一个磁盘用来奇偶校验</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174532.png"></p>
<p>可靠， 速度（n-1）S， 容量大</p>
<p>当一校验盘同时有两个块需要校验时， 速度会减慢， 因此引入：</p>
<h3 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h3><p>旋转奇偶校验</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174917.png"></p>
<p>可靠， 速度（n-1）S，容量大</p>
<h3 id="性能比较："><a href="#性能比较：" class="headerlink" title="性能比较："></a>性能比较：</h3><p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200108174957.png"></p>
<h2 id="12-文件系统接口"><a href="#12-文件系统接口" class="headerlink" title="12.文件系统接口"></a>12.文件系统接口</h2><blockquote>
<p> 了解文件系统接口，如open，read，write，在实现时对元数据和文件内容的读写过程。</p>
</blockquote>
<p>都说不考喽！！！</p>
<h2 id="13-操作系统历史"><a href="#13-操作系统历史" class="headerlink" title="13.操作系统历史"></a>13.操作系统历史</h2><blockquote>
<p>了解课堂上讲到的跟操作系统发展史相关的重要人物，并能介绍其主要贡献。</p>
</blockquote>
<ul>
<li>图灵</li>
</ul>
<p>计算机之父</p>
<ul>
<li>冯·诺伊曼</li>
</ul>
<p>提出了“存储程序”的概念和二进制原理</p>
<ul>
<li>linus</li>
</ul>
<p>编写第一个linux</p>
<ul>
<li>阿兰·马西森·图灵（1912-1917年6月23日）</li>
</ul>
<p>他在计算机科学的发展，提供概念的形式化“算法”和“计算”的图灵机，可以考虑通用计算机的模型。</p>
<p>图灵被广泛认为是理论计算机之父！</p>
<ul>
<li>Dijkstra</li>
</ul>
<p>同步进程通信的信号量</p>
<ul>
<li>Thompson</li>
</ul>
<p>用B语言写了第一个UNIX操作系统</p>
<h2 id="14-其它"><a href="#14-其它" class="headerlink" title="14.其它"></a>14.其它</h2><blockquote>
<p>作业中的难点问题需要掌握其解题方法。</p>
</blockquote>
<p>都包含在上面了。</p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2019/08/22/notepad/others/matlab%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"
                        >
                            <span class="left arrow-icon flex-center" >
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">matlab基础语法</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2019/06/05/notepad/compiling/easy_c/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">easy_c</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center" >
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                    
                </main>

            </div>

            <div class="page-main-content-bottom">
                <!--
 * @Author: Firefly
 * @Date: 2020-12-06 11:25:04
 * @Descripttion: 
 * @LastEditTime: 2020-12-06 17:25:59
-->
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2017</span> -
            
            2020 <i class="fas fa-heart icon-animate"></i> <a href="/">Firefly</a>
        </div>
        
    </div>
</footer>

            </div>
        </div>
    </main>

    <div class="sidebar-tools">
        <div class="tools-container">
    <ul class="tools-list">
        
            <li class="search popup-trigger">
                <i class="fas fa-search"></i>
            </li>
        

        

        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

    </ul>
</div>

    </div>

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">

    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center">
            <i class="fas fa-arrow-up"></i>
        </li>

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="tools-ul-1">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

    </ul>
</div>

    </div>

    <!-- page aside -->
    <aside class="page-aside">
        
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%8D%97"><span class="nav-number">1.</span> <span class="nav-text">操作系统复习指南</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-CPU-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">1.CPU 调度算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">2.进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8BAPI"><span class="nav-number">1.2.1.</span> <span class="nav-text">进程API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8BAPI"><span class="nav-number">1.2.2.</span> <span class="nav-text">线程API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5"><span class="nav-number">1.3.</span> <span class="nav-text">3.并发同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%EF%BC%9A"><span class="nav-number">1.3.1.</span> <span class="nav-text">死锁：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.4.</span> <span class="nav-text">4.地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%EF%BC%9A"><span class="nav-number">1.4.1.</span> <span class="nav-text">分配：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%EF%BC%9A"><span class="nav-number">1.4.2.</span> <span class="nav-text">释放：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%EF%BC%9A"><span class="nav-number">1.4.3.</span> <span class="nav-text">常见错误：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD"><span class="nav-number">1.5.</span> <span class="nav-text">5.同步原语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%EF%BC%9A"><span class="nav-number">1.5.1.</span> <span class="nav-text">锁：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E9%94%81"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">实现锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E4%B8%AD%E6%96%AD"><span class="nav-number">1.5.1.1.1.</span> <span class="nav-text">控制中断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TestAndSet"><span class="nav-number">1.5.1.1.2.</span> <span class="nav-text">TestAndSet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FetchAndAdd"><span class="nav-number">1.5.1.1.3.</span> <span class="nav-text">FetchAndAdd</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E4%B8%8D%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">实现公平不自旋锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.5.3.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">实现信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">信号量实现条件变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E9%94%81%EF%BC%89"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">二值信号量（锁）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">1.5.4.</span> <span class="nav-text">生产者消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E9%94%81"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">基于条件变量和锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">基于信号量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5"><span class="nav-number">1.6.</span> <span class="nav-text">6.分段与分页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%EF%BC%9A"><span class="nav-number">1.6.1.</span> <span class="nav-text">动态重定位：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%EF%BC%9A"><span class="nav-number">1.6.2.</span> <span class="nav-text">分段：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%EF%BC%9A"><span class="nav-number">1.6.3.</span> <span class="nav-text">分页：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">例子：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-TLB%EF%BC%8C-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.7.</span> <span class="nav-text">7.TLB， 多级页表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%981%EF%BC%9A-%E6%85%A2"><span class="nav-number">1.7.1.</span> <span class="nav-text">解决问题1： 慢</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB%EF%BC%9A"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">TLB：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%EF%BC%88%E6%B3%A8%E6%84%8F%E5%8A%A0%E7%B2%97%EF%BC%8C-%EF%BC%89%EF%BC%9A"><span class="nav-number">1.7.1.1.1.</span> <span class="nav-text">原理（注意加粗， ** **）：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">缓存：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E9%87%8C%E9%9D%A2%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">问题里面的问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TLB%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">1.7.1.3.1.</span> <span class="nav-text">TLB覆盖问题：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TLB%E7%9A%84%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5%EF%BC%9ALRU"><span class="nav-number">1.7.1.3.2.</span> <span class="nav-text">TLB的替换策略：LRU</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%982%EF%BC%9A-%E9%A1%B5%E8%A1%A8%E5%BE%88%E5%A4%A7%EF%BC%81"><span class="nav-number">1.7.2.</span> <span class="nav-text">解决问题2： 页表很大！</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E5%A4%A7%E7%9A%84%E9%A1%B5"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">更大的页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%AE%B5-%E5%88%86%E9%A1%B5"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">分段+分页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">多级页表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.8.</span> <span class="nav-text">8.页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FIFO"><span class="nav-number">1.8.1.</span> <span class="nav-text">FIFO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU"><span class="nav-number">1.8.2.</span> <span class="nav-text">LRU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%91%E4%BC%BCLRU"><span class="nav-number">1.8.3.</span> <span class="nav-text">近似LRU</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#clock%E7%AE%97%E6%B3%95"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">clock算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARC%E7%AE%97%E6%B3%95"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">ARC算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="nav-number">1.9.</span> <span class="nav-text">9.磁盘驱动器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">1.10.</span> <span class="nav-text">10.磁盘调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SJF"><span class="nav-number">1.10.1.</span> <span class="nav-text">SJF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSTF"><span class="nav-number">1.10.2.</span> <span class="nav-text">SSTF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCAN"><span class="nav-number">1.10.3.</span> <span class="nav-text">SCAN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPTF"><span class="nav-number">1.10.4.</span> <span class="nav-text">SPTF</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-RAID"><span class="nav-number">1.11.</span> <span class="nav-text">11.RAID</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID0"><span class="nav-number">1.11.1.</span> <span class="nav-text">RAID0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID1"><span class="nav-number">1.11.2.</span> <span class="nav-text">RAID1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID4"><span class="nav-number">1.11.3.</span> <span class="nav-text">RAID4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID5"><span class="nav-number">1.11.4.</span> <span class="nav-text">RAID5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="nav-number">1.11.5.</span> <span class="nav-text">性能比较：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.12.</span> <span class="nav-text">12.文件系统接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%86%E5%8F%B2"><span class="nav-number">1.13.</span> <span class="nav-text">13.操作系统历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E5%85%B6%E5%AE%83"><span class="nav-number">1.14.</span> <span class="nav-text">14.其它</span></a></li></ol></li></ol>
    </div>
</div>
        
    </aside>

    <!-- image viewer -->
    <div class="image-viewer-container">
    <div class="img-box">
        <img src="">
    </div>
</div>


</div>



    <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-icon">
            <i class="fas fa-search"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/local-search.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/left-side-toggle.js"></script>

    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/code-copy.js"></script>
    

    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/toc.js"></script>
    


</body>
</html>