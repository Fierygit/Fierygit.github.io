<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <title>
        Leetcode100 |
        
        Firefly
    </title>
    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true},"style":{"primary_color":"#0066CC","avatar":"images/avatar.png","favicon":"images/logo.svg","img_position":"left","left_side_width":"260px","content_max_width":"900px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":false,"description":"Welcome"}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"version":"3.0.3"};
    KEEP.language = {"search":"Search...","prev":"Prev","next":"Next","prev_posts":"Prev posts","next_posts":"Next posts","page":"Page %d","recent_posts":"Recent Posts","share":"Share","powered_by":"Powered by %s","theme":"Theme","rss_feed":"RSS Feed","category":"Category","categories":"Categories","tag":"Tag","tags":"Tags","tagcloud":"Tag Cloud","comment":"Comment","home":"Home","archive":"Archive","archives":"Archives","about":"About","site_uv":"Visitor Count","site_pv":"Totalview","links":"Links","link":"Link","top":"TOP","read_more":"Read more","wordcount":"Words","min2read":"Mins","changelog":"Changelog","copyright":{"author":"Post author","title":"Post title","link":"Post link","create_time":"Create time","license_title":"Copyright Notice","license_content":"All articles in this blog are licensed under %s unless stating additionally."},"ago":{"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days age","week":"%s weeks age","month":"%s months age","year":"%s years age"}};
  </script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
<div class="page-container">

    

    <header class="page-header">
        <div class="header-progress"></div>
    </header>

    <main class="page-main">

        <div class="page-main-content">

            <div class="page-main-content-top">
                <header class="header-wrapper">

    <div class="header-content">
        <a class="logo-title" href="/">
            Firefly
        </a>

        <ul class="menu-list">
            
                <li class="menu-item">
                    <a class=""
                       href="/"
                    >
                        HOME
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/archives"
                    >
                        ARCHIVES
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/categories"
                    >
                        CATEGORIES
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/links"
                    >
                        LINKS
                    </a>
                </li>
            
        </ul>

        <div class="menu-bar">
            <div class="menu-bar-middle"></div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">LINKS</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


            </div>

            <div class="page-main-content-middle">

                <main class="main-content normal-code-theme">

                    
                        <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Leetcode100</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span>Firefly</span>
                        <span class="level">Lv5</span>
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-calendar"></i> 2019-12-28 00:00:00
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>
            <ul>
                
                    <li>
                        <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i> <span>18k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i> <span>87 Mins</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="leetcode100-练习"><a href="#leetcode100-练习" class="headerlink" title="leetcode100 练习"></a><center>leetcode100 练习</center></h2><p>来源：力扣（LeetCode）<br>链接：<a class="link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers" >https://leetcode-cn.com/problems/add-two-numbers<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h4><blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
</blockquote>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/two-sum</span></span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>思路： 一开始看到这道题就是暴力，暴力不知道时间和空间够不够， 因此不写了，想了一会儿， 可以哈希一下，map[num[i]] = i,  用一个map来存储数据的值 和 下标， 这样遍历一遍就可以知道， 有没有 target - num[i]  对应的值， 如果有， 可以直接map到；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数字  map 下标</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            a[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>( a[temp] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[temp] != i)&#123;</span><br><span class="line">                    ans.push_back(i);</span><br><span class="line">                    ans.push_back(a[temp]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h4><blockquote>
<p> 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
</blockquote>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>刚拿到这道题的时候，想都没想，直接就遍历两条链表， 求出值， 然后再加起来， 结果是，给出了一个大于9位的数值，直接就超出了int的范围，看来我还是太年轻了，幼稚！！</p>
<p>然后看了下正确的题解， 遍历链表， 一位一位求， 像人工算超长的算法一样！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;      </span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* index = ans;</span><br><span class="line">        <span class="comment">//l l1 中的值； r l2 中的值；  a 进位</span></span><br><span class="line">        <span class="keyword">int</span> l, r, a;</span><br><span class="line">        l = r = a = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只要有一个不是空的就计算</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            l = l1 == <span class="literal">NULL</span> ? <span class="number">0</span> : l1-&gt;val;</span><br><span class="line">            r = l2 == <span class="literal">NULL</span> ? <span class="number">0</span> : l2-&gt;val;</span><br><span class="line">            <span class="comment">//计算每一位的和， 一开始a为0，没有进位</span></span><br><span class="line">            <span class="keyword">int</span> sum = l + r + a;    </span><br><span class="line">            sum -= sum&gt;= <span class="number">10</span> ? <span class="number">10</span> : <span class="number">0</span>; <span class="comment">//大于10的话减去10 进位</span></span><br><span class="line">            ListNode* temp = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            a = l + r + a&gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//指向答案下一个节点</span></span><br><span class="line">            index-&gt;next = temp;</span><br><span class="line">            index = temp;</span><br><span class="line">            <span class="comment">//响应移动</span></span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)   l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)   l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span><br><span class="line">             ListNode* temp = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">             index-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h4><blockquote>
<p> 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>


<p>​     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>思路：</p>
<p>一开始没考虑全题目的意思！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;  c;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c.find(s[i]) != c.end())&#123;</span><br><span class="line">                ans = c.size() &gt; ans? c.size() : ans;</span><br><span class="line">                c.clear();               </span><br><span class="line">            &#125;</span><br><span class="line">             c.insert(s[i]);    </span><br><span class="line">        &#125;</span><br><span class="line">        ans = c.size() &gt; ans? c.size() : ans; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>想都不用想肯定错了！</p>
<p>这道题的正确思路是滑动窗口的解题思想， 确保右边的“窗口”一定是没有重复的字母， 每次增加一个字符， 更新窗口的值，在这个过程中记录出现的最大值即为解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 滑动窗口 start 窗口的开始</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, max = <span class="number">0</span>, j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i ++)&#123;<span class="comment">// 每当加入一个字符</span></span><br><span class="line">            <span class="keyword">for</span>(j = start; j &lt; i; j ++)&#123;  <span class="comment">// 遍历新的窗口</span></span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                     start = j + <span class="number">1</span>;			<span class="comment">//找到第一个相等的字符</span></span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i - start + <span class="number">1</span> &gt; max)</span><br><span class="line">                max = i - start  + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="4-寻找两个有序数组的中位数todo"><a href="#4-寻找两个有序数组的中位数todo" class="headerlink" title="4.寻找两个有序数组的中位数todo"></a>4.寻找两个有序数组的中位数todo</h4><blockquote>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
</blockquote>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line">则中位数是 <span class="number">2.0</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">则中位数是 (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>



<p>//todo 没弄懂</p>
<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h4><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出: <span class="string">&quot;bab&quot;</span></span><br><span class="line">注意: <span class="string">&quot;aba&quot;</span> 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出: <span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>



<p>解题思路：</p>
<p>题解一： 中心查找</p>
<p>遍历一遍字符串， 如果当前的字符不对称就开始检查，现在是否为最大的回文串, 是就更新！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> size = len * <span class="number">2</span> - <span class="number">1</span>;<span class="comment">//一共有 2*n - 1 个重点</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;<span class="comment">//字符本身为中点</span></span><br><span class="line">                <span class="keyword">int</span> mid = i / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(mid - j &gt;= <span class="number">0</span> &amp;&amp; mid + j &lt; len</span><br><span class="line">                &amp;&amp; s[mid-j] == s[mid+j]) j++;</span><br><span class="line">                maxi = <span class="number">2</span> * j - <span class="number">1</span> &gt; max ? i : maxi;</span><br><span class="line">                max = <span class="number">2</span> * j - <span class="number">1</span> &gt; max ? <span class="number">2</span> * j - <span class="number">1</span> : max;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxi &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxi/ <span class="number">2</span> &lt;&lt;  <span class="string">&quot; *0*&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)&#123;<span class="comment">//不是以字符本身为中点</span></span><br><span class="line">                <span class="keyword">int</span> left = i / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(left - j &gt;= <span class="number">0</span> &amp;&amp; right + j &lt; len &amp;&amp; </span><br><span class="line">                s[left - j] == s[right + j]) j++;</span><br><span class="line">                maxi = <span class="number">2</span> * j &gt; max ? i : maxi;</span><br><span class="line">                max = <span class="number">2</span> * j &gt; max ? <span class="number">2</span> * j : max;   </span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxi &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxi/ <span class="number">2</span> &lt;&lt;  <span class="string">&quot; *1*&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxi &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(maxi % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.substr(maxi / <span class="number">2</span> - (max/<span class="number">2</span>), max);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> s.substr(maxi / <span class="number">2</span> - max/<span class="number">2</span> +<span class="number">1</span>, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>题解二： 动态规划</p>
<p>p[ i ] [ j ] 表示 i 到 j 为回文串！</p>
<p>递推式：</p>
<p>p[i+1] [j+1] =  p[ i ] [ j ] + s[i+1] [j+1];</p>
<p>p[i] [j] = (i == j - 1 ) &amp;&amp; s[i] [j - 1];</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">bool</span> flag[len][len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max, l;</span><br><span class="line">        l = max = <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">                flag[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i ++)  flag[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++)&#123;      </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(j == i - <span class="number">1</span> &amp;&amp; s[j] == s[i])&#123;</span><br><span class="line">                    flag[j][i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(  max &lt; i - j ) max = i - j , l = j;</span><br><span class="line">                 &#125; </span><br><span class="line">                 <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; flag[j][i<span class="number">-1</span>] &amp;&amp; s[j<span class="number">-1</span>] == s[i])&#123;</span><br><span class="line">                    flag[j<span class="number">-1</span>][i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(  max &lt; i - (j - <span class="number">1</span>) ) max = i - j + <span class="number">1</span>, l = j<span class="number">-1</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(l,max+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="6-Z字型变换"><a href="#6-Z字型变换" class="headerlink" title="6. Z字型变换"></a>6. Z字型变换</h4><blockquote>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
</blockquote>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<p>L    C     I        R<br>E T O E S  I     I  G<br>E    D    H       N<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<p>string convert(string s, int numRows);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;LEETCODEISHIRING&quot;</span>, numRows = <span class="number">3</span></span><br><span class="line">输出: <span class="string">&quot;LCIRETOESIIGEDHN&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;LEETCODEISHIRING&quot;</span>, numRows = <span class="number">4</span></span><br><span class="line">输出: <span class="string">&quot;LDREOEIIECIHNTSG&quot;</span></span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>这道题首先想到的是使用找规律， 规律其实很好找！</p>
<p>看到题解中有一个很不错的思路，是把这个的过程直接转换成代码的形式， 好多的题都是这样的！</p>
<p>之前不知道这种做法， 真的是孤陋寡闻！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">		<span class="comment">// 这个表示每一行的字符</span></span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">rows</span><span class="params">(min(numRows, <span class="keyword">int</span>(s.size())))</span></span>; <span class="comment">// 防止s的长度小于行数</span></span><br><span class="line">		<span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">bool</span> goingDown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">			rows[curRow] += c;</span><br><span class="line">			<span class="keyword">if</span> (curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>) &#123;<span class="comment">// 当前行curRow为0或numRows -1时，箭头发生反向转</span></span><br><span class="line">				goingDown = !goingDown;</span><br><span class="line">			&#125;</span><br><span class="line">			curRow += goingDown ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">string</span> ret;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">string</span> row : rows) &#123;<span class="comment">// 从上到下遍历行</span></span><br><span class="line">			ret += row;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h4><blockquote>
<p> 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">123</span></span><br><span class="line">输出: <span class="number">321</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">-123</span></span><br><span class="line">输出: <span class="number">-321</span></span><br></pre></td></tr></table></figure>

<p>==注意:==</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>思路：</p>
<p>这道题最重要的是判断是否溢出， 用一个更大的来存， 或者直接判断（笨方法）。</p>
<p>请你记住下面这两个的求法！！！</p>
<p>MAX_INT = (unsigned)(-1)&gt;&gt;1;<br>MIN_INT = ~MAX_INT;</p>
<p>或者</p>
<p>MIN_INT = 1 &lt;&lt; 31;</p>
<p>MAX_INT = ~MAX_INT;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首次找到最大的int值</span></span><br><span class="line">        <span class="keyword">int</span> MAX_INT, MIN_INT;</span><br><span class="line">        MAX_INT = (<span class="keyword">unsigned</span>)(<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        MIN_INT = ~MAX_INT;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; MAX_INT ||  ans &lt; MIN_INT) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8.字符串转换整数 (atoi)"></a>8.字符串转换整数 (atoi)</h4><blockquote>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
</blockquote>
<ul>
<li><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
</li>
<li><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
</li>
<li><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
</li>
<li><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
</li>
<li><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
</li>
</ul>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 −  1]。如果数值超过这个范围，请返回  INT_MAX (2^31 −  1) 或 INT_MIN (−2^31) 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;42&quot;</span></span><br><span class="line">输出: <span class="number">42</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;   -42&quot;</span></span><br><span class="line">输出: <span class="number">-42</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;4193 with words&quot;</span></span><br><span class="line">输出: <span class="number">4193</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;words and 987&quot;</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;-91283472332&quot;</span></span><br><span class="line">输出: <span class="number">-2147483648</span></span><br></pre></td></tr></table></figure>

<p>解题思路： 直接暴力， 暴力求解！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (1&lt;&lt;31)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX ~INT_MIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> firstnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>  len = str.length();</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;       </span><br><span class="line">             <span class="keyword">if</span>(!firstnum)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(str[i] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(str[i]) &amp;&amp; !(str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">                     <span class="keyword">return</span> <span class="number">0</span>;               </span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;+&#x27;</span>)&#123;                  </span><br><span class="line">                    f = str[i] == <span class="string">&#x27;-&#x27;</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                 &#125;<span class="keyword">else</span> ans = ans * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);             </span><br><span class="line">                firstnum = <span class="number">1</span>;           </span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(str[i]))&#123;</span><br><span class="line">                ans = ans * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span>(f &amp;&amp; (ans &gt; INT_MAX )) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ans &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> f ? ~(<span class="keyword">int</span>)ans + <span class="number">1</span>:(<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h4><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">121</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">-121</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>你能不将整数转为字符串来解决这个问题吗？</p>
<p>我就直接用字符串处理解决这道题了，还可以用数字反转处理！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; x;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        ss &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; temp.length() / <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(temp[i] != temp[temp.length() - i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10.正则表达式匹配"></a>10.正则表达式匹配</h4><blockquote>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
</blockquote>
<blockquote>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
</blockquote>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">p = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: <span class="string">&quot;a&quot;</span> 无法匹配 <span class="string">&quot;aa&quot;</span> 整个字符串。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">p = <span class="string">&quot;a*&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">&#x27;a&#x27;</span>。</span><br><span class="line">     因此，字符串 <span class="string">&quot;aa&quot;</span> 可被视为 <span class="string">&#x27;a&#x27;</span> 重复了一次。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;ab&quot;</span></span><br><span class="line">p = <span class="string">&quot;.*&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: <span class="string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="string">&#x27;*&#x27;</span>）任意字符（<span class="string">&#x27;.&#x27;</span>）。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;aab&quot;</span></span><br><span class="line">p = <span class="string">&quot;c*a*b&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">&#x27;*&#x27;</span> 表示零个或多个，这里 <span class="string">&#x27;c&#x27;</span> 为 <span class="number">0</span> 个, <span class="string">&#x27;a&#x27;</span> 被重复一次。因此可以匹配字符串 <span class="string">&quot;aab&quot;</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;mississippi&quot;</span></span><br><span class="line">p = <span class="string">&quot;mis*is*p*.&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<p>这道题利用的是递归的思想， 我是一步一步增加考虑的情况，</p>
<p>我下面的代码其实可以合并， 合并后可以更加简洁，跟题解是一样的，但我认为初次做这道题， 一下子合并代码的话不容易理解！！</p>
<p>具体的思路都在注释里面！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这是消除相同的闭包， 不然会超时， 比如a*a*a*a*a*其实一个a*和很多个是没有区别的！！</span></span><br><span class="line">       <span class="comment">// 但是处理的情况却多了很多， 比如第一个a* 会考虑 直接匹配a 也可以不匹配a让后面的匹配，</span></span><br><span class="line">        <span class="comment">// 每一个a* 都是这样考虑这就是一个指数函数了！！！</span></span><br><span class="line">        <span class="keyword">if</span>(p.length() &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[i+<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; i + <span class="number">3</span> &lt;  p.length() </span><br><span class="line">                &amp;&amp; p[i+<span class="number">3</span>] ==<span class="string">&#x27;*&#x27;</span> &amp;&amp; p[i] == p[i+<span class="number">2</span>])&#123;</span><br><span class="line">                    p = p.substr(<span class="number">0</span>, i) + p.substr(i + <span class="number">2</span>, p.length() - i - <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s :  &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;   &quot;</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; P : &quot;</span> &lt;&lt; p &lt;&lt;<span class="built_in">endl</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果pattern 空了， 但是s还没有空的话肯定错了</span></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="string">&quot;&quot;</span>)   <span class="keyword">return</span> s == <span class="string">&quot;&quot;</span> ? <span class="literal">true</span> : <span class="literal">false</span>;  </span><br><span class="line">        <span class="comment">// 如果字符空了， 但是p还没空， 那就删除一个闭包，因为闭包可以为空，</span></span><br><span class="line">        <span class="comment">// 比如 s == “” p == “a*” 这个是可以匹配的！</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> p.length() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> ?  </span><br><span class="line">            isMatch(s,p.substr(<span class="number">2</span>,p.length() - <span class="number">2</span>)) : <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//第一种情况， 一个 . 的情况</span></span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; (p.length() &gt;=<span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span> || p.length() == <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substr(<span class="number">1</span>,s.length() - <span class="number">1</span>),p.substr(<span class="number">1</span>,p.length() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二种  .* 的情况， 返回有两种情况 1、闭包为空， 2、闭包不为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; p.length() &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  isMatch(s,p.substr(<span class="number">2</span>,p.length() - <span class="number">2</span>)) || isMatch(s.substr(<span class="number">1</span>,s.length() - <span class="number">1</span>),p) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第三种情况 字符相同但不是闭包的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">0</span>] == s[<span class="number">0</span>] &amp;&amp; (p.length() &gt;=<span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span> || p.length() == <span class="number">1</span>) )&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substr(<span class="number">1</span>,s.length() - <span class="number">1</span>), p.substr(<span class="number">1</span>,p.length() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第四种情况 字符相同且是闭包的情况</span></span><br><span class="line">        <span class="comment">// 返回也有两种： 1、 闭包为空 2、 闭包吃掉一个字符</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">0</span>] == s[<span class="number">0</span>] &amp;&amp; (p.length() &gt;=<span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substr(<span class="number">2</span>,p.length() - <span class="number">2</span>)) ||isMatch(s.substr(<span class="number">1</span>,s.length() - <span class="number">1</span>),p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个情况， 字符不相同， 但是p有闭包， 闭包可以为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">0</span>] != s[<span class="number">0</span>] &amp;&amp; p.length() &gt;=<span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s,p.substr(<span class="number">2</span>,p.length() - <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其它情况的话就是匹配不了的了，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h4><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x hyj轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" style="zoom:80%;" />

<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">49</span></span><br></pre></td></tr></table></figure>

<p>首先思路简单：直接暴力可以通过！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span> ; i &lt; len; i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (i - j) * min(height[i],height[j]);</span><br><span class="line">                ans = temp &gt; ans ? temp : ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当这道题肯定没有这么简单就过了， 暴力应该不是出题人的本意！</p>
<p>leetco的题解上抄的！ Terry su</p>
<p>简单反证法证明：通过双指针方法，两个指针一定会同时经过最大面积对应的指针位置。</p>
<p>假设mn是最大的面积</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                  |                     </span><br><span class="line">           |      |                     </span><br><span class="line">           |      |                     </span><br><span class="line">     ......|......|......               </span><br><span class="line">——————————————————————————————————————— </span><br><span class="line">           m      n</span><br></pre></td></tr></table></figure>

<p>假设有条边p更高在外面，</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        |                                </span><br><span class="line">        |          |                     </span><br><span class="line">        |   |      |                     </span><br><span class="line">        |   |      |                     </span><br><span class="line">     ...|...|......|......               </span><br><span class="line">——————————————————————————————————————— </span><br><span class="line">        p   m      n</span><br></pre></td></tr></table></figure>

<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AreaMN = ( <span class="name">n</span> - m ) * min( <span class="name">arr</span>[ m ], arr[ n ] )</span><br><span class="line">AreaPN = ( <span class="name">n</span> - p ) * min( <span class="name">arr</span>[ p ], arr[ n ] )</span><br></pre></td></tr></table></figure>

<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(  <span class="name">n</span> - m ) &lt;= ( <span class="name">n</span> - p )</span><br><span class="line"> min( <span class="name">arr</span>[ m ], arr[ n ] ) &lt;= min( <span class="name">arr</span>[ p ], arr[ n ] )</span><br></pre></td></tr></table></figure>

<p>所以： <code>AreaMN &lt; AreaPN</code>, 与m和n构成最大面积相矛盾，所以假设不成立，即m左侧的点都不高于n，即等于或矮于n。同理可证，n右侧指针等于或矮于m。所以通过双指针方法，两个指针一定会同时经过最大面积对应的指针位置。</p>
<p>原理明白了， 代码自然简单！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b? b : a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (r - l) * min(height[l],height[r]);</span><br><span class="line">            max = max &lt; temp? temp : max;</span><br><span class="line">            <span class="keyword">if</span>(height[l] &lt; height[r]) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a>12.整数转罗马数字</h4><blockquote>
<p> 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></table></figure>


<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><br><span class="line">X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><br><span class="line">C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="string">&quot;III&quot;</span></span><br></pre></td></tr></table></figure>

<p>这道是我做过简答的， 相当于找钱，每次找最大面额的钱！</p>
<p>我应该是做过类似的题， 不然我不会一看到代码就直接会思路了， 这应该就是刷题的好处了！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">        m[<span class="number">1000</span>] = <span class="string">&quot;M&quot;</span>;</span><br><span class="line">        m[<span class="number">900</span>] = <span class="string">&quot;CM&quot;</span>;</span><br><span class="line">        m[<span class="number">500</span>] = <span class="string">&quot;D&quot;</span>;</span><br><span class="line">        m[<span class="number">400</span>] = <span class="string">&quot;CD&quot;</span>;</span><br><span class="line">        m[<span class="number">100</span>] = <span class="string">&quot;C&quot;</span>;</span><br><span class="line">        m[<span class="number">90</span>] = <span class="string">&quot;XC&quot;</span>;</span><br><span class="line">        m[<span class="number">50</span>] = <span class="string">&quot;L&quot;</span>;</span><br><span class="line">        m[<span class="number">40</span>] = <span class="string">&quot;XL&quot;</span>;</span><br><span class="line">        m[<span class="number">10</span>] = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">        m[<span class="number">9</span>] = <span class="string">&quot;IX&quot;</span>;</span><br><span class="line">        m[<span class="number">5</span>] = <span class="string">&quot;V&quot;</span>;</span><br><span class="line">        m[<span class="number">4</span>] = <span class="string">&quot;IV&quot;</span>;</span><br><span class="line">        m[<span class="number">1</span>] =  <span class="string">&quot;I&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> range[] = &#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span> ; i++)</span><br><span class="line">            <span class="keyword">while</span>(num &gt;= range[i]) ans += m[range[i]], num-=range[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h4><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;III&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>解题思路： 12 题反过来， 顺序遍历字符串， 全部加起来， 如果前面的比后面的小要双倍减去，一看代码就明白了！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        m[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        m[<span class="string">&#x27;V&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">        m[<span class="string">&#x27;X&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">        m[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">        m[<span class="string">&#x27;C&#x27;</span>] = <span class="number">100</span>;</span><br><span class="line">        m[<span class="string">&#x27;D&#x27;</span>] = <span class="number">500</span>;</span><br><span class="line">        m[<span class="string">&#x27;M&#x27;</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!i)&#123;</span><br><span class="line">                ans += m[s[i]];<span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m[s[i]] &gt; m[s[i - <span class="number">1</span>]])&#123;</span><br><span class="line">                ans -= <span class="number">2</span> * m[s[i - <span class="number">1</span>]]; <span class="comment">// 加倍奉还</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans+= m[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="14-最长公共子串"><a href="#14-最长公共子串" class="headerlink" title="14.最长公共子串"></a>14.最长公共子串</h4><blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
</blockquote>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>]</span><br><span class="line">输出: <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>暴力，^_~</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.size() == <span class="number">0</span>)  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">char</span> com;</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strs.size(); i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> temp = strs[i];</span><br><span class="line">                <span class="keyword">if</span>(temp.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span>(!i) com = temp[index];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(com  !=  temp[index])</span><br><span class="line">                    <span class="keyword">return</span> ans;               </span><br><span class="line">                <span class="keyword">if</span>(index == temp.length() - <span class="number">1</span>) flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt;<span class="built_in">endl</span>;     </span><br><span class="line">            ans += com;     </span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> ans;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;              </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h4><blockquote>
<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
</blockquote>
<p>注意：答案中不可以包含重复的三元组。</p>
<p> 解题思路：</p>
<p>首先这题可以变成一个两数之和题目， 然后一个for循环找nums 里的一个数等于这个两数之和；</p>
<p>所以这道题首先要会两数之和的做法：</p>
<blockquote>
<p>两数之和等于0(特例=0)</p>
</blockquote>
<p>先将数组排序， 然后利用双指针一个在左边， 一个在右边， 如果指针对应的两个数的和大于0， 则右边指针减1，小于则左边加， 直到相遇， 如果相遇了还没有找到答案就没有解， 这个算法容易，但是怎么证明？</p>
<p>想了很久很久。。。。。。</p>
<p>证明：</p>
<p>首先这个算法有三种情况</p>
<ul>
<li><p>和等于0</p>
<p> 随机一个指针往里面移动，比如（-2  -1 1 2）  现在有两个答案， 找到等于0的 -2 2 后， 假设2左移到1，之后 -2 + 1 &lt; 0, 因此左边 右移， -1 + 1 这个答案也找到了！！</p>
</li>
<li><p>和小于0， 左指针右移</p>
</li>
<li><p>和大于0， 右指针左移</p>
</li>
</ul>
<p>现在考虑后面这两种情况， 只有两种选择， 因此这两个指针一定会移到答案（如果有）的其中一个因子上！</p>
<p>上面这句话其实好理解， 因为如果有答案， 算法的停止条件是left  &lt; right, 已经遍历了所有的项了！</p>
<p>再举个例子：  两数之和等于 16</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-8 -6 5 7 11 17 22（答案可以看出 5  11）</span><br></pre></td></tr></table></figure>

<p>现在再来考虑两种情况：</p>
<p>1、假设 右指针 <strong>先</strong> 移到  11（刚好这道题是），</p>
<p>那么此时无论左边指针移到哪里， 反正就是小于5， 那么条件为真的只有左指针右移，直到找到答案！</p>
<p>2、 假设 左指针 <strong>先</strong> 移到  5</p>
<p>那么此时无论右指针在哪里， 反正就是大于11，条件为真的只有右指针左移，直至找到答案或相遇！</p>
<p>3、一次只移动左指针或右指针， 不会同时移到答案的两个， 也就是 5  和 11！！</p>
<p>综上上面四点（包括一定会一个先移到答案）， 可以证明， 如果有答案一定可以找到这个答案！！</p>
<p>三数之和就好解了！！！看注释就会了！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>]，</span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> le, ri,sum;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            le = i + <span class="number">1</span>;<span class="comment">//不重头开始是为了 去重1</span></span><br><span class="line">            ri = len - <span class="number">1</span>;      </span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">//这个也是 去重1， 具体自己想</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 第三项 作为 两数之和的相反数 相同， 去重2</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(le &lt; ri)&#123;</span><br><span class="line">                sum = nums[i] + nums[le] + nums[ri];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;nums[le],nums[i],nums[ri]&#125;;</span><br><span class="line">                    ans.push_back(a);   </span><br><span class="line">                    <span class="comment">//下面两个 去重2！！！</span></span><br><span class="line">                    <span class="keyword">while</span>(le &lt; ri  &amp;&amp; nums[le] == nums[le + <span class="number">1</span>]) le++;</span><br><span class="line">                    <span class="keyword">while</span>(le &lt; ri  &amp;&amp; nums[ri] == nums[ri - <span class="number">1</span>]) ri--;     </span><br><span class="line">                &#125;                       </span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) ri--;</span><br><span class="line">                <span class="keyword">else</span> le++; <span class="comment">// 这个包含相同时的移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去重1    a + b + c = 0  如果不去重， a作为 i 得到一个答案， b作为i得到一个答案, c作为i得到一个答案</span></span><br><span class="line"><span class="comment">//去重2    数组中含有相同的数子     a1 + b + c = 0    a2 + b + c = 0</span></span><br></pre></td></tr></table></figure>

<p><img src="images/image-20200114220202937.png" alt="image-20200114220202937"></p>
<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16.最接近的三数之和"></a>16.最接近的三数之和</h4><blockquote>
<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">-1</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">-4</span>], 和 target = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 <span class="number">2.</span> (<span class="number">-1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>
<p>思路就是和三数之和一样不同的是多一个判断！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> le, ri;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            le = i + <span class="number">1</span>;</span><br><span class="line">            ri = len - <span class="number">1</span>;    </span><br><span class="line">            <span class="keyword">while</span>(le &lt; ri)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[le] + nums[ri] ;   </span><br><span class="line">                <span class="comment">//while(le &lt; ri &amp;&amp; nums[le] == nums[le+1]) le++;</span></span><br><span class="line">                <span class="comment">//while(le &lt; ri &amp;&amp; nums[ri] == nums[ri-1]) ri--;       </span></span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; &quot; sum: &quot; &lt;&lt; sum &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;    </span></span><br><span class="line">                <span class="keyword">if</span>(sum ==  target) <span class="keyword">return</span> target; <span class="comment">//已经最进了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                    le++;</span><br><span class="line">                    <span class="keyword">if</span>(num &gt;=  target - sum)&#123;</span><br><span class="line">                        num = target -sum;</span><br><span class="line">                        ans = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ri--;</span><br><span class="line">                    <span class="keyword">if</span>(num &gt;= sum - target)&#123;</span><br><span class="line">                        num = sum - target;</span><br><span class="line">                        ans = sum;</span><br><span class="line">                    &#125;                 </span><br><span class="line">                &#125;                 </span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; &quot; i: &quot; &lt;&lt; i &lt;&lt; &quot; *&quot; &lt;&lt; endl;</span></span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h4><blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
</blockquote>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200115170558.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">&quot;23&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;ad&quot;</span>, <span class="string">&quot;ae&quot;</span>, <span class="string">&quot;af&quot;</span>, <span class="string">&quot;bd&quot;</span>, <span class="string">&quot;be&quot;</span>, <span class="string">&quot;bf&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;ce&quot;</span>, <span class="string">&quot;cf&quot;</span>].</span><br><span class="line">说明:</span><br><span class="line">尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</span><br></pre></td></tr></table></figure>

<p>我用的是广搜！这道搞人的地方是 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;cao&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2 = str[<span class="number">0</span>] + <span class="string">&quot;&quot;</span>; <span class="comment">//不行</span></span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;b&#x27;</span>; <span class="comment">//不行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; m;  </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution()&#123;</span><br><span class="line">        m[<span class="string">&#x27;2&#x27;</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;3&#x27;</span>] = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;4&#x27;</span>] = <span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;5&#x27;</span>] = <span class="string">&quot;jkl&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;6&#x27;</span>] = <span class="string">&quot;mno&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;7&#x27;</span>] = <span class="string">&quot;pqrs&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;8&#x27;</span>] = <span class="string">&quot;tuv&quot;</span>;</span><br><span class="line">        m[<span class="string">&#x27;9&#x27;</span>] = <span class="string">&quot;wxyz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;     </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans, next;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">string</span> str = m[digits[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">if</span>(digits.length() &gt; <span class="number">1</span>)</span><br><span class="line">            next = letterCombinations(digits.substr(<span class="number">1</span>, digits.length() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits.length() &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; next.size(); j ++)</span><br><span class="line">                    ans.push_back(str[i] + next[j]);     </span><br><span class="line">            <span class="keyword">else</span>    ans.push_back(str.substr(i,<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="18-做不出"><a href="#18-做不出" class="headerlink" title="18. 做不出"></a>18. 做不出</h4><h4 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h4><blockquote>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 n = <span class="number">2.</span></span><br><span class="line">当删除了倒数第二个节点后，链表变为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure>


<p>说明：</p>
<p>给定的 n 保证是有效的。</p>
<p>进阶：</p>
<p>你能尝试使用一趟扫描实现吗？使用hashmap</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* first= <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* second = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        first = second = head;</span><br><span class="line">        <span class="keyword">while</span>( first-&gt;next != <span class="literal">NULL</span> &amp;&amp;  n-- ) first = first-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(first-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            first = first-&gt;next, second = second-&gt;next;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h4><blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
</blockquote>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;()&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>思路：<br>使用一个栈来存就行了！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.size() == <span class="number">0</span> ||st.top() != <span class="string">&#x27;(&#x27;</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> st.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( s[i] == <span class="string">&#x27;]&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.size() == <span class="number">0</span> || st.top() != <span class="string">&#x27;[&#x27;</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> st.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( s[i] == <span class="string">&#x27;&#125;&#x27;</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span>( st.size() == <span class="number">0</span> || st.top() != <span class="string">&#x27;&#123;&#x27;</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> st.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> st.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h4><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>思路没什么思路， 就是归并排序的最后一步！！！ 相当于又写了一遍归并排序！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* index = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        index = ans;</span><br><span class="line">		<span class="comment">//一步一步想！！！！</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="literal">NULL</span> ) index-&gt;next = l1, l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> ) index-&gt;next = l2, l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) index-&gt;next = l1, l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> index-&gt;next = l2, l2 = l2-&gt;next;</span><br><span class="line">            index = index-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简化后的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* index = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        index = ans;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="literal">NULL</span> ) index-&gt;next = l1, l1 = l1-&gt;next;</span><br><span class="line">            <span class="comment">//下面代码 l2 肯定不为空了， l1为空了 就直接跳过后面的了， 所以可以直接合并</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">NULL</span> || l1-&gt;val &gt;= l2-&gt;val ) index-&gt;next = l2, l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> index-&gt;next = l1, l1 = l1-&gt;next;</span><br><span class="line">            index = index-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="22-有效括号"><a href="#22-有效括号" class="headerlink" title="22.有效括号"></a>22.有效括号</h4><blockquote>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例如，给出 n = <span class="number">3</span>，生成结果为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  <span class="string">&quot;((()))&quot;</span>,</span><br><span class="line">  <span class="string">&quot;(()())&quot;</span>,</span><br><span class="line">  <span class="string">&quot;(())()&quot;</span>,</span><br><span class="line">  <span class="string">&quot;()(())&quot;</span>,</span><br><span class="line">  <span class="string">&quot;()()()&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>思路： 一开始我想到的是广搜， 广搜虽好，但是会超内存， 因为要一个栈来存储答案， 于时就改成了深搜，深搜一定要剪枝！</p>
<p>广搜如果保留太多的信息会让内存超出限制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans = &#123;<span class="string">&quot;(&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span>  bfs(ans,<span class="number">1</span>,<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;  <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; m, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> len)</span></span>&#123;    </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans; </span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= len &amp;&amp; right == len) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp = m;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)&#123;          </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.size(); j++) temp[j] += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                temp = bfs(temp,left, right+<span class="number">1</span>,len);</span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.size(); i++) m[i] += <span class="string">&quot;(&quot;</span>;</span><br><span class="line">            ans =  bfs(m,left +<span class="number">1</span> , right,len);</span><br><span class="line">            <span class="keyword">if</span>(temp.size() != <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++)</span><br><span class="line">                    ans.push_back(temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改一下不用临时变量， 还他么超了?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        bfs(ans,<span class="number">1</span>,<span class="number">0</span>,n,<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> len, <span class="built_in">string</span> cur)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= len &amp;&amp; right == len)&#123;</span><br><span class="line">            ans.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left != right)  </span><br><span class="line">                bfs(ans,left, right+<span class="number">1</span>, len,cur + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            bfs(ans,left+<span class="number">1</span>,right, len, cur + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再改！！</p>
<p>只有改dfs了, dfs的剪枝很重要</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        dfs(ans,n,<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="keyword">int</span> len, <span class="built_in">string</span> cur)</span></span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(!valid(len, cur)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(valid(len, cur) == <span class="number">1</span>)</span><br><span class="line">             ans.push_back(cur); </span><br><span class="line">        dfs(ans, len, cur+ <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        dfs(ans, len, cur+ <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> len, <span class="built_in">string</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        right = left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur[i] == <span class="string">&#x27;(&#x27;</span>) left++;</span><br><span class="line">            <span class="keyword">else</span> right++;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt; len  || left &lt; right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == len &amp;&amp; right == len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23.合并K个排序链表"></a>23.合并K个排序链表</h4><blockquote>
<p> 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>解题思路， 每次将链表合并到一个总的链表上</p>
<p>时间复杂度分析：</p>
<p>前两个合并， 一共有n个节点，评分 n/k 个节点每条，</p>
<p>前两条合并为 n*2 / k ， 之后每次合并都要加上之前的</p>
<p>x + x + 2x + x + 3x  + x + 4x + x + ……..(k-1)x + x = kx + k^2 / 2 x = k^2 * x = k ^2 * (n*2/k) = kx</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!i) ans = lists[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                ListNode* index = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                head = index;</span><br><span class="line">                <span class="keyword">while</span>(lists[i] != <span class="literal">NULL</span> || ans!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(lists[i] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                            index-&gt;next = ans;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ans == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                            index-&gt;next = lists[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ans-&gt;val &gt;= lists[i]-&gt;val)&#123;</span><br><span class="line">                            index-&gt;next = lists[i];</span><br><span class="line">                            lists[i] = lists[i]-&gt;next;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            index-&gt;next = ans;</span><br><span class="line">                            ans = ans-&gt;next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        index = index-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = head-&gt;next;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="24-两两交换链表-todo"><a href="#24-两两交换链表-todo" class="headerlink" title="24.两两交换链表 todo"></a>24.两两交换链表 todo</h4><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例:</p>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> ListNode(<span class="number">0</span>),*tmp = res;</span><br><span class="line">        res-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next != <span class="literal">NULL</span> &amp;&amp; tmp-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode *start = tmp-&gt;next,*end = tmp-&gt;next-&gt;next;</span><br><span class="line">            tmp-&gt;next = end;</span><br><span class="line">            start-&gt;next = end-&gt;next;</span><br><span class="line">            end-&gt;next = start;</span><br><span class="line">            tmp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="25-k个一组翻转链表"><a href="#25-k个一组翻转链表" class="headerlink" title="25.k个一组翻转链表"></a>25.k个一组翻转链表</h4><blockquote>
<p> 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
</blockquote>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定这个链表：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">当 k = <span class="number">2</span> 时，应当返回: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">当 k = <span class="number">3</span> 时，应当返回: <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>说明 :</p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>思路： 其实就是暴力</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;   </span><br><span class="line">        ListNode * index = head;   </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(index == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> index = index-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(i == k <span class="number">-1</span> )  flag = <span class="number">1</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;       </span><br><span class="line">            <span class="keyword">while</span>(head != index)&#123;</span><br><span class="line">                next = head-&gt;next;</span><br><span class="line">                head-&gt;next = pre;</span><br><span class="line">                pre = head;</span><br><span class="line">                head = next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp-&gt;next = reverseKGroup(index,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pre = head;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="26-下一个排列"><a href="#26-下一个排列" class="headerlink" title="26. 下一个排列"></a>26. 下一个排列</h4><p>123的全排列为</p>
<p>123     132     213    231     312    321</p>
<p>123的下一排列为132， 321没有所以为123</p>
<p>直接思路：</p>
<p>从后面往前找，先找出最大的索引 k 满足 nums[k] &lt; nums[k+1]，如果不存在，就翻转整个数组；<br>从后面往前找，再找出另一个最大索引 l 满足 nums[l] &gt; nums[k]；一定有一个的<br>交换 nums[l] 和 nums[k]；<br>最后翻转 nums[k+1:]。</p>
<p>思路： 这道题主要理解排列的意思， 翻译过来就是上面的解法， </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!i) reverse(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//第一个前面大的</span></span><br><span class="line">            <span class="keyword">if</span>(i &amp;&amp; nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[j] &gt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                        nums[j] = nums[ i - <span class="number">1</span>];</span><br><span class="line">                        nums[i - <span class="number">1</span>] = temp;</span><br><span class="line">                        reverse(nums,i,nums.size() - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= (end + start) / <span class="number">2</span>; i++)&#123;</span><br><span class="line">           temp = nums[i];</span><br><span class="line">           nums[i] = nums[end - i + start];</span><br><span class="line">           nums[end - i + start]  = temp;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="27-最长有效括号"><a href="#27-最长有效括号" class="headerlink" title="27. 最长有效括号"></a>27. 最长有效括号</h4><blockquote>
<p> 给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>从左边向右遍历， 如果当前的左括号小于右括号证明是没有用的，从新开始计数， 如果当前的左括号等于右括号是一个有效值，判断是否为最大值， 右边一样！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ri, le, ans;</span><br><span class="line">        ri = le = ans = <span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) le++;</span><br><span class="line">            <span class="keyword">else</span> ri++;</span><br><span class="line">            <span class="keyword">if</span>(le == ri) ans = ans &gt; le * <span class="number">2</span> ? ans : le * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(le &lt; ri) le = ri = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ri = le = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) le++;</span><br><span class="line">            <span class="keyword">else</span> ri++;</span><br><span class="line">            <span class="keyword">if</span>(le == ri) ans = ans &gt; le * <span class="number">2</span> ? ans : le * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(le &gt; ri) le = ri = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="28-搜索旋转排序数组"><a href="#28-搜索旋转排序数组" class="headerlink" title="28. 搜索旋转排序数组"></a>28. 搜索旋转排序数组</h4><blockquote>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
</blockquote>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>这题主要理解的问题是，一个旋转之后的数组，拆成两半， 总有一个半是有效的！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> devideSearch(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">devideSearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> le, <span class="keyword">int</span> ri , <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ri == le) <span class="keyword">return</span> nums[ri] == target? ri : <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// if(ri - le == 1)&#123;</span></span><br><span class="line">        <span class="comment">//     if(nums[ri] == target) return  ri;</span></span><br><span class="line">        <span class="comment">//     else if( nums[le] == target) return le;</span></span><br><span class="line">        <span class="comment">//     return -1;</span></span><br><span class="line">        <span class="comment">// &#125;        </span></span><br><span class="line">        <span class="keyword">int</span> mid = (le + ri) / <span class="number">2</span>;</span><br><span class="line">       <span class="comment">// cout &lt;&lt; le &lt;&lt; &quot; &quot; &lt;&lt; ri &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// 左边有序</span></span><br><span class="line">        <span class="keyword">if</span>(nums[le] &lt; nums[mid] )&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[le] &lt;= target &amp;&amp; nums[mid] &gt;= target)</span><br><span class="line">                <span class="keyword">return</span> devideSearch(nums, le, mid,target);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> devideSearch(nums, mid + <span class="number">1</span>, ri,target);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid + <span class="number">1</span>] &lt;= target &amp;&amp; nums[ri] &gt;= target)</span><br><span class="line">                <span class="keyword">return</span> devideSearch(nums,mid + <span class="number">1</span>, ri,target);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> devideSearch(nums, le, mid,target);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="29-在排序数组中查找元素的第一个和最后一个位置"><a href="#29-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="29. 在排序数组中查找元素的第一个和最后一个位置"></a>29. 在排序数组中查找元素的第一个和最后一个位置</h4><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>], target = <span class="number">6</span></span><br><span class="line">输出: [<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>解题思路：<br> 这道题关键还是二分搜索， 当搜索到答案以后， 往两边找相同的！！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) &#123;</span><br><span class="line">             <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> mid = search(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">if</span>(mid == <span class="number">-1</span> ) &#123;</span><br><span class="line">            ans.push_back(mid);</span><br><span class="line">            ans.push_back(mid);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i = mid; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] != target) <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(i = mid; i &lt; nums.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] != target) <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(i<span class="number">-1</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> le, <span class="keyword">int</span> ri, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; nums[<span class="number">0</span>] || target &gt; nums[ri]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ri == le) <span class="keyword">return</span> target == nums[le] ? le : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (le + ri) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) <span class="keyword">return</span> search(nums,mid + <span class="number">1</span>, ri, target);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> search(nums,le, mid, target);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="30-组数之和"><a href="#30-组数之和" class="headerlink" title="30.组数之和"></a>30.组数之和</h4><blockquote>
<p> 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
</blockquote>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>解题思路： 我觉得这个回溯算法好简单呀！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        vint temp;</span><br><span class="line">        <span class="comment">//sort(candidates.begin(), candidates.end());  </span></span><br><span class="line">        search(candidates,ans, target, <span class="number">0</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(vint&amp; c,<span class="built_in">vector</span>&lt;vint&gt;&amp; ans, <span class="keyword">int</span> target, <span class="keyword">int</span> len, vint cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len == c.size()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = addup(cur);</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ans.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i] == cur) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(len &lt; c.size())&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt;len &lt;&lt; &quot; &quot; &lt;&lt;  sum&lt;&lt;endl;</span></span><br><span class="line">            search(c, ans, target, len+<span class="number">1</span>, cur);</span><br><span class="line">            cur.push_back(c[len]);       </span><br><span class="line">            search(c,ans, target, len, cur); <span class="comment">// 这里说可以重复</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addup</span><span class="params">(vint a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)&#123;</span><br><span class="line">                sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="31-旋转图形"><a href="#31-旋转图形" class="headerlink" title="31.旋转图形"></a>31.旋转图形</h4><blockquote>
<p>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。</p>
</blockquote>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>解题思路：先转置， 然后 在进行横排的移动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> x = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> y = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )&#123;</span><br><span class="line">                temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; x/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j++)&#123;</span><br><span class="line">                temp = matrix[j][i];</span><br><span class="line">                matrix[j][i] = matrix[j][x - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][x - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="32-字母异位词分组"><a href="#32-字母异位词分组" class="headerlink" title="32. 字母异位词分组"></a>32. 字母异位词分组</h4><blockquote>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;tea&quot;</span>, <span class="string">&quot;tan&quot;</span>, <span class="string">&quot;ate&quot;</span>, <span class="string">&quot;nat&quot;</span>, <span class="string">&quot;bat&quot;</span>],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">&quot;ate&quot;</span>,<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;tea&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;nat&quot;</span>,<span class="string">&quot;tan&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;bat&quot;</span>]</span><br><span class="line">]</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">所有输入均为小写字母。</span><br><span class="line">不考虑答案输出的顺序。</span><br></pre></td></tr></table></figure>

<p>解题思路： 可以说是暴力求解了， 把每一个单词都排序，排好序之后， map 一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; vvstr;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; str2vstr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        vvstr ans;</span><br><span class="line">        str2vstr str2vstr; for_ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strs.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> temp = strs[i];</span><br><span class="line">            sort(strs[i].begin(), strs[i].end());</span><br><span class="line">            for_ans[strs[i]].push_back(temp);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span>(str2vstr::iterator i = for_ans.begin(); i != for_ans.end(); i++)&#123;</span><br><span class="line">            ans.push_back(i-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="33-最大连续子数组"><a href="#33-最大连续子数组" class="headerlink" title="33.最大连续子数组"></a>33.最大连续子数组</h4><blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>],</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure>


<p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<p>解题思路： 使用dp的思想， 如果当前的连续和还是大于 0 的， 可以加到后面， 如果当前的连续和小于0了， 加到后面后面反而减小了， 所以不需要加到后面了！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans, cur;</span><br><span class="line">        cur =  <span class="number">0</span>;</span><br><span class="line">        ans = (<span class="keyword">unsigned</span>)(<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ans = ~ans;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size(); i ++ )&#123;</span><br><span class="line">             cur += nums[i];</span><br><span class="line">             ans = cur &gt; ans ? cur : ans;</span><br><span class="line">             <span class="keyword">if</span>( cur &lt; <span class="number">0</span>)</span><br><span class="line">                cur = <span class="number">0</span>;           </span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>分治法：暂无</p>
<h4 id="34-最大连续和"><a href="#34-最大连续和" class="headerlink" title="34. 最大连续和"></a>34. 最大连续和</h4><blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">解释: 我们可以先跳 <span class="number">1</span> 步，从位置 <span class="number">0</span> 到达 位置 <span class="number">1</span>, 然后再从位置 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个位置。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解题思路： 直接暴力就可以了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == nums.size() - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            arr = i + nums[i] &gt; arr ? i + nums[i] : arr;</span><br><span class="line">            <span class="keyword">if</span>(arr &lt;= i ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="35-合并区间"><a href="#35-合并区间" class="headerlink" title="35. 合并区间"></a>35. 合并区间</h4><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释: 区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>

<p>解题思路： 一开始想到的想到的是给 vector 的开始排序， 然后遍历一遍就可以知道结束的地方</p>
<p>后来发现， 这个是可以分开的， start 和 end 分开来也行！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vvint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = intervals.size();</span><br><span class="line">        vvint ans;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> start[len], end[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            start[i] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            end[i] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(start, start + len);</span><br><span class="line">        sort(end, end+ len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == len<span class="number">-1</span> || start[i + <span class="number">1</span>] &gt; end[i])&#123;<span class="comment">//最后一个直接放</span></span><br><span class="line">                vint tmp;</span><br><span class="line">                tmp.push_back(start[j]);</span><br><span class="line">                tmp.push_back(end[i]);</span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="34-不同路径"><a href="#34-不同路径" class="headerlink" title="34. 不同路径"></a>34. 不同路径</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200210100443.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如，上图是一个<span class="number">7</span> x <span class="number">3</span> 的网格。有多少可能的路径？</span><br><span class="line"></span><br><span class="line">说明：m 和 n 的值均不超过 <span class="number">100</span>。</span><br></pre></td></tr></table></figure>

<p>递归求解： 换来的是超时。。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        search(ans,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> &amp;ans, <span class="keyword">int</span> curm, <span class="keyword">int</span> curn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curm &gt; m || curn &gt; n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(curn == n &amp;&amp; curm == m)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curm &lt; m) search(ans,curm + <span class="number">1</span>,curn);</span><br><span class="line">        <span class="keyword">if</span>(curn &lt; n) search(ans,curm, curn + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>换用dp：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[m][n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>)    dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)  dp[i][j]= dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>) dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="35-不同路径Ⅱ"><a href="#35-不同路径Ⅱ" class="headerlink" title="35. 不同路径Ⅱ"></a>35. 不同路径Ⅱ</h4><p>题目一样，但是加上一个障碍物的存在， 思路一样的， 这个测试样例坑人的， 返回型是int的， 但是中间值是超过int的， 坑！！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.size();</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> dp[m][n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>)    dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)  dp[i][j]= dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>) dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">               <span class="keyword">if</span>(i &gt; <span class="number">8</span> &amp;&amp; j &gt; <span class="number">8</span>) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; dp[i][j] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="36-最小路径和"><a href="#36-最小路径和" class="headerlink" title="36.最小路径和"></a>36.最小路径和</h4><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p>解题思路： 这题也是dp 挺简单的， 值得注意的是  vvint 的速度执行 会 比  int 快！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = grid.size();</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function">vvint <span class="title">dp</span><span class="params">(y,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(x))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i ==<span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[i][j] = grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) dp[i][j] = min(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]) + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> ) dp[i][j] = dp[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span>  dp[i][j] = dp[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[y<span class="number">-1</span>][x<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="37-验证给定的字符串是否可以解释为十进制数字。"><a href="#37-验证给定的字符串是否可以解释为十进制数字。" class="headerlink" title="37.验证给定的字符串是否可以解释为十进制数字。"></a>37.验证给定的字符串是否可以解释为十进制数字。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;0&quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot; 0.1 &quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;1 a&quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;2e10&quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot; -90e3   &quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot; 1e&quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;e3&quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot; 6e-1&quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot; 99e2.5 &quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;53.5e93&quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&quot; --6 &quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;-+3&quot;</span> =&gt; <span class="literal">false</span></span><br><span class="line"><span class="string">&quot;95a54e53&quot;</span> =&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>编译原理的自动机！！！ 状态难画！ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">9</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">8</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">8</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">7</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">6</span>&#125;,&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">7</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">7</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> state=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            i+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j=s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[j]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            j-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>) state=a[state][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;e&#x27;</span>) state=a[state][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;.&#x27;</span>) state=a[state][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;+&#x27;</span>||s[i]==<span class="string">&#x27;-&#x27;</span>) state=a[state][<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(state==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(state==<span class="number">7</span>||state==<span class="number">1</span>||state==<span class="number">5</span>||state==<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="38-爬楼梯"><a href="#38-爬楼梯" class="headerlink" title="38. 爬楼梯"></a>38. 爬楼梯</h4><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方可以爬到楼顶呢？</p>
</blockquote>
<p>注意：给定 n 是一个正整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1.  1 阶 + 1 阶  2 阶</span><br></pre></td></tr></table></figure>

<p>解题思路： 简单的dp问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> a[n];</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>; a[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            a[i] = a[i<span class="number">-1</span>] + a[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="39-单词最短距离"><a href="#39-单词最短距离" class="headerlink" title="39. 单词最短距离"></a>39. 单词最短距离</h4><blockquote>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
</blockquote>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: word1 = <span class="string">&quot;horse&quot;</span>, word2 = <span class="string">&quot;ros&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>解题思路： 刚拿到这道题时完全没有思路可言， 我是看了题解才知道怎么做的！</p>
<p>还是dp， 又是dp！</p>
<p>dp [i] [j]: 表示  <code>word1</code> 到 <code>i</code> 位置转换成 <code>word2</code> 到 <code>j</code> 位置需要最少步数 </p>
<p>当 word1[i] == word2[j]，dp[i] [j] = dp[i-1] [j-1]；</p>
<p>当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1] [j-1], dp[i-1] [j], dp[i] [j-1]) + 1</p>
<p>其中，dp[i-1] [j-1] 表示替换操作，dp[i-1] [j] 表示删除操作，dp[i][j-1] 表示插入操作。</p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200214163734.png"></p>
<p>明白后还是挺简单的！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = word1.length();</span><br><span class="line">        <span class="keyword">int</span> y = word2.length();</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[x+<span class="number">1</span>][y+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= y; i++) dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i++) dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= y; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = min(min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]) , dp[i][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="40-颜色分类"><a href="#40-颜色分类" class="headerlink" title="40.颜色分类"></a>40.颜色分类</h4><blockquote>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
</blockquote>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p>解题思路： 三个指针， 分为三部分！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p0,cur,p2, len, tmp;</span><br><span class="line">        len = nums.size();</span><br><span class="line">        cur = p0 = <span class="number">0</span>;</span><br><span class="line">        p2 = len - <span class="number">1</span>;        </span><br><span class="line">        <span class="keyword">while</span>(cur &lt;= p2)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(nums[cur])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    cur++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    tmp = nums[cur];</span><br><span class="line">                    nums[cur++] = nums[p0];</span><br><span class="line">                    nums[p0++] = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    tmp = nums[p2];</span><br><span class="line">                    nums[p2--] = nums[cur];</span><br><span class="line">                    nums[cur] = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="42-单词搜索"><a href="#42-单词搜索" class="headerlink" title="42. 单词搜索"></a>42. 单词搜索</h4><blockquote>
<p> 给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
</blockquote>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board &#x3D;</span><br><span class="line">[</span><br><span class="line">  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],</span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word &#x3D; &quot;ABCCED&quot;, 返回 true.</span><br><span class="line">给定 word &#x3D; &quot;SEE&quot;, 返回 true.</span><br><span class="line">给定 word &#x3D; &quot;ABCB&quot;, 返回 false.</span><br></pre></td></tr></table></figure>

<p>解题思路： 这道题最难的是， 回溯，   <strong>找过的路不能再找， 所以临时改变一下路径</strong>， 搜索完了后==重新恢复数据==，记得多看这道题， 经常出现！！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(backtrack(board, word, <span class="number">0</span>, i , j))&#123; <span class="comment">// 从二维表格的每一个格子出发</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word, <span class="keyword">int</span> wordIndex, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( board[x][y] != word[wordIndex])&#123; <span class="comment">// 当前位的字母不相等，此路不通</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(word.size() - <span class="number">1</span>  == wordIndex)&#123; <span class="comment">// 最后一个字母也相等, 返回成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> tmp = board[x][y]; </span><br><span class="line">        board[x][y] = <span class="number">0</span>; <span class="comment">// 避免该位重复使用</span></span><br><span class="line">        wordIndex++;</span><br><span class="line">        <span class="keyword">if</span>((x &gt; <span class="number">0</span> &amp;&amp; backtrack(board, word, wordIndex, x - <span class="number">1</span>, y)) <span class="comment">// 往左走</span></span><br><span class="line">        || (y &gt; <span class="number">0</span> &amp;&amp; backtrack(board, word, wordIndex, x, y - <span class="number">1</span>)) <span class="comment">// 往上走</span></span><br><span class="line">        || (x &lt; board.size() - <span class="number">1</span> &amp;&amp; backtrack(board, word, wordIndex, x + <span class="number">1</span>, y)) <span class="comment">// 往右走</span></span><br><span class="line">        || (y &lt; board[<span class="number">0</span>].size() - <span class="number">1</span> &amp;&amp; backtrack(board, word, wordIndex, x, y + <span class="number">1</span>)))&#123; <span class="comment">// 往下走</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">true</span>; <span class="comment">// 其中一条能走通，就算成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = tmp; <span class="comment">// 如果都不通，则回溯上一状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="43-pow-x-n"><a href="#43-pow-x-n" class="headerlink" title="43. pow(x, n)"></a>43. pow(<em>x</em>, <em>n</em>)</h4><blockquote>
<p>实现 pow(<em>x</em>, <em>n</em>) ，即计算 x 的 n 次幂函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>

<p>解题思路： </p>
<p>这道题我认为关键的地方是分治法， 把底层会重复计算的数据删除掉，不去计算！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = n &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> m = n;</span><br><span class="line">        m = m &lt; <span class="number">0</span> ? -m : m;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>) <span class="keyword">return</span> flag ? <span class="number">1</span>/x : x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> flag ? <span class="number">1</span> / (x * x) : x * x;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> temp = myPow(x, (flag ? - m/<span class="number">2</span>: m/<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">0</span>)&#123;             </span><br><span class="line">                <span class="keyword">return</span> temp * temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> temp * temp  * (flag ? <span class="number">1</span>/x : x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="44-八皇后问题"><a href="#44-八皇后问题" class="headerlink" title="44.八皇后问题"></a>44.八皇后问题</h4><blockquote>
<p> n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
</blockquote>
<p> <img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200223195130.png"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>解题思路： 回溯， 当此时是可以求解的， 把当前值置为1， 搜索完后恢复状态， 写了1.30 h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; vvstr;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vvint;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="function">vvint <span class="title">m</span><span class="params">(n,vint(n))</span></span>;</span><br><span class="line">        vvstr ans;</span><br><span class="line">        search(<span class="number">0</span>, n,ans, m);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> line,<span class="keyword">int</span> n, vvstr&amp; ans, vvint&amp; m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(line == n)&#123;</span><br><span class="line">            <span class="built_in">string</span> temp;</span><br><span class="line">            vstr an;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(m[i][j] == <span class="number">0</span>) temp += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> temp += <span class="string">&quot;Q&quot;</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                an.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(an);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">// 对于这一行的每一个作为答案</span></span><br><span class="line">           <span class="comment">// cout &lt;&lt; line &lt;&lt; &quot; i: &quot; &lt;&lt; i  &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123; </span><br><span class="line">                <span class="keyword">if</span>(m[j][i] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 检查列</span></span><br><span class="line">                <span class="comment">// 斜</span></span><br><span class="line">                <span class="keyword">int</span> x1 = line - (i - j);</span><br><span class="line">                <span class="keyword">if</span>( x1 &gt;= <span class="number">0</span> &amp;&amp;  x1 &lt; n &amp;&amp;  m[x1][j] == <span class="number">1</span> ) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                x1 = line + (i - j);</span><br><span class="line">                <span class="keyword">if</span>(x1 &gt;= <span class="number">0</span> &amp;&amp; x1 &lt; n &amp;&amp; m[x1][j] == <span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">               <span class="comment">// cout &lt;&lt; &quot; &quot; &lt;&lt; j;        </span></span><br><span class="line">                <span class="keyword">if</span>(j == n - <span class="number">1</span>)&#123; <span class="comment">//列检查完毕</span></span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">                    m[line][i] = <span class="number">1</span>;</span><br><span class="line">                    search(line + <span class="number">1</span>, n, ans, m);</span><br><span class="line">                    m[line][i] = <span class="number">0</span>;</span><br><span class="line">                &#125;                  </span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//cout &lt;&lt; endl;       </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="44-二叉树的中序遍历"><a href="#44-二叉树的中序遍历" class="headerlink" title="44.  二叉树的中序遍历"></a>44.  二叉树的中序遍历</h4><p>给定一个二叉树，返回它的中序遍历。</p>
<p>示例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,null,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>解题思路： 递归太简单了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">            vint ans;</span><br><span class="line">            traverse(root,ans);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, vint&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            traverse(node-&gt;left, ans);</span><br><span class="line">            ans.push_back(node-&gt;val);</span><br><span class="line">            traverse(node-&gt;right, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归， 多看看！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//递归是使用了函数的栈， 迭代的话模拟出一个栈给它  </span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">          <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">while</span>(p || !st.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                st.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            ans.push_back(p-&gt;val);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="45-不同的二叉搜索树"><a href="#45-不同的二叉搜索树" class="headerlink" title="45.不同的二叉搜索树"></a>45.不同的二叉搜索树</h4><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<p><strong>示例:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释:</span><br><span class="line">给定 n = <span class="number">3</span>, 一共有 <span class="number">5</span> 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>         <span class="number">3</span>     <span class="number">3</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>      <span class="number">2</span></span><br><span class="line">    /     /       \                 \</span><br><span class="line">   <span class="number">2</span>     <span class="number">1</span>         <span class="number">2</span>                 <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>这道题主要推导dp的递推式子！</p>
<p>问题是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p>
<ul>
<li><p>G(n): 长度为n的序列的不同二叉搜索树个数。</p>
</li>
<li><p>F(i,n): 以i为根的不同二叉搜索树个数(1 \leq i \leq n1≤i≤n)。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200301195813.png"></p>
<p><img src="https://raw.githubusercontent.com/Fierygit/picbed/master/20200301195932.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> g[n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        g[<span class="number">0</span>] = g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">                g[i] += g[j<span class="number">-1</span>] * g[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="46-验证二叉搜索树"><a href="#46-验证二叉搜索树" class="headerlink" title="46.验证二叉搜索树"></a>46.验证二叉搜索树</h4><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>思路不难： 递归处理， 中间的数据会超int， 带取值域搜索</p>
<p>或者  中序遍历， 带一个值搜索！！！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(TreeNode* current,<span class="keyword">long</span> left,<span class="keyword">long</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(current-&gt;val&lt;=left||current-&gt;val&gt;=right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValid(current-&gt;left,left,current-&gt;val)</span><br><span class="line">            &amp;&amp;isValid(current-&gt;right,current-&gt;val,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValid(root,LONG_MIN,LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="47-对称二叉树"><a href="#47-对称二叉树" class="headerlink" title="47. 对称二叉树"></a>47. 对称二叉树</h4><blockquote>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
</blockquote>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>解题思路： </p>
<p>基于递归的解决方案！ 这个较为简单！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isValid(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(TreeNode* left, TreeNode* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">NULL</span> || right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt; val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValid(left-&gt;left, right-&gt;right) &amp;&amp; </span><br><span class="line">            isValid(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归的方法， 使用一个栈来模拟方法的递归过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; le, ri;</span><br><span class="line">        le.push(root-&gt;left);</span><br><span class="line">        ri.push(root-&gt;right);</span><br><span class="line">        TreeNode * t1, * t2;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(le.empty() &amp;&amp; ri.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(le.empty() || ri.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            t1 = le.top(); t2 = ri.top();</span><br><span class="line">            le.pop(); ri.pop();</span><br><span class="line">            <span class="keyword">if</span>(t1 == <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(t1== <span class="literal">NULL</span> || t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            le.push(t1-&gt;right);ri.push(t2-&gt;left);</span><br><span class="line">            le.push(t1-&gt;left); ri.push(t2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="48-二叉树的层次遍历"><a href="#48-二叉树的层次遍历" class="headerlink" title="48. 二叉树的层次遍历"></a>48. 二叉树的层次遍历</h4><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>​    按照遍历的思想模拟</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vvint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vvint ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">set</span> = &#123;root&#125;;</span><br><span class="line">        solve(ans,<span class="built_in">set</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vvint &amp;ans, <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">set</span>)</span></span>&#123;</span><br><span class="line">        vint tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">set</span>.size(); i++)</span><br><span class="line">            tmp.push_back(<span class="built_in">set</span>[i]-&gt;val);</span><br><span class="line">        ans.push_back(tmp);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">set</span>.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>[i]-&gt;left) nodes.push_back(<span class="built_in">set</span>[i]-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>[i]-&gt;right) nodes.push_back(<span class="built_in">set</span>[i]-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nodes.size() != <span class="number">0</span>) solve(ans, nodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="49-二叉树的最大深度"><a href="#49-二叉树的最大深度" class="headerlink" title="49. 二叉树的最大深度"></a>49. 二叉树的最大深度</h4><p>难度简单471收藏分享切换为英文关注反馈</p>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<p>解题思路： 练手题， 太简单了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        solve(ans,<span class="number">0</span>,root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> &amp;ans, <span class="keyword">int</span> cur, TreeNode* cu)</span></span>&#123;</span><br><span class="line">        ans = max(ans,cur);</span><br><span class="line">        <span class="keyword">if</span>(cu == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        solve(ans, cur + <span class="number">1</span>, cu-&gt;left);</span><br><span class="line">        solve(ans, cur + <span class="number">1</span>, cu-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="50-从前序与中序遍历序列构造二叉树"><a href="#50-从前序与中序遍历序列构造二叉树" class="headerlink" title="50. 从前序与中序遍历序列构造二叉树"></a>50. 从前序与中序遍历序列构造二叉树</h4><blockquote>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
</blockquote>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>解题思路： 按要求来！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> solve(preorder,inorder, <span class="number">0</span>,inorder.size(), <span class="number">0</span>,preorder.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode * <span class="title">solve</span><span class="params">(vint&amp; pre, vint&amp; ino, <span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> b1, <span class="keyword">int</span> b2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a1 &gt;= a2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> first = pre[a1];</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        TreeNode* root= <span class="keyword">new</span> TreeNode(first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = b1; i &lt; b2; i ++)</span><br><span class="line">            <span class="keyword">if</span>(ino[i] == first )&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; a1 &lt;&lt; &quot; &quot; &lt;&lt; a2  &lt;&lt; &quot; &quot; &lt;&lt; b1 &lt;&lt; &quot; &quot; &lt;&lt; b2 &lt;&lt; endl;</span></span><br><span class="line">        root-&gt;left = solve(pre,ino,a1 + <span class="number">1</span>, a1 + index - b1 + <span class="number">1</span>, b1, index);</span><br><span class="line">        root-&gt;right = solve(pre,ino,a1 + index - b1 + <span class="number">1</span>,a2, index + <span class="number">1</span>, b2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="51-只出现一次的数字"><a href="#51-只出现一次的数字" class="headerlink" title="51. 只出现一次的数字"></a>51. 只出现一次的数字</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>解题思路：真的没有想到这么巧， 使用位运算, 相同的异或了之后， 数据不变</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">                num ^= nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="52-环形链表"><a href="#52-环形链表" class="headerlink" title="52. 环形链表"></a>52. 环形链表</h4><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p>快慢指针，快点指针会追上慢的指针！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fir = head;</span><br><span class="line">        ListNode* sec = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fir-&gt;next != <span class="literal">NULL</span>) fir = fir-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(sec-&gt;next != <span class="literal">NULL</span>) sec = sec-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(sec-&gt;next != <span class="literal">NULL</span>) sec = sec -&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fir == sec)&#123;<span class="comment">// 值有可能重复</span></span><br><span class="line">                <span class="keyword">if</span>(fir-&gt;next ==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="53-环形链表-II"><a href="#53-环形链表-II" class="headerlink" title="53. 环形链表 II"></a>53. 环形链表 II</h4><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p>解题思路： 我一开始想到的是让一个节点先走，然后面那个追相等的时候，判断有环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* fastPtr=head, *slowPtr=head;</span><br><span class="line">	<span class="comment">// 让fast与slow指针第一次相遇</span></span><br><span class="line">	<span class="keyword">while</span> (fastPtr!=<span class="literal">NULL</span> &amp;&amp; fastPtr-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		fastPtr = fastPtr-&gt;next-&gt;next;</span><br><span class="line">		slowPtr = slowPtr-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (fastPtr==slowPtr)&#123;</span><br><span class="line">			<span class="comment">// 从相遇点再走“非环部分长度”一定可以再次走到环起点</span></span><br><span class="line">			fastPtr = head;</span><br><span class="line">			<span class="keyword">while</span> (fastPtr != slowPtr)&#123;</span><br><span class="line">				fastPtr = fastPtr-&gt;next;</span><br><span class="line">				slowPtr = slowPtr-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fastPtr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h4 id="54-LRU缓存机制"><a href="#54-LRU缓存机制" class="headerlink" title="54. LRU缓存机制"></a>54. LRU缓存机制</h4><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:</p>
<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>模仿 redis 的设计思路，  索引用map， 然后移动使用 list， 找基于 map O（1）时间复杂度， 移动基于链表， 也是O（1）时间复杂度！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> key,val;</span><br><span class="line">        List* next, *pre;</span><br><span class="line">        List(<span class="keyword">int</span> key, <span class="keyword">int</span> v)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;val = v;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> capacity, max;</span><br><span class="line">    List *head, *tail;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, List*&gt; cap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;max = capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">        head = tail = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mv2head</span><span class="params">(List* tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp != head)&#123;                 <span class="comment">// 如果不是头结点, 头结点不用移动</span></span><br><span class="line">            List *p = tmp-&gt;pre;</span><br><span class="line">            <span class="keyword">if</span>(tmp == tail)&#123;</span><br><span class="line">                p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                tail = p;     </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = tmp-&gt;next;</span><br><span class="line">                tmp-&gt;next-&gt;pre = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//放到前面</span></span><br><span class="line">            tmp-&gt;next = head;</span><br><span class="line">            head-&gt;pre = tmp;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;capacity &gt; <span class="keyword">this</span>-&gt;max)&#123;</span><br><span class="line">            cap[tail-&gt;key] = <span class="literal">NULL</span>;  </span><br><span class="line">            capacity--;</span><br><span class="line">            tail = tail-&gt;pre;  <span class="comment">// 空的容器， 不考虑</span></span><br><span class="line">            <span class="keyword">delete</span> tail-&gt;next;</span><br><span class="line">            tail-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        List* tmp = cap[key];</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;get key: &quot; &lt;&lt; key  &lt;&lt; &quot; &quot; &lt;&lt; tmp&lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        mv2head(tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        List* tmp = cap[key];</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="literal">NULL</span>)&#123;  <span class="comment">// 不存在键</span></span><br><span class="line">            List* newL = <span class="keyword">new</span> List(key,value);</span><br><span class="line">            cap[key] = newL;</span><br><span class="line">            <span class="keyword">this</span>-&gt;capacity++;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                tail = head = newL;</span><br><span class="line">                newL-&gt;pre = newL-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head-&gt;pre = newL;</span><br><span class="line">            newL-&gt;next = head;</span><br><span class="line">            head = newL;</span><br><span class="line">            rm();   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp-&gt;val = value;</span><br><span class="line">            mv2head(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>




























        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2019/12/28/notepad/algorithm/exercise/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/"
                        >
                            <span class="left arrow-icon flex-center" >
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">大数运算</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2019/12/28/notepad/algorithm/exercise/sorting/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">排序</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center" >
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                    
                </main>

            </div>

            <div class="page-main-content-bottom">
                <!--
 * @Author: Firefly
 * @Date: 2020-12-06 11:25:04
 * @Descripttion: 
 * @LastEditTime: 2020-12-06 17:25:59
-->
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2017</span> -
            
            2020 <i class="fas fa-heart icon-animate"></i> <a href="/">Firefly</a>
        </div>
        
    </div>
</footer>

            </div>
        </div>
    </main>

    <div class="sidebar-tools">
        <div class="tools-container">
    <ul class="tools-list">
        
            <li class="search popup-trigger">
                <i class="fas fa-search"></i>
            </li>
        

        

        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

    </ul>
</div>

    </div>

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">

    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center">
            <i class="fas fa-arrow-up"></i>
        </li>

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="tools-ul-1">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

    </ul>
</div>

    </div>

    <!-- page aside -->
    <aside class="page-aside">
        
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode100-%E7%BB%83%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">leetcode100 练习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.两数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">1.0.2.</span> <span class="nav-text">2.两数相加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">1.0.3.</span> <span class="nav-text">3.无重复字符的最长子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0todo"><span class="nav-number">1.0.4.</span> <span class="nav-text">4.寻找两个有序数组的中位数todo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">1.0.5.</span> <span class="nav-text">5.最长回文子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Z%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2"><span class="nav-number">1.0.6.</span> <span class="nav-text">6. Z字型变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">1.0.7.</span> <span class="nav-text">7.整数反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi"><span class="nav-number">1.0.8.</span> <span class="nav-text">8.字符串转换整数 (atoi)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E5%9B%9E%E6%96%87%E6%95%B0"><span class="nav-number">1.0.9.</span> <span class="nav-text">9.回文数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">1.0.10.</span> <span class="nav-text">10.正则表达式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">1.0.11.</span> <span class="nav-text">11.盛最多水的容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="nav-number">1.0.12.</span> <span class="nav-text">12.整数转罗马数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="nav-number">1.0.13.</span> <span class="nav-text">13. 罗马数字转整数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="nav-number">1.0.14.</span> <span class="nav-text">14.最长公共子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.0.15.</span> <span class="nav-text">15. 三数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.0.16.</span> <span class="nav-text">16.最接近的三数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-number">1.0.17.</span> <span class="nav-text">17. 电话号码的字母组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-%E5%81%9A%E4%B8%8D%E5%87%BA"><span class="nav-number">1.0.18.</span> <span class="nav-text">18. 做不出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.0.19.</span> <span class="nav-text">19. 删除链表的倒数第N个节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">1.0.20.</span> <span class="nav-text">20.有效的括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.0.21.</span> <span class="nav-text">21.合并两个有序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-number">1.0.22.</span> <span class="nav-text">22.有效括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.0.23.</span> <span class="nav-text">23.合并K个排序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8-todo"><span class="nav-number">1.0.24.</span> <span class="nav-text">24.两两交换链表 todo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.0.25.</span> <span class="nav-text">25.k个一组翻转链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">1.0.26.</span> <span class="nav-text">26. 下一个排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-number">1.0.27.</span> <span class="nav-text">27. 最长有效括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.0.28.</span> <span class="nav-text">28. 搜索旋转排序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.0.29.</span> <span class="nav-text">29. 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-%E7%BB%84%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.0.30.</span> <span class="nav-text">30.组数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%BD%A2"><span class="nav-number">1.0.31.</span> <span class="nav-text">31.旋转图形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-number">1.0.32.</span> <span class="nav-text">32. 字母异位词分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">1.0.33.</span> <span class="nav-text">33.最大连续子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C"><span class="nav-number">1.0.34.</span> <span class="nav-text">34. 最大连续和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">1.0.35.</span> <span class="nav-text">35. 合并区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">1.0.36.</span> <span class="nav-text">34. 不同路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1"><span class="nav-number">1.0.37.</span> <span class="nav-text">35. 不同路径Ⅱ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">1.0.38.</span> <span class="nav-text">36.最小路径和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#37-%E9%AA%8C%E8%AF%81%E7%BB%99%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A7%A3%E9%87%8A%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97%E3%80%82"><span class="nav-number">1.0.39.</span> <span class="nav-text">37.验证给定的字符串是否可以解释为十进制数字。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#38-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">1.0.40.</span> <span class="nav-text">38. 爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39-%E5%8D%95%E8%AF%8D%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="nav-number">1.0.41.</span> <span class="nav-text">39. 单词最短距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#40-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="nav-number">1.0.42.</span> <span class="nav-text">40.颜色分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-number">1.0.43.</span> <span class="nav-text">42. 单词搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#43-pow-x-n"><span class="nav-number">1.0.44.</span> <span class="nav-text">43. pow(x, n)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#44-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.45.</span> <span class="nav-text">44.八皇后问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#44-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.0.46.</span> <span class="nav-text">44.  二叉树的中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#45-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.0.47.</span> <span class="nav-text">45.不同的二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.0.48.</span> <span class="nav-text">46.验证二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#47-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.0.49.</span> <span class="nav-text">47. 对称二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#48-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">1.0.50.</span> <span class="nav-text">48. 二叉树的层次遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#49-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.0.51.</span> <span class="nav-text">49. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.0.52.</span> <span class="nav-text">50. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#51-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">1.0.53.</span> <span class="nav-text">51. 只出现一次的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#52-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">1.0.54.</span> <span class="nav-text">52. 环形链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="nav-number">1.0.55.</span> <span class="nav-text">53. 环形链表 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#54-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-number">1.0.56.</span> <span class="nav-text">54. LRU缓存机制</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        
    </aside>

    <!-- image viewer -->
    <div class="image-viewer-container">
    <div class="img-box">
        <img src="">
    </div>
</div>


</div>



    <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-icon">
            <i class="fas fa-search"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/local-search.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/left-side-toggle.js"></script>

    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/code-copy.js"></script>
    

    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.0.3/source/js/toc.js"></script>
    


</body>
</html>